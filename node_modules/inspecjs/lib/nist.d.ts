import { ControlStatus } from './compat_wrappers';
type ParseNist = NistControl | NistRevision | null;
export interface CanonizationConfig {
    max_specifiers?: number;
    pad_zeros?: boolean;
    allow_letters?: boolean;
    add_spaces?: boolean;
    add_parens?: boolean;
    add_periods?: boolean;
}
export declare const DEFAULT_CANONIZATION_CONFIG: {
    max_specifiers: number;
    pad_zeros: boolean;
    allow_letters: boolean;
    add_spaces: boolean;
    add_parens: boolean;
    add_periods: boolean;
};
export declare class NistControl {
    subSpecifiers: string[];
    rawText?: string;
    constructor(subSpecs: string[], rawRext?: string);
    contains(other: NistControl): boolean;
    compare_lineage(other: NistControl): number;
    localCompare(other: NistControl): number;
    get family(): string | undefined;
    canonize(c?: CanonizationConfig): string;
}
export declare class NistRevision {
    revNum: number;
    constructor(revNum: number);
}
export declare function parse_nist(rawNist: string): ParseNist;
export declare function is_control(x: NistControl | NistRevision | null): x is NistControl;
export declare function is_revision(x: NistControl | NistRevision | null): x is NistRevision;
export interface CategoryItemRequirements {
    status: ControlStatus;
}
export type ControlGroupStatus = ControlStatus | 'Empty';
export declare function compare_statuses(a: ControlGroupStatus, b: ControlGroupStatus): number;
export declare function updateStatus(group: ControlGroupStatus, control: ControlStatus): ControlGroupStatus;
export interface NistHierarchyNode {
    control: NistControl;
    children: NistHierarchyNode[];
}
export type NistHierarchy = NistHierarchyNode[];
export declare const FULL_NIST_HIERARCHY: Readonly<NistHierarchy>;
export {};
