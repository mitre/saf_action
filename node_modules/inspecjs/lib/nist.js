"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FULL_NIST_HIERARCHY = exports.updateStatus = exports.compare_statuses = exports.is_revision = exports.is_control = exports.parse_nist = exports.NistRevision = exports.NistControl = void 0;
const raw_nist_1 = require("./raw_nist");
const NIST_FAMILY_RE = /^[A-Z]{2}$/;
const NIST_CONTROL_RE = /^([A-Z]{2})-([0-9]+)(.{0,60})$/;
const SPEC_SPLITTER = /[\s\(\)\.]+/;
const REV_RE = /^rev[\s_.]+(\d+)$/i;
function default_partial_config(c) {
    return {
        pad_zeros: false,
        allow_letters: true,
        add_spaces: true,
        add_parens: true,
        add_periods: true,
        ...c
    };
}
class NistControl {
    constructor(subSpecs, rawRext) {
        this.subSpecifiers = subSpecs;
        this.rawText = rawRext;
    }
    contains(other) {
        return this.compare_lineage(other) !== -1;
    }
    compare_lineage(other) {
        if (this.subSpecifiers.length > other.subSpecifiers.length) {
            return -1;
        }
        for (let i = 0; i < this.subSpecifiers.length; i++) {
            if (this.subSpecifiers[i] !== other.subSpecifiers[i]) {
                return -1;
            }
        }
        return other.subSpecifiers.length - this.subSpecifiers.length;
    }
    localCompare(other) {
        const aChain = this.subSpecifiers;
        const bChain = other.subSpecifiers;
        for (let i = 0; i < aChain.length && i < bChain.length; i++) {
            const idA = aChain[i];
            const idB = bChain[i];
            const lc = idA.localeCompare(idB, 'en', { numeric: true });
            if (lc) {
                return lc;
            }
        }
        return aChain.length - bChain.length;
    }
    get family() {
        if (this.subSpecifiers.length) {
            return this.subSpecifiers[0];
        }
        else {
            return undefined;
        }
    }
    canonize(config) {
        config = default_partial_config(config);
        const ss = this.subSpecifiers;
        let s = this.family || '';
        if (ss.length > 1) {
            s += '-';
        }
        for (let i = 1; i < ss.length && i < config.max_specifiers; i++) {
            let spec = ss[i];
            if (!Number.isNaN(Number.parseInt(spec))) {
                if (config.pad_zeros && spec.length < 2) {
                    spec = '0' + spec;
                }
                if (i > 1) {
                    if (config.add_parens) {
                        spec = `(${spec})`;
                    }
                    if (config.add_spaces) {
                        spec = ' ' + spec;
                    }
                }
                s += spec;
            }
            else if (config.allow_letters) {
                if (config.add_spaces) {
                    s += ' ';
                }
                s += spec;
                if (config.add_periods) {
                    s += '.';
                }
            }
        }
        return s;
    }
}
exports.NistControl = NistControl;
class NistRevision {
    constructor(revNum) {
        this.revNum = revNum;
    }
}
exports.NistRevision = NistRevision;
function parse_nist(rawNist) {
    const revMatch = rawNist.match(REV_RE);
    if (revMatch) {
        return new NistRevision(Number.parseInt(revMatch[1]));
    }
    const famMatch = rawNist.match(NIST_FAMILY_RE);
    if (famMatch) {
        return new NistControl([famMatch[0]], famMatch[0]);
    }
    const fullMatch = rawNist.match(NIST_CONTROL_RE);
    if (!fullMatch) {
        return null;
    }
    const family = fullMatch[1];
    const controlNum = fullMatch[2];
    const subspecsRaw = (fullMatch[3] || '').trim();
    const subSpecs = [family, controlNum];
    let subspecsSplit = subspecsRaw.split(SPEC_SPLITTER);
    subspecsSplit = subspecsSplit.filter((s) => s !== '');
    return new NistControl(subSpecs.concat(subspecsSplit), rawNist);
}
exports.parse_nist = parse_nist;
function is_control(x) {
    if (x && x.subSpecifiers !== undefined) {
        return true;
    }
    return false;
}
exports.is_control = is_control;
function is_revision(x) {
    if (x && x.revNum !== undefined) {
        return true;
    }
    return false;
}
exports.is_revision = is_revision;
function compare_statuses(a, b) {
    const precedence = [
        'Empty',
        'From Profile',
        'Not Applicable',
        'Not Reviewed',
        'Passed',
        'Failed',
        'Profile Error'
    ];
    const idA = precedence.indexOf(a);
    const idB = precedence.indexOf(b);
    return idA - idB;
}
exports.compare_statuses = compare_statuses;
function updateStatus(group, control) {
    if (compare_statuses(group, control) > 0) {
        return control;
    }
    else {
        return group;
    }
}
exports.updateStatus = updateStatus;
function _control_parent(c) {
    if (c.subSpecifiers.length) {
        return new NistControl(c.subSpecifiers.slice(0, c.subSpecifiers.length - 1));
    }
    else {
        return null;
    }
}
function _key_for(c) {
    return c.subSpecifiers.join('-');
}
function _generate_full_nist_hierarchy() {
    const roots = raw_nist_1.ALL_NIST_FAMILIES.map((family) => {
        return {
            control: new NistControl([family], family),
            children: []
        };
    });
    const map = {};
    roots.forEach((r) => {
        map[_key_for(r.control)] = r;
    });
    raw_nist_1.ALL_NIST_CONTROL_NUMBERS.forEach((n) => {
        const asControl = parse_nist(n);
        if (!asControl) {
            throw new Error(`Invalid nist control constant ${n}`);
        }
        const key = _key_for(asControl);
        let asNode;
        if (map[key]) {
            asNode = map[key];
            asNode.control = asControl;
        }
        else {
            asNode = {
                control: asControl,
                children: []
            };
            map[key] = asNode;
        }
        const parent = _control_parent(asControl);
        if (!parent) {
            roots.push({
                control: asControl,
                children: []
            });
        }
        else {
            const parentKey = _key_for(parent);
            const parentNode = map[parentKey];
            if (parentNode) {
                parentNode.children.push(asNode);
            }
            else {
                map[parentKey] = {
                    control: parent,
                    children: [asNode]
                };
            }
        }
    });
    return roots;
}
exports.FULL_NIST_HIERARCHY = _generate_full_nist_hierarchy();
//# sourceMappingURL=nist.js.map