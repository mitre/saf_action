"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.contextualizeProfile = exports.contextualizeEvaluation = void 0;
const compat_wrappers_1 = require("./compat_wrappers");
class ContextualizedControlImp {
    constructor(data, sourcedFrom, extendedBy, extendsFrom) {
        this.data = data;
        this.sourcedFrom = sourcedFrom;
        this.hdf = (0, compat_wrappers_1.hdfWrapControl)(data);
        this.extendedBy = extendedBy;
        this.extendsFrom = extendsFrom;
    }
    get root() {
        if (this.extendsFrom.length) {
            return this.extendsFrom[0].root;
        }
        return this;
    }
    get is_redundant() {
        return (!this.data.code ||
            this.data.code.trim() === '' ||
            (this.extendsFrom.length > 0 && this.data.code === this.root.data.code));
    }
    get full_code() {
        if (this.extendsFrom.length) {
            const ancestor = this.extendsFrom[0];
            if (this.is_redundant) {
                return ancestor.full_code;
            }
            else {
                return `\
=========================================================
# Profile name: ${this.sourcedFrom.data.name}
=========================================================

${this.data.code}

${this.extendsFrom[0].full_code}`.trim();
            }
        }
        else {
            return `\
=========================================================
# Profile name: ${this.sourcedFrom.data.name}
=========================================================

${this.data.code}`.trim();
        }
    }
}
function contextualizeEvaluation(evaluation) {
    const evalContext = {
        data: evaluation,
        contains: []
    };
    for (const profile of evaluation.profiles) {
        const evalProfileContext = {
            data: profile,
            sourcedFrom: evalContext,
            extendedBy: [],
            extendsFrom: [],
            contains: []
        };
        evalContext.contains.push(evalProfileContext);
    }
    for (const profile of evalContext.contains) {
        const asExec = profile.data;
        if (asExec.parent_profile !== undefined) {
            const parent = evalContext.contains.find((p) => p.data.name === asExec.parent_profile);
            if (parent) {
                parent.extendsFrom.push(profile);
                profile.extendedBy.push(parent);
            }
        }
    }
    const allControls = [];
    for (const profile of evalContext.contains) {
        const pControls = profile.data.controls;
        profile.contains = pControls.map((c) => {
            return new ContextualizedControlImp(c, profile, [], []);
        });
        allControls.push(...profile.contains);
    }
    for (const cc of allControls) {
        if (cc.sourcedFrom.extendsFrom.length || cc.sourcedFrom.extendedBy.length) {
            if (cc.sourcedFrom.extendsFrom.length === 0) {
                continue;
            }
            for (const extendedProfile of cc.sourcedFrom.extendsFrom) {
                const ancestor = extendedProfile.contains.find((c) => c.data.id === cc.data.id);
                if (ancestor) {
                    ancestor.extendedBy.push(cc);
                    cc.extendsFrom.push(ancestor);
                    break;
                }
            }
        }
        else {
            const sameId = allControls.filter((c) => c.data.id === cc.data.id);
            let sameIdPopulated = sameId.find((c) => c.hdf.segments && c.hdf.segments.length);
            if (!sameIdPopulated) {
                sameIdPopulated = sameId[0];
            }
            if (Object.is(cc, sameIdPopulated)) {
                continue;
            }
            else {
                sameIdPopulated.extendedBy.push(cc);
                cc.extendsFrom.push(sameIdPopulated);
            }
        }
    }
    return evalContext;
}
exports.contextualizeEvaluation = contextualizeEvaluation;
function contextualizeProfile(profile) {
    const profileContext = {
        data: profile,
        extendedBy: [],
        extendsFrom: [],
        contains: [],
        sourcedFrom: null
    };
    for (const c of profile.controls) {
        const result = new ContextualizedControlImp(c, profileContext, [], []);
        profileContext.contains.push(result);
    }
    return profileContext;
}
exports.contextualizeProfile = contextualizeProfile;
//# sourceMappingURL=context.js.map