"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProfileControl = exports.ExecControl = void 0;
const nist_1 = require("../nist");
const profileError = 'Profile Error';
class HDFControl10 {
    constructor(forControl, isProfile, waived, attested, attestationStatus) {
        this.descriptions = {};
        this.wraps = forControl;
        this.waived = waived;
        this.attested = attested;
        this.attestationStatus = attestationStatus;
        this.isProfile = isProfile;
        const tempNistTags = HDFControl10.compute_raw_nist_tags(this.wraps);
        this.rawNistTags = Array.isArray(tempNistTags)
            ? tempNistTags
            : [tempNistTags];
        const tmp = HDFControl10.compute_proper_nist_tags(this.rawNistTags);
        this.parsedNistTags = tmp[0];
        this.parsedNistRevision = tmp[1];
        this.severity = HDFControl10.compute_severity(this.wraps);
    }
    get finding_details() {
        switch (this.status) {
            case 'Failed':
                return `One or more of the automated tests failed or was inconclusive for the control:\n\n${this.message}\n`;
            case 'Passed':
                return `All Automated tests passed for the control:\n\n${this.message}\n`;
            case 'Not Reviewed':
                return `Automated test skipped due to known accepted condition in the control:\n\n${this.message}\n`;
            case 'Not Applicable':
                return `Justification:\n\n${this.message}\n`;
            case profileError:
                if (!this.status_list || this.status_list.length === 0) {
                    return 'No describe blocks were run in this control';
                }
                else if (this.message !== undefined) {
                    return `Exception:\n\n${this.message}\n`;
                }
                else {
                    return `No details available for this control.`;
                }
            case 'From Profile':
                return 'No tests are run in a profile json.';
            default:
                throw new Error('Error: invalid status generated');
        }
    }
    get status_list() {
        if (this.segments !== undefined) {
            return this.segments.map((s) => s.status);
        }
    }
    static compute_raw_nist_tags(raw) {
        const fetched = raw.tags['nist'];
        if (!fetched) {
            return ['UM-1'];
        }
        else {
            return fetched;
        }
    }
    static compute_proper_nist_tags(raw) {
        let parsedNistTags = [];
        let parsedNistRevision = null;
        const seenSpecs = new Set();
        (Array.isArray(raw) ? raw : [raw]).map(nist_1.parse_nist).forEach((x) => {
            if (!x) {
                return;
            }
            else if ((0, nist_1.is_control)(x)) {
                const specChain = x.subSpecifiers.join('-');
                if (!seenSpecs.has(specChain)) {
                    seenSpecs.add(specChain);
                    parsedNistTags.push(x);
                }
            }
            else {
                parsedNistRevision = x;
            }
        });
        parsedNistTags = parsedNistTags.sort((a, b) => a.localCompare(b));
        if (parsedNistTags.length === 0) {
            parsedNistTags.push((0, nist_1.parse_nist)('UM-1'));
        }
        return [parsedNistTags, parsedNistRevision];
    }
    canonized_nist(config) {
        const result = [];
        for (const v of this.parsedNistTags) {
            const s = v.canonize(config);
            if (!result.includes(s)) {
                result.push(s);
            }
        }
        return result;
    }
    static compute_severity(raw) {
        if (raw.impact < 0.1) {
            return 'none';
        }
        else if (raw.impact < 0.4) {
            return 'low';
        }
        else if (raw.impact < 0.7) {
            return 'medium';
        }
        else if (raw.impact < 0.9) {
            return 'high';
        }
        else {
            return 'critical';
        }
    }
}
class ExecControl extends HDFControl10 {
    constructor(control) {
        var _a, _b;
        super(control, false, Boolean((_a = control.waiver_data) === null || _a === void 0 ? void 0 : _a.skipped_due_to_waiver), Boolean(control.attestation_data), (_b = control.attestation_data) === null || _b === void 0 ? void 0 : _b.status);
        if (control.descriptions) {
            control.descriptions.forEach((x) => (this.descriptions[x.label] = x.data));
        }
        this.message = ExecControl.compute_message(control);
        this.segments = ExecControl.compute_segments(control);
        this.status = this.compute_status();
    }
    get start_time() {
        if (this.segments && this.segments.length) {
            return this.segments[0].start_time;
        }
        return undefined;
    }
    static compute_message(control) {
        if (control.impact !== 0) {
            return control.results.map(ExecControl.to_message_line).join('');
        }
        else {
            return control.desc || 'No message found.';
        }
    }
    compute_status() {
        if (!this.status_list || this.status_list.includes('error')) {
            return profileError;
        }
        else if (this.waived || this.wraps.impact === 0) {
            return 'Not Applicable';
        }
        else if (this.status_list.length === 0) {
            return profileError;
        }
        else if (this.status_list.includes('failed')) {
            return 'Failed';
        }
        else if (this.status_list.includes('passed')) {
            return 'Passed';
        }
        else if (this.attested) {
            if (this.attestationStatus === 'failed') {
                return 'Failed';
            }
            else if (this.attestationStatus === 'passed') {
                return 'Passed';
            }
            else {
                throw new Error(`Attestation for control ${this.wraps.id} exists with invalid status: ${this.attestationStatus}`);
            }
        }
        else if (this.status_list.includes('skipped')) {
            return 'Not Reviewed';
        }
        else {
            return profileError;
        }
    }
    static to_message_line(r) {
        switch (r.status) {
            case 'skipped':
                return `SKIPPED -- ${r.skip_message}\n`;
            case 'failed':
                return `FAILED -- Test: ${r.code_desc}\nMessage: ${r.message}\n`;
            case 'passed':
                return `PASSED -- ${r.code_desc}\n"`;
            case 'error':
                return `ERROR -- Test: ${r.code_desc}\nMessage: ${r.message}`;
            default:
                return `Exception: ${r.exception}\n`;
        }
    }
    static compute_segments(control) {
        return control.results.map((result) => {
            const status = result.backtrace
                ? 'error'
                : result.status || 'no_status';
            return {
                status: status,
                message: result.message || undefined,
                code_desc: result.code_desc,
                skip_message: result.skip_message || undefined,
                exception: result.exception || undefined,
                backtrace: result.backtrace || undefined,
                start_time: result.start_time,
                run_time: result.run_time || undefined,
                resource: result.resource || undefined
            };
        });
    }
}
exports.ExecControl = ExecControl;
class ProfileControl extends HDFControl10 {
    constructor(control) {
        super(control, true, false, false);
        this.segments = undefined;
        this.status = 'From Profile';
        if (control.descriptions) {
            for (const key of Object.keys(control.descriptions)) {
                if (typeof control.descriptions[key] === 'string') {
                    this.descriptions[key] = control.descriptions[key];
                }
            }
        }
    }
    get typed_wrap() {
        return this.wraps;
    }
    get message() {
        return this.typed_wrap.desc || 'No message found.';
    }
}
exports.ProfileControl = ProfileControl;
//# sourceMappingURL=compat_inspec_1_0.js.map