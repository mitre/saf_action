"use strict";

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var defer = require("./defer");

var Cancel = require("./Cancel");

var isPromise = require("./isPromise");

var _require = require("./_symbols"),
    $$toStringTag = _require.$$toStringTag;

var cancelTokenTag = "CancelToken";

function cancel(message) {
  if (this._reason !== undefined) {
    return;
  }

  var reason = this._reason = message instanceof Cancel ? message : new Cancel(message);
  var resolve = this._resolve;

  if (resolve !== undefined) {
    this._resolve = undefined;
    resolve(reason);
  }

  var handlers = this._handlers;

  if (handlers !== undefined) {
    this._handlers = undefined;

    var _defer = defer(),
        promise = _defer.promise,
        _resolve = _defer.resolve;

    var wait = 0;

    var onSettle = function onSettle() {
      if (--wait === 0) {
        return _resolve();
      }
    };

    for (var i = 0, n = handlers.length; i < n; ++i) {
      try {
        var result = handlers[i](reason);

        if (isPromise(result)) {
          ++wait;
          result.then(onSettle, onSettle);
        }
      } catch (_) {}
    }

    if (wait !== 0) {
      return promise;
    }
  }
}

function removeHandler(handler) {
  var handlers = this._handlers;

  if (handlers !== undefined) {
    var i = handlers.indexOf(handler);

    if (i !== -1) {
      handlers.splice(i, 1);
    }
  }
}

var INTERNAL = {};

function CancelTokenSource(tokens) {
  var cancel_ = this.cancel = cancel.bind(this.token = new CancelToken(INTERNAL));

  if (tokens == null) {
    return;
  }

  tokens.forEach(function (token) {
    var reason = token.reason;

    if (reason !== undefined) {
      cancel_(reason);
      return false;
    }

    token.addHandler(cancel_);
  });
}

var CancelToken = function () {
  CancelToken.isCancelToken = function isCancelToken(value) {
    return value != null && value[$$toStringTag] === cancelTokenTag;
  };

  CancelToken.source = function source(tokens) {
    return new CancelTokenSource(tokens);
  };

  function CancelToken(executor) {
    this._handlers = undefined;
    this._promise = undefined;
    this._reason = undefined;
    this._resolve = undefined;

    if (executor !== INTERNAL) {
      executor(cancel.bind(this));
    }
  }

  var _proto = CancelToken.prototype;

  _proto.addHandler = function addHandler(handler) {
    var handlers = this._handlers;

    if (handlers === undefined) {
      if (this.requested) {
        throw new TypeError("cannot add a handler to an already canceled token");
      }

      handlers = this._handlers = [];
    }

    handlers.push(handler);
    return removeHandler.bind(this, handler);
  };

  _proto.throwIfRequested = function throwIfRequested() {
    var reason = this._reason;

    if (reason !== undefined) {
      throw reason;
    }
  };

  _createClass(CancelToken, [{
    key: "promise",
    get: function get() {
      var _this = this;

      var promise = this._promise;

      if (promise === undefined) {
        var reason = this._reason;
        promise = this._promise = reason !== undefined ? Promise.resolve(reason) : new Promise(function (resolve) {
          _this._resolve = resolve;
        });
      }

      return promise;
    }
  }, {
    key: "reason",
    get: function get() {
      return this._reason;
    }
  }, {
    key: "requested",
    get: function get() {
      return this._reason !== undefined;
    }
  }, {
    key: $$toStringTag,
    get: function get() {
      return cancelTokenTag;
    }
  }]);

  return CancelToken;
}();

cancel.call(CancelToken.canceled = new CancelToken(INTERNAL));
CancelToken.none = new CancelToken(INTERNAL);
module.exports = CancelToken;