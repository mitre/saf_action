"use strict";

var once = require("./_once");

var Resource = require("./_Resource");

var wrapApply = require("./wrapApply");

var wrapCall = require("./wrapCall");

var _require = require("./_utils"),
    forArray = _require.forArray;

module.exports = function using() {
  var _this = this;

  var nResources = arguments.length - 1;

  if (nResources < 1) {
    throw new TypeError("using expects at least 2 arguments");
  }

  var handler = arguments[nResources];
  var resources;
  var spread = nResources > 1 || !Array.isArray(resources = arguments[0]);

  if (spread) {
    resources = Array.prototype.slice.call(arguments, 0, nResources);
  } else {
    nResources = resources.length;
  }

  var dispose = once(function (fn, value) {
    var leftToProcess = nResources;

    var onSettle = function onSettle() {
      if (--leftToProcess === 0) {
        fn(value);
      }
    };

    var onFailure = function onFailure(reason) {
      setTimeout(function () {
        throw reason;
      }, 0);
    };

    forArray(resources, function (resource) {
      var d;

      if (resource != null && typeof (d = resource.d) === "function") {
        resource.p.then(function (value) {
          return wrapCall(d, value).then(onSettle, onFailure);
        }, onSettle);
        resource.p = resource.d = undefined;
      } else {
        --leftToProcess;
      }
    });
  });
  return new Promise(function (resolve, reject) {
    var values = new Array(nResources);
    var leftToProcess = nResources;

    var _onProviderFailure_ = function onProviderFailure_(reason) {
      _onProviderFailure_ = onProviderSettle;

      onSettle = function onSettle() {
        return dispose(reject, reason);
      };

      onProviderSettle();
    };

    var onProviderFailure = function onProviderFailure(reason) {
      return _onProviderFailure_(reason);
    };

    var onProviderSettle = function onProviderSettle() {
      if (--leftToProcess === 0) {
        onSettle();
      }
    };

    var onSettle = function onSettle() {
      return (spread ? wrapApply : wrapCall)(handler, values, _this).then(function (value) {
        return dispose(resolve, value);
      }, function (reason) {
        return dispose(reject, reason);
      });
    };

    forArray(resources, function (resource, i) {
      var p;

      if (resource instanceof Resource) {
        p = resource.p;

        if (p === undefined) {
          return onProviderFailure(new TypeError("resource has already been disposed of"));
        }
      } else {
        p = Promise.resolve(resource);
      }

      p.then(function (value) {
        values[i] = value;
        onProviderSettle();
      }, onProviderFailure);
    });
  });
};