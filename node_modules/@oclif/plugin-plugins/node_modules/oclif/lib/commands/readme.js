"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("node:path"));
const node_url_1 = require("node:url");
const help_compatibility_1 = require("../help-compatibility");
const util_1 = require("../util");
const normalize = require('normalize-package-data');
const columns = Number.parseInt(process.env.COLUMNS, 10) || 120;
const slugify = new (require('github-slugger'))();
const lodashTemplate = require('lodash.template');
class Readme extends core_1.Command {
    static description = `The readme must have any of the following tags inside of it for it to be replaced or else it will do nothing:
# Usage
<!-- usage -->
# Commands
<!-- commands -->
# Table of contents
<!-- toc -->

Customize the code URL prefix by setting oclif.repositoryPrefix in package.json.
`;
    static flags = {
        aliases: core_1.Flags.boolean({
            allowNo: true,
            default: true,
            description: 'Include aliases in the command list.',
        }),
        multi: core_1.Flags.boolean({
            description: 'Create a different markdown page for each topic.',
        }),
        'nested-topics-depth': core_1.Flags.integer({
            dependsOn: ['multi'],
            description: 'Max nested topics depth for multi markdown page generation. Use with --multi enabled.',
        }),
        'output-dir': core_1.Flags.string({
            aliases: ['dir'],
            default: 'docs',
            description: 'Output directory for multi docs.',
            required: true,
        }),
        'plugin-directory': core_1.Flags.string({
            description: 'Plugin directory to generate README for. Defaults to the current directory.',
        }),
        'readme-path': core_1.Flags.string({
            default: 'README.md',
            description: 'Path to the README file.',
            required: true,
        }),
        'repository-prefix': core_1.Flags.string({
            description: 'A template string used to build links to the source code.',
        }),
        version: core_1.Flags.string({
            description: 'Version to use in readme links. Defaults to the version in package.json.',
        }),
    };
    static summary = 'Adds commands to README.md in current directory.';
    flags;
    HelpClass;
    commandCode(config, c) {
        const pluginName = c.pluginName;
        if (!pluginName)
            return;
        const plugin = config.plugins.get(pluginName);
        if (!plugin)
            return;
        const repo = this.repo(plugin);
        if (!repo)
            return;
        let label = plugin.name;
        let version = plugin.version;
        const commandPath = this.commandPath(plugin, c);
        if (!commandPath)
            return;
        if (config.name === plugin.name) {
            label = commandPath;
            version = this.flags.version || version;
        }
        const template = this.flags['repository-prefix'] ||
            plugin.pjson.oclif.repositoryPrefix ||
            '<%- repo %>/blob/v<%- version %>/<%- commandPath %>';
        return `_See code: [${label}](${lodashTemplate(template)({ c, commandPath, config, repo, version })})_`;
    }
    commands(config, commands) {
        return [
            ...commands.map((c) => {
                const usage = this.commandUsage(config, c);
                return usage
                    ? `* [\`${config.bin} ${usage}\`](#${slugify.slug(`${config.bin}-${usage}`)})`
                    : `* [\`${config.bin}\`](#${slugify.slug(`${config.bin}`)})`;
            }),
            '',
            ...commands.map((c) => this.renderCommand(config, { ...c })).map((s) => s.trim() + '\n'),
        ]
            .join('\n')
            .trim();
    }
    createTopicFile(file, config, topic, commands) {
        const bin = `\`${config.bin} ${topic.name}\``;
        const doc = [
            bin,
            '='.repeat(bin.length),
            '',
            (0, util_1.template)({ config })(topic.description || '').trim(),
            '',
            this.commands(config, commands),
        ]
            .join('\n')
            .trim() + '\n';
        fs.outputFileSync(path.resolve(this.flags['plugin-directory'] ?? process.cwd(), file), doc);
    }
    multiCommands(config, commands, dir, nestedTopicsDepth) {
        let topics = config.topics;
        topics = nestedTopicsDepth
            ? topics.filter((t) => !t.hidden && (t.name.match(/:/g) || []).length < nestedTopicsDepth)
            : topics.filter((t) => !t.hidden && !t.name.includes(':'));
        topics = topics.filter((t) => commands.find((c) => c.id.startsWith(t.name)));
        topics = (0, util_1.sortBy)(topics, (t) => t.name);
        topics = (0, util_1.uniqBy)(topics, (t) => t.name);
        for (const topic of topics) {
            this.createTopicFile(path.join('.', dir, topic.name.replaceAll(':', '/') + '.md'), config, topic, commands.filter((c) => c.id === topic.name || c.id.startsWith(topic.name + ':')));
        }
        return ([
            '# Command Topics\n',
            ...topics.map((t) => (0, util_1.compact)([
                `* [\`${config.bin} ${t.name.replaceAll(':', config.topicSeparator)}\`](${dir}/${t.name.replaceAll(':', '/')}.md)`,
                (0, util_1.template)({ config })(t.description || '')
                    .trim()
                    .split('\n')[0],
            ]).join(' - ')),
        ]
            .join('\n')
            .trim() + '\n');
    }
    renderCommand(config, c) {
        this.debug('rendering command', c.id);
        const title = (0, util_1.template)({ command: c, config })(c.summary ?? c.description ?? '')
            .trim()
            .split('\n')[0];
        const help = new this.HelpClass(config, { maxWidth: columns, stripAnsi: true });
        const wrapper = new help_compatibility_1.HelpCompatibilityWrapper(help);
        const header = () => {
            const usage = this.commandUsage(config, c);
            return usage ? `## \`${config.bin} ${usage}\`` : `## \`${config.bin}\``;
        };
        try {
            // copy c to keep the command ID with colons, see:
            // https://github.com/oclif/oclif/pull/1165#discussion_r1282305242
            const command = { ...c };
            return (0, util_1.compact)([
                header(),
                title,
                '```\n' + wrapper.formatCommand(c).trim() + '\n```',
                this.commandCode(config, command),
            ]).join('\n\n');
        }
        catch (error) {
            const { message } = error;
            this.error(message);
        }
    }
    replaceTag(readme, tag, body) {
        if (readme.includes(`<!-- ${tag} -->`)) {
            if (readme.includes(`<!-- ${tag}stop -->`)) {
                readme = readme.replace(new RegExp(`<!-- ${tag} -->(.|\n)*<!-- ${tag}stop -->`, 'm'), `<!-- ${tag} -->`);
            }
            this.log(`replacing <!-- ${tag} --> in ${this.flags['readme-path']}`);
        }
        return readme.replace(`<!-- ${tag} -->`, `<!-- ${tag} -->\n${body}\n<!-- ${tag}stop -->`);
    }
    async run() {
        const { flags } = await this.parse(Readme);
        this.flags = flags;
        this.flags['plugin-directory'] ??= process.cwd();
        const readmePath = path.resolve(this.flags['plugin-directory'], flags['readme-path']);
        const tsConfigPath = path.resolve(this.flags['plugin-directory'], 'tsconfig.json');
        const tsConfig = await fs.readJSON(tsConfigPath).catch(() => ({}));
        const outDir = tsConfig.compilerOptions?.outDir ?? 'lib';
        if (!(await fs.pathExists(outDir))) {
            this.warn(`No compiled source found at ${outDir}. Some commands may be missing.`);
        }
        const config = await core_1.Config.load({
            devPlugins: false,
            root: this.flags['plugin-directory'],
            userPlugins: false,
        });
        try {
            const p = require.resolve('@oclif/plugin-legacy', { paths: [this.flags['plugin-directory']] });
            const plugin = new core_1.Plugin({ root: p, type: 'core' });
            await plugin.load();
            config.plugins.set(plugin.name, plugin);
        }
        catch { }
        await config.runHook('init', { argv: this.argv, id: 'readme' });
        this.HelpClass = await (0, core_1.loadHelpClass)(config);
        let readme = await fs.readFile(readmePath, 'utf8');
        let commands = config.commands
            .filter((c) => !c.hidden && c.pluginType === 'core')
            .filter((c) => (this.flags.aliases ? true : !c.aliases.includes(c.id)))
            .map((c) => (config.isSingleCommandCLI ? { ...c, id: '' } : c));
        this.debug('commands:', commands.map((c) => c.id).length);
        commands = (0, util_1.uniqBy)(commands, (c) => c.id);
        commands = (0, util_1.sortBy)(commands, (c) => c.id);
        readme = this.replaceTag(readme, 'usage', this.usage(config));
        readme = this.replaceTag(readme, 'commands', flags.multi
            ? this.multiCommands(config, commands, flags['output-dir'], flags['nested-topics-depth'])
            : this.commands(config, commands));
        readme = this.replaceTag(readme, 'toc', this.toc(config, readme));
        readme = readme.trimEnd();
        readme += '\n';
        await fs.outputFile(readmePath, readme);
    }
    toc(__, readme) {
        return readme
            .split('\n')
            .filter((l) => l.startsWith('# '))
            .map((l) => l.trim().slice(2))
            .map((l) => `* [${l}](#${slugify.slug(l)})`)
            .join('\n');
    }
    usage(config) {
        const versionFlags = ['--version', ...(config.pjson.oclif.additionalVersionFlags ?? []).sort()];
        const versionFlagsString = `(${versionFlags.join('|')})`;
        return [
            `\`\`\`sh-session
$ npm install -g ${config.name}
$ ${config.bin} COMMAND
running command...
$ ${config.bin} ${versionFlagsString}
${config.name}/${this.flags.version || config.version} ${process.platform}-${process.arch} node-v${process.versions.node}
$ ${config.bin} --help [COMMAND]
USAGE
  $ ${config.bin} COMMAND
...
\`\`\`\n`,
        ]
            .join('\n')
            .trim();
    }
    /**
     * fetches the path to a command
     */
    commandPath(plugin, c) {
        const strategy = typeof plugin.pjson.oclif?.commands === 'string' ? 'pattern' : plugin.pjson.oclif?.commands?.strategy;
        // if the strategy is explicit, we can't determine the path so return undefined
        if (strategy === 'explicit')
            return;
        const commandsDir = typeof plugin.pjson.oclif?.commands === 'string'
            ? plugin.pjson.oclif?.commands
            : plugin.pjson.oclif?.commands?.target;
        if (!commandsDir)
            return;
        const hasTypescript = plugin.pjson.devDependencies?.typescript || plugin.pjson.dependencies?.typescript;
        let p = path.join(plugin.root, commandsDir, ...c.id.split(':'));
        const outDir = path.dirname(commandsDir.replace(/^.\/|.\\/, '')); // remove leading ./ or .\ from path
        const outDirRegex = new RegExp('^' + outDir + (path.sep === '\\' ? '\\\\' : path.sep));
        if (fs.pathExistsSync(path.join(p, 'index.js'))) {
            p = path.join(p, 'index.js');
        }
        else if (fs.pathExistsSync(p + '.js')) {
            p += '.js';
        }
        else if (hasTypescript) {
            // check if non-compiled scripts are available
            const base = p.replace(plugin.root + path.sep, '');
            p = path.join(plugin.root, base.replace(outDirRegex, 'src' + path.sep));
            if (fs.pathExistsSync(path.join(p, 'index.ts'))) {
                p = path.join(p, 'index.ts');
            }
            else if (fs.pathExistsSync(p + '.ts')) {
                p += '.ts';
            }
            else
                return;
        }
        else
            return;
        p = p.replace(plugin.root + path.sep, '');
        if (hasTypescript) {
            p = p.replace(outDirRegex, 'src' + path.sep).replace(/\.js$/, '.ts');
        }
        p = p.replaceAll('\\', '/'); // Replace windows '\' by '/'
        return p;
    }
    commandUsage(config, command) {
        const arg = (arg) => {
            const name = arg.name.toUpperCase();
            if (arg.required)
                return `${name}`;
            return `[${name}]`;
        };
        const id = (0, core_1.toConfiguredId)(command.id, config);
        const defaultUsage = () => (0, util_1.compact)([
            id,
            Object.values(command.args)
                .filter((a) => !a.hidden)
                .map((a) => arg(a))
                .join(' '),
        ]).join(' ');
        const usages = (0, util_1.castArray)(command.usage);
        return (0, util_1.template)({ command, config })(usages.length === 0 ? defaultUsage() : usages[0]);
    }
    repo(plugin) {
        const pjson = { ...plugin.pjson };
        normalize(pjson);
        const repo = pjson.repository && pjson.repository.url;
        if (!repo)
            return;
        const url = new node_url_1.URL(repo);
        if (!['github.com', 'gitlab.com'].includes(url.hostname) &&
            !pjson.oclif.repositoryPrefix &&
            !this.flags['repository-prefix'])
            return;
        return `https://${url.hostname}${url.pathname.replace(/\.git$/, '')}`;
    }
}
exports.default = Readme;
