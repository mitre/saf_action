"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
const find_yarn_workspace_root_1 = __importDefault(require("find-yarn-workspace-root"));
const fs_extra_1 = require("fs-extra");
const node_child_process_1 = require("node:child_process");
const node_fs_1 = require("node:fs");
const promises_1 = require("node:fs/promises");
const path = __importStar(require("node:path"));
const node_util_1 = require("node:util");
const log_1 = require("../log");
const upload_util_1 = require("../upload-util");
const util_1 = require("../util");
const bin_1 = require("./bin");
const node_1 = require("./node");
const exec = (0, node_util_1.promisify)(node_child_process_1.exec);
const pack = async (from, to) => {
    const cwd = path.dirname(from);
    await (0, promises_1.mkdir)(path.dirname(to), { recursive: true });
    (0, log_1.log)(`packing tarball from ${(0, util_1.prettifyPaths)(path.dirname(from))} to ${(0, util_1.prettifyPaths)(to)}`);
    to.endsWith('gz')
        ? await exec(`tar czf ${to} ${path.basename(from)}`, { cwd })
        : await exec(`tar cfJ ${to} ${path.basename(from)}`, { cwd });
};
const isYarnProject = (yarnRootPath) => {
    const yarnLockFileName = 'yarn.lock';
    const rootYarnLockFilePath = path.join(yarnRootPath, yarnLockFileName);
    return (0, node_fs_1.existsSync)(rootYarnLockFilePath);
};
const copyYarnDirectory = async (relativePath, yarnRootPath, workspacePath) => {
    const rootYarnDirectoryPath = path.join(yarnRootPath, relativePath);
    const workspaceYarnDirectoryPath = path.join(workspacePath, relativePath);
    if ((0, node_fs_1.existsSync)(rootYarnDirectoryPath)) {
        // create the directory if it does not exist
        if (!(0, node_fs_1.existsSync)(workspaceYarnDirectoryPath)) {
            await (0, promises_1.mkdir)(workspaceYarnDirectoryPath, { recursive: true });
        }
        // recursively copy all files in the directory
        await (0, fs_extra_1.copy)(rootYarnDirectoryPath, workspaceYarnDirectoryPath);
    }
};
const copyCoreYarnFiles = async (yarnRootPath, workspacePath) => {
    // copy yarn dependencies lock file
    const yarnLockFileName = 'yarn.lock';
    const rootYarnLockFilePath = path.join(yarnRootPath, yarnLockFileName);
    const workspaceYarnLockFilePath = path.join(workspacePath, yarnLockFileName);
    if ((0, node_fs_1.existsSync)(rootYarnLockFilePath)) {
        await (0, fs_extra_1.copy)(rootYarnLockFilePath, workspaceYarnLockFilePath);
    }
    // copy yarn configuration file
    const yarnConfigFileName = '.yarnrc.yml';
    const rootYarnConfigFilePath = path.join(yarnRootPath, yarnConfigFileName);
    const workspaceYarnConfigFilePath = path.join(workspacePath, yarnConfigFileName);
    if ((0, node_fs_1.existsSync)(rootYarnConfigFilePath)) {
        await (0, fs_extra_1.copy)(rootYarnConfigFilePath, workspaceYarnConfigFilePath);
    }
    // copy yarn releases e.g. yarn may be installed via a local config path like "yarnPath"
    await copyYarnDirectory('./.yarn/releases/', yarnRootPath, workspacePath);
    // copy yarn plugins if they exists
    await copyYarnDirectory('./.yarn/plugins/', yarnRootPath, workspacePath);
};
async function build(c, options = {}) {
    const { config, xz } = c;
    const packCLI = async () => {
        const { stdout } = await exec('npm pack --unsafe-perm', { cwd: c.root });
        return path.join(c.root, stdout.trim().split('\n').pop());
    };
    const extractCLI = async (tarball) => {
        await (0, fs_extra_1.emptyDir)(c.workspace());
        const tarballNewLocation = path.join(c.workspace(), path.basename(tarball));
        await (0, fs_extra_1.move)(tarball, tarballNewLocation);
        let tarCommand = `tar -xzf "${tarballNewLocation}"`;
        if (process.platform === 'win32')
            tarCommand += ' --force-local';
        await exec(tarCommand, { cwd: c.workspace() });
        const files = await (0, promises_1.readdir)(path.join(c.workspace(), 'package'), { withFileTypes: true });
        await Promise.all(files.map((i) => (0, fs_extra_1.move)(path.join(c.workspace(), 'package', i.name), path.join(c.workspace(), i.name))));
        await Promise.all([
            (0, promises_1.rm)(path.join(c.workspace(), 'package'), { recursive: true }),
            (0, promises_1.rm)(path.join(c.workspace(), path.basename(tarball)), { recursive: true }),
            (0, fs_extra_1.remove)(path.join(c.workspace(), 'bin', 'run.cmd')),
        ]);
    };
    const updatePJSON = async () => {
        const pjsonPath = path.join(c.workspace(), 'package.json');
        const pjson = await (0, fs_extra_1.readJSON)(pjsonPath);
        pjson.version = config.version;
        pjson.oclif.update = pjson.oclif.update || {};
        pjson.oclif.update.s3 = pjson.oclif.update.s3 || {};
        pjson.oclif.update.s3.bucket = c.s3Config.bucket;
        await (0, fs_extra_1.writeJSON)(pjsonPath, pjson, { spaces: 2 });
    };
    const addDependencies = async () => {
        const yarnRoot = (0, find_yarn_workspace_root_1.default)(c.root) || c.root;
        if (isYarnProject(yarnRoot)) {
            await copyCoreYarnFiles(yarnRoot, c.workspace());
            const { stdout } = await exec('yarn -v');
            const yarnVersion = stdout.charAt(0);
            if (yarnVersion === '1') {
                await exec('yarn --no-progress --production --non-interactive', { cwd: c.workspace() });
            }
            else if (yarnVersion === '2') {
                throw new Error('Yarn 2 is not supported yet. Try using Yarn 1, or Yarn 3');
            }
            else {
                try {
                    await exec('yarn workspaces focus --production', { cwd: c.workspace() });
                }
                catch (error) {
                    if (error instanceof Error && error.message.includes('Command not found')) {
                        throw new Error('Missing workspace tools. Run `yarn plugin import workspace-tools`.');
                    }
                    throw error;
                }
            }
        }
        else {
            const lockpath = (0, node_fs_1.existsSync)(path.join(c.root, 'package-lock.json'))
                ? path.join(c.root, 'package-lock.json')
                : path.join(c.root, 'npm-shrinkwrap.json');
            await (0, fs_extra_1.copy)(lockpath, path.join(c.workspace(), path.basename(lockpath)));
            await exec('npm install --production', { cwd: c.workspace() });
        }
    };
    const pretarball = async () => {
        const pjson = await (0, fs_extra_1.readJSON)(path.join(c.workspace(), 'package.json'));
        const yarnRoot = (0, find_yarn_workspace_root_1.default)(c.root) || c.root;
        const yarn = (0, node_fs_1.existsSync)(path.join(yarnRoot, 'yarn.lock'));
        if (pjson.scripts.pretarball) {
            yarn
                ? await exec('yarn run pretarball', { cwd: c.workspace() })
                : await exec('npm run pretarball', { cwd: c.workspace() });
        }
    };
    const buildTarget = async (target) => {
        const workspace = c.workspace(target);
        const gzLocalKey = (0, upload_util_1.templateShortKey)('versioned', {
            arch: target.arch,
            bin: c.config.bin,
            ext: '.tar.gz',
            platform: target.platform,
            sha: c.gitSha,
            version: config.version,
        });
        const xzLocalKey = (0, upload_util_1.templateShortKey)('versioned', {
            arch: target.arch,
            bin: c.config.bin,
            ext: '.tar.xz',
            platform: target.platform,
            sha: c.gitSha,
            version: config.version,
        });
        const base = path.basename(gzLocalKey);
        (0, log_1.log)(`building target ${base}`);
        (0, log_1.log)('copying workspace', c.workspace(), workspace);
        await (0, fs_extra_1.emptyDir)(workspace);
        await (0, fs_extra_1.copy)(c.workspace(), workspace);
        await (0, node_1.fetchNodeBinary)({
            arch: target.arch,
            nodeVersion: c.nodeVersion,
            output: path.join(workspace, 'bin', 'node'),
            platform: target.platform,
            tmp: path.join(config.root, 'tmp'),
        });
        if (options.pack === false)
            return;
        if (options.parallel) {
            await Promise.all([pack(workspace, c.dist(gzLocalKey)), ...(xz ? [pack(workspace, c.dist(xzLocalKey))] : [])]);
        }
        else {
            await pack(workspace, c.dist(gzLocalKey));
            if (xz)
                await pack(workspace, c.dist(xzLocalKey));
        }
        if (!c.updateConfig.s3.host)
            return;
        const rollout = typeof c.updateConfig.autoupdate === 'object' && c.updateConfig.autoupdate.rollout;
        const gzCloudKey = `${(0, upload_util_1.commitAWSDir)(config.version, c.gitSha, c.updateConfig.s3)}/${gzLocalKey}`;
        const xzCloudKey = `${(0, upload_util_1.commitAWSDir)(config.version, c.gitSha, c.updateConfig.s3)}/${xzLocalKey}`;
        const [sha256gz, sha256xz] = await Promise.all([
            (0, util_1.hash)('sha256', c.dist(gzLocalKey)),
            ...(xz ? [(0, util_1.hash)('sha256', c.dist(xzLocalKey))] : []),
        ]);
        const manifest = {
            baseDir: (0, upload_util_1.templateShortKey)('baseDir', { ...target, bin: c.config.bin }),
            gz: config.s3Url(gzCloudKey),
            node: {
                compatible: config.pjson.engines.node,
                recommended: c.nodeVersion,
            },
            rollout: rollout === false ? undefined : rollout,
            sha: c.gitSha,
            sha256gz,
            sha256xz,
            version: config.version,
            xz: xz ? config.s3Url(xzCloudKey) : undefined,
        };
        const manifestFilepath = c.dist((0, upload_util_1.templateShortKey)('manifest', {
            arch: target.arch,
            bin: c.config.bin,
            platform: target.platform,
            sha: c.gitSha,
            version: config.version,
        }));
        await (0, fs_extra_1.writeJSON)(manifestFilepath, manifest, { spaces: 2 });
    };
    (0, log_1.log)(`gathering workspace for ${config.bin} to ${c.workspace()}`);
    await extractCLI(options.tarball ?? (await packCLI()));
    await updatePJSON();
    await addDependencies();
    await (0, bin_1.writeBinScripts)({ baseWorkspace: c.workspace(), config, nodeOptions: c.nodeOptions, nodeVersion: c.nodeVersion });
    await pretarball();
    const targetsToBuild = c.targets.filter((t) => !options.platform || options.platform === t.platform);
    if (options.parallel) {
        (0, log_1.log)(`will build ${targetsToBuild.length} targets in parallel`);
        await Promise.all(targetsToBuild.map((t) => buildTarget(t)));
    }
    else {
        (0, log_1.log)(`will build ${targetsToBuild.length} targets sequentially`);
        for (const target of targetsToBuild) {
            // eslint-disable-next-line no-await-in-loop
            await buildTarget(target);
        }
        (0, log_1.log)(`finished building ${targetsToBuild.length} targets sequentially`);
    }
}
exports.build = build;
