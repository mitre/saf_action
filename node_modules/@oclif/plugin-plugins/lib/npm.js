import { Errors, ux } from '@oclif/core';
import makeDebug from 'debug';
import { fork as cpFork } from 'node:child_process';
import { readFile } from 'node:fs/promises';
import { createRequire } from 'node:module';
import { join, sep } from 'node:path';
import { npmRunPathEnv } from 'npm-run-path';
const debug = makeDebug('@oclif/plugin-plugins:npm');
async function fork(modulePath, args = [], { cwd, logLevel }) {
    return new Promise((resolve, reject) => {
        const forked = cpFork(modulePath, args, {
            cwd,
            env: {
                ...npmRunPathEnv(),
                // Disable husky hooks because a plugin might be trying to install them, which will
                // break the install since the install location isn't a .git directory.
                HUSKY: '0',
            },
            execArgv: process.execArgv
                .join(' ')
                // Remove --loader ts-node/esm from execArgv so that the subprocess doesn't fail if it can't find ts-node.
                // The ts-node/esm loader isn't need to execute npm commands anyways.
                .replace('--loader ts-node/esm', '')
                .replace('--loader=ts-node/esm', '')
                .split(' ')
                .filter(Boolean),
            stdio: [0, null, null, 'ipc'],
        });
        const possibleLastLinesOfNpmInstall = ['up to date', 'added'];
        const stderr = [];
        const stdout = [];
        const loggedStderr = [];
        const loggedStdout = [];
        const shouldPrint = (str) => {
            // For ux cleanliness purposes, don't print the final line of npm install output if
            // the log level is 'notice' and there's no other output.
            const noOtherOutput = loggedStderr.length === 0 && loggedStdout.length === 0;
            const isLastLine = possibleLastLinesOfNpmInstall.some((line) => str.startsWith(line));
            if (noOtherOutput && isLastLine && logLevel === 'notice') {
                return false;
            }
            return logLevel !== 'silent';
        };
        forked.stderr?.setEncoding('utf8');
        forked.stderr?.on('data', (d) => {
            const output = d.toString().trim();
            stderr.push(output);
            if (shouldPrint(output)) {
                loggedStderr.push(output);
                ux.log(output);
            }
            else
                debug(output);
        });
        forked.stdout?.setEncoding('utf8');
        forked.stdout?.on('data', (d) => {
            const output = d.toString().trim();
            stdout.push(output);
            if (shouldPrint(output)) {
                loggedStdout.push(output);
                ux.log(output);
            }
            else
                debug(output);
        });
        forked.on('error', reject);
        forked.on('exit', (code) => {
            if (code === 0) {
                resolve({ stderr, stdout });
            }
            else {
                reject(new Errors.CLIError(`${modulePath} ${args.join(' ')} exited with code ${code}`, {
                    suggestions: ['Run with DEBUG=@oclif/plugin-plugins* to see debug output.'],
                }));
            }
        });
    });
}
export class NPM {
    bin;
    config;
    logLevel;
    constructor({ config, logLevel }) {
        this.config = config;
        this.logLevel = logLevel;
    }
    async exec(args = [], options) {
        const bin = await this.findNpm();
        debug('npm binary path', bin);
        args.push(`--loglevel=${this.logLevel}`, '--no-fund');
        if (this.config.npmRegistry)
            args.push(`--registry=${this.config.npmRegistry}`);
        if (options.logLevel !== 'notice' && options.logLevel !== 'silent') {
            ux.logToStderr(`${options.cwd}: ${bin} ${args.join(' ')}`);
        }
        debug(`${options.cwd}: ${bin} ${args.join(' ')}`);
        try {
            const output = await fork(bin, args, options);
            debug('npm done');
            return output;
        }
        catch (error) {
            debug('npm error', error);
            throw error;
        }
    }
    async install(args, opts) {
        const prod = opts.prod ? ['--omit', 'dev'] : [];
        return this.exec(['install', ...args, ...prod, '--no-audit'], opts);
    }
    async uninstall(args, opts) {
        return this.exec(['uninstall', ...args], opts);
    }
    async update(args, opts) {
        return this.exec(['update', ...args], opts);
    }
    async view(args, opts) {
        return this.exec(['view', ...args], { ...opts, logLevel: 'silent' });
    }
    /**
     * Get the path to the npm CLI file.
     * This will always resolve npm to the pinned version in `@oclif/plugin-plugins/package.json`.
     *
     * @returns The path to the `npm/bin/npm-cli.js` file.
     */
    async findNpm() {
        if (this.bin)
            return this.bin;
        const npmPjsonPath = createRequire(import.meta.url).resolve('npm/package.json');
        const npmPjson = JSON.parse(await readFile(npmPjsonPath, { encoding: 'utf8' }));
        const npmPath = npmPjsonPath.slice(0, Math.max(0, npmPjsonPath.lastIndexOf(sep)));
        this.bin = join(npmPath, npmPjson.bin.npm);
        return this.bin;
    }
}
