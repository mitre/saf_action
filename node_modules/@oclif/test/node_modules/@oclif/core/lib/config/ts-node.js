"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tsPath = exports.TS_CONFIGS = void 0;
const node_path_1 = require("node:path");
const util_1 = require("./util");
const node_fs_1 = require("node:fs");
const util_2 = require("../util/util");
const errors_1 = require("../errors");
const fs_1 = require("../util/fs");
const settings_1 = require("../settings");
// eslint-disable-next-line new-cap
const debug = (0, util_1.Debug)('ts-node');
exports.TS_CONFIGS = {};
const REGISTERED = new Set();
/**
 * Cache the root plugin so that we can reference it later when determining if
 * we should skip ts-node registration for an ESM plugin.
 */
let ROOT_PLUGIN;
function loadTSConfig(root) {
    if (exports.TS_CONFIGS[root])
        return exports.TS_CONFIGS[root];
    const tsconfigPath = (0, node_path_1.join)(root, 'tsconfig.json');
    let typescript;
    try {
        typescript = require('typescript');
    }
    catch {
        try {
            typescript = require((0, node_path_1.join)(root, 'node_modules', 'typescript'));
        }
        catch {
            debug(`Could not find typescript dependency. Skipping ts-node registration for ${root}.`);
            (0, errors_1.memoizedWarn)('Could not find typescript. Please ensure that typescript is a devDependency. Falling back to compiled source.');
            return;
        }
    }
    if ((0, node_fs_1.existsSync)(tsconfigPath) && typescript) {
        const tsconfig = typescript.parseConfigFileTextToJson(tsconfigPath, (0, fs_1.readJsonSync)(tsconfigPath, false)).config;
        if (!tsconfig || !tsconfig.compilerOptions) {
            throw new Error(`Could not read and parse tsconfig.json at ${tsconfigPath}, or it ` +
                'did not contain a "compilerOptions" section.');
        }
        exports.TS_CONFIGS[root] = tsconfig;
        return tsconfig;
    }
}
function registerTSNode(root) {
    const tsconfig = loadTSConfig(root);
    if (!tsconfig)
        return;
    if (REGISTERED.has(root))
        return tsconfig;
    debug('registering ts-node at', root);
    const tsNodePath = require.resolve('ts-node', { paths: [root, __dirname] });
    debug('ts-node path:', tsNodePath);
    let tsNode;
    try {
        tsNode = require(tsNodePath);
    }
    catch {
        debug(`Could not find ts-node at ${tsNodePath}. Skipping ts-node registration for ${root}.`);
        (0, errors_1.memoizedWarn)(`Could not find ts-node at ${tsNodePath}. Please ensure that ts-node is a devDependency. Falling back to compiled source.`);
        return;
    }
    const typeRoots = [(0, node_path_1.join)(root, 'node_modules', '@types')];
    const rootDirs = [];
    if (tsconfig.compilerOptions.rootDirs) {
        for (const r of tsconfig.compilerOptions.rootDirs) {
            rootDirs.push((0, node_path_1.join)(root, r));
        }
    }
    else if (tsconfig.compilerOptions.rootDir) {
        rootDirs.push((0, node_path_1.join)(root, tsconfig.compilerOptions.rootDir));
    }
    else {
        rootDirs.push((0, node_path_1.join)(root, 'src'));
    }
    const conf = {
        compilerOptions: {
            esModuleInterop: tsconfig.compilerOptions.esModuleInterop,
            target: tsconfig.compilerOptions.target ?? 'es2019',
            experimentalDecorators: tsconfig.compilerOptions.experimentalDecorators ?? false,
            emitDecoratorMetadata: tsconfig.compilerOptions.emitDecoratorMetadata ?? false,
            module: tsconfig.compilerOptions.module ?? 'commonjs',
            sourceMap: tsconfig.compilerOptions.sourceMap ?? true,
            rootDirs,
            typeRoots,
        },
        skipProject: true,
        transpileOnly: true,
        esm: tsconfig['ts-node']?.esm ?? true,
        scope: true,
        scopeDir: root,
        cwd: root,
        experimentalSpecifierResolution: tsconfig['ts-node']?.experimentalSpecifierResolution ?? 'explicit',
    };
    if (tsconfig.compilerOptions.moduleResolution) {
        // @ts-expect-error TSNode.RegisterOptions.compilerOptions is typed as a plain object
        conf.compilerOptions.moduleResolution = tsconfig.compilerOptions.moduleResolution;
    }
    if (tsconfig.compilerOptions.jsx) {
        // @ts-expect-error TSNode.RegisterOptions.compilerOptions is typed as a plain object
        conf.compilerOptions.jsx = tsconfig.compilerOptions.jsx;
    }
    tsNode.register(conf);
    REGISTERED.add(root);
    return tsconfig;
}
function tsPath(root, orig, plugin) {
    if (plugin?.isRoot)
        ROOT_PLUGIN = plugin;
    if (!orig)
        return orig;
    orig = orig.startsWith(root) ? orig : (0, node_path_1.join)(root, orig);
    // NOTE: The order of these checks matter!
    if (settings_1.settings.tsnodeEnabled === false) {
        debug(`Skipping ts-node registration for ${root} because tsNodeEnabled is explicitly set to false`);
        return orig;
    }
    const isProduction = (0, util_2.isProd)();
    /**
     * Skip ts-node registration for ESM plugins.
     * The node ecosystem is not mature enough to support auto-transpiling ESM modules at this time.
     * See the following:
     * - https://github.com/TypeStrong/ts-node/issues/1791#issuecomment-1149754228
     * - https://github.com/nodejs/node/issues/49432
     * - https://github.com/nodejs/node/pull/49407
     * - https://github.com/nodejs/node/issues/34049
     *
     * We still register ts-node for ESM plugins when NODE_ENV is "test" or "development" and root plugin is also ESM.
     * In other words, this allows plugins to be auto-transpiled when developing locally using `bin/dev.js`.
     */
    if ((isProduction || ROOT_PLUGIN?.moduleType === 'commonjs') && plugin?.moduleType === 'module') {
        debug(`Skipping ts-node registration for ${root} because it's an ESM module (NODE_ENV: ${process.env.NODE_ENV}, root plugin module type: ${ROOT_PLUGIN?.moduleType})))`);
        if (plugin.type === 'link')
            (0, errors_1.memoizedWarn)(`${plugin.name} is a linked ESM module and cannot be auto-transpiled. Existing compiled source will be used instead.`);
        return orig;
    }
    if (settings_1.settings.tsnodeEnabled === undefined && isProduction && plugin?.type !== 'link') {
        debug(`Skipping ts-node registration for ${root} because NODE_ENV is NOT "test" or "development"`);
        return orig;
    }
    try {
        const tsconfig = registerTSNode(root);
        if (!tsconfig)
            return orig;
        const { rootDir, rootDirs, outDir } = tsconfig.compilerOptions;
        const rootDirPath = rootDir || (rootDirs || [])[0];
        if (!rootDirPath || !outDir)
            return orig;
        // rewrite path from ./lib/foo to ./src/foo
        const lib = (0, node_path_1.join)(root, outDir); // ./lib
        const src = (0, node_path_1.join)(root, rootDirPath); // ./src
        const relative = (0, node_path_1.relative)(lib, orig); // ./commands
        // For hooks, it might point to a js file, not a module. Something like "./hooks/myhook.js" which doesn't need the js.
        const out = (0, node_path_1.join)(src, relative).replace(/\.js$/, ''); // ./src/commands
        // this can be a directory of commands or point to a hook file
        // if it's a directory, we check if the path exists. If so, return the path to the directory.
        // For hooks, it might point to a module, not a file. Something like "./hooks/myhook"
        // That file doesn't exist, and the real file is "./hooks/myhook.ts"
        // In that case we attempt to resolve to the filename. If it fails it will revert back to the lib path
        if ((0, node_fs_1.existsSync)(out) || (0, node_fs_1.existsSync)(out + '.ts'))
            return out;
        return orig;
    }
    catch (error) {
        debug(error);
        return orig;
    }
}
exports.tsPath = tsPath;
