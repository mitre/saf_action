"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Plugin = void 0;
const errors_1 = require("../errors");
const util_1 = require("./util");
const performance_1 = require("../performance");
const util_2 = require("../util/util");
const node_path_1 = require("node:path");
const fs_1 = require("../util/fs");
const module_loader_1 = require("../module-loader");
const cache_command_1 = require("../util/cache-command");
const node_util_1 = require("node:util");
const globby_1 = require("globby");
const ts_node_1 = require("./ts-node");
const _pjson = (0, fs_1.requireJson)(__dirname, '..', '..', 'package.json');
function topicsToArray(input, base) {
    if (!input)
        return [];
    base = base ? `${base}:` : '';
    if (Array.isArray(input)) {
        return [...input, input.flatMap((t) => topicsToArray(t.subtopics, `${base}${t.name}`))];
    }
    return Object.keys(input).flatMap((k) => {
        input[k].name = k;
        return [{ ...input[k], name: `${base}${k}` }, ...topicsToArray(input[k].subtopics, `${base}${input[k].name}`)];
    });
}
// essentially just "cd .."
function* up(from) {
    while ((0, node_path_1.dirname)(from) !== from) {
        yield from;
        from = (0, node_path_1.dirname)(from);
    }
    yield from;
}
async function findSourcesRoot(root) {
    for (const next of up(root)) {
        const cur = (0, node_path_1.join)(next, 'package.json');
        // eslint-disable-next-line no-await-in-loop
        if (await (0, fs_1.exists)(cur))
            return (0, node_path_1.dirname)(cur);
    }
}
/**
 * @returns string
 * @param name string
 * @param root string
 * find package root
 * for packages installed into node_modules this will go up directories until
 * it finds a node_modules directory with the plugin installed into it
 *
 * This is needed because some oclif plugins do not declare the `main` field in their package.json
 * https://github.com/oclif/config/pull/289#issuecomment-983904051
 */
async function findRootLegacy(name, root) {
    for (const next of up(root)) {
        let cur;
        if (name) {
            cur = (0, node_path_1.join)(next, 'node_modules', name, 'package.json');
            // eslint-disable-next-line no-await-in-loop
            if (await (0, fs_1.exists)(cur))
                return (0, node_path_1.dirname)(cur);
            try {
                // eslint-disable-next-line no-await-in-loop
                const pkg = await (0, fs_1.readJson)((0, node_path_1.join)(next, 'package.json'));
                if (pkg.name === name)
                    return next;
            }
            catch { }
        }
        else {
            cur = (0, node_path_1.join)(next, 'package.json');
            // eslint-disable-next-line no-await-in-loop
            if (await (0, fs_1.exists)(cur))
                return (0, node_path_1.dirname)(cur);
        }
    }
}
async function findRoot(name, root) {
    if (name) {
        let pkgPath;
        try {
            pkgPath = (0, util_1.resolvePackage)(name, { paths: [root] });
        }
        catch { }
        return pkgPath ? findSourcesRoot((0, node_path_1.dirname)(pkgPath)) : findRootLegacy(name, root);
    }
    return findSourcesRoot(root);
}
const cachedCommandCanBeUsed = (manifest, id) => Boolean(manifest?.commands[id] && 'isESM' in manifest.commands[id] && 'relativePath' in manifest.commands[id]);
const search = (cmd) => {
    if (typeof cmd.run === 'function')
        return cmd;
    if (cmd.default && cmd.default.run)
        return cmd.default;
    return Object.values(cmd).find((cmd) => typeof cmd.run === 'function');
};
class Plugin {
    options;
    _base = `${_pjson.name}@${_pjson.version}`;
    name;
    version;
    pjson;
    type;
    moduleType;
    root;
    alias;
    tag;
    manifest;
    commands;
    hooks;
    valid = false;
    alreadyLoaded = false;
    parent;
    children = [];
    hasManifest = false;
    isRoot = false;
    _commandsDir;
    flexibleTaxonomy;
    // eslint-disable-next-line new-cap
    _debug = (0, util_1.Debug)();
    warned = false;
    constructor(options) {
        this.options = options;
    }
    async load() {
        this.type = this.options.type || 'core';
        this.tag = this.options.tag;
        this.isRoot = this.options.isRoot ?? false;
        if (this.options.parent)
            this.parent = this.options.parent;
        // Linked plugins already have a root so there's no need to search for it.
        // However there could be child plugins nested inside the linked plugin, in which
        // case we still need to search for the child plugin's root.
        const root = this.type === 'link' && !this.parent ? this.options.root : await findRoot(this.options.name, this.options.root);
        if (!root)
            throw new errors_1.CLIError(`could not find package.json with ${(0, node_util_1.inspect)(this.options)}`);
        this.root = root;
        this._debug('reading %s plugin %s', this.type, root);
        this.pjson = await (0, fs_1.readJson)((0, node_path_1.join)(root, 'package.json'));
        this.flexibleTaxonomy = this.options?.flexibleTaxonomy || this.pjson.oclif?.flexibleTaxonomy || false;
        this.moduleType = this.pjson.type === 'module' ? 'module' : 'commonjs';
        this.name = this.pjson.name;
        this.alias = this.options.name ?? this.pjson.name;
        const pjsonPath = (0, node_path_1.join)(root, 'package.json');
        if (!this.name)
            throw new errors_1.CLIError(`no name in ${pjsonPath}`);
        if (!(0, util_2.isProd)() && !this.pjson.files)
            this.warn(`files attribute must be specified in ${pjsonPath}`);
        // eslint-disable-next-line new-cap
        this._debug = (0, util_1.Debug)(this.name);
        this.version = this.pjson.version;
        if (this.pjson.oclif) {
            this.valid = true;
        }
        else {
            this.pjson.oclif = this.pjson['cli-engine'] || {};
        }
        this.hooks = (0, util_2.mapValues)(this.pjson.oclif.hooks || {}, (i) => (Array.isArray(i) ? i : [i]));
        this.manifest = await this._manifest();
        this.commands = Object.entries(this.manifest.commands)
            .map(([id, c]) => ({
            ...c,
            pluginAlias: this.alias,
            pluginType: c.pluginType === 'jit' ? 'jit' : this.type,
            load: async () => this.findCommand(id, { must: true }),
        }))
            .sort((a, b) => a.id.localeCompare(b.id));
    }
    get topics() {
        return topicsToArray(this.pjson.oclif.topics || {});
    }
    get commandsDir() {
        if (this._commandsDir)
            return this._commandsDir;
        this._commandsDir = (0, ts_node_1.tsPath)(this.root, this.pjson.oclif.commands, this);
        return this._commandsDir;
    }
    get commandIDs() {
        if (!this.commandsDir)
            return [];
        const marker = performance_1.Performance.mark(performance_1.OCLIF_MARKER_OWNER, `plugin.commandIDs#${this.name}`, { plugin: this.name });
        this._debug(`loading IDs from ${this.commandsDir}`);
        const patterns = ['**/*.+(js|cjs|mjs|ts|tsx)', '!**/*.+(d.ts|test.ts|test.js|spec.ts|spec.js)?(x)'];
        const ids = (0, globby_1.sync)(patterns, { cwd: this.commandsDir }).map((file) => {
            const p = (0, node_path_1.parse)(file);
            const topics = p.dir.split('/');
            const command = p.name !== 'index' && p.name;
            const id = [...topics, command].filter(Boolean).join(':');
            return id === '' ? '.' : id;
        });
        this._debug('found commands', ids);
        marker?.addDetails({ count: ids.length });
        marker?.stop();
        return ids;
    }
    async findCommand(id, opts = {}) {
        const marker = performance_1.Performance.mark(performance_1.OCLIF_MARKER_OWNER, `plugin.findCommand#${this.name}.${id}`, { id, plugin: this.name });
        const fetch = async () => {
            if (!this.commandsDir)
                return;
            let module;
            let isESM;
            let filePath;
            try {
                ;
                ({ isESM, module, filePath } = cachedCommandCanBeUsed(this.manifest, id)
                    ? await (0, module_loader_1.loadWithDataFromManifest)(this.manifest.commands[id], this.root)
                    : await (0, module_loader_1.loadWithData)(this, (0, node_path_1.join)(this.commandsDir ?? this.pjson.oclif.commands, ...id.split(':'))));
                this._debug(isESM ? '(import)' : '(require)', filePath);
            }
            catch (error) {
                if (!opts.must && error.code === 'MODULE_NOT_FOUND')
                    return;
                throw error;
            }
            const cmd = search(module);
            if (!cmd)
                return;
            cmd.id = id;
            cmd.plugin = this;
            cmd.isESM = isESM;
            cmd.relativePath = (0, node_path_1.relative)(this.root, filePath || '').split(node_path_1.sep);
            return cmd;
        };
        const cmd = await fetch();
        if (!cmd && opts.must)
            (0, errors_1.error)(`command ${id} not found`);
        marker?.stop();
        return cmd;
    }
    async _manifest() {
        const ignoreManifest = Boolean(this.options.ignoreManifest);
        const errorOnManifestCreate = Boolean(this.options.errorOnManifestCreate);
        const respectNoCacheDefault = Boolean(this.options.respectNoCacheDefault);
        const readManifest = async (dotfile = false) => {
            try {
                const p = (0, node_path_1.join)(this.root, `${dotfile ? '.' : ''}oclif.manifest.json`);
                const manifest = await (0, fs_1.readJson)(p);
                if (!process.env.OCLIF_NEXT_VERSION && manifest.version.split('-')[0] !== this.version.split('-')[0]) {
                    process.emitWarning(`Mismatched version in ${this.name} plugin manifest. Expected: ${this.version} Received: ${manifest.version}\nThis usually means you have an oclif.manifest.json file that should be deleted in development. This file should be automatically generated when publishing.`);
                }
                else {
                    this._debug('using manifest from', p);
                    this.hasManifest = true;
                    return manifest;
                }
            }
            catch (error) {
                if (error.code === 'ENOENT') {
                    if (!dotfile)
                        return readManifest(true);
                }
                else {
                    this.warn(error, 'readManifest');
                }
            }
        };
        const marker = performance_1.Performance.mark(performance_1.OCLIF_MARKER_OWNER, `plugin.manifest#${this.name}`, { plugin: this.name });
        if (!ignoreManifest) {
            const manifest = await readManifest();
            if (manifest) {
                marker?.addDetails({ fromCache: true, commandCount: Object.keys(manifest.commands).length });
                marker?.stop();
                return manifest;
            }
        }
        const manifest = {
            version: this.version,
            commands: (await Promise.all(this.commandIDs.map(async (id) => {
                try {
                    const cached = await (0, cache_command_1.cacheCommand)(await this.findCommand(id, { must: true }), this, respectNoCacheDefault);
                    if (this.flexibleTaxonomy) {
                        const permutations = (0, util_1.getCommandIdPermutations)(id);
                        const aliasPermutations = cached.aliases.flatMap((a) => (0, util_1.getCommandIdPermutations)(a));
                        return [id, { ...cached, permutations, aliasPermutations }];
                    }
                    return [id, cached];
                }
                catch (error) {
                    const scope = 'cacheCommand';
                    if (Boolean(errorOnManifestCreate) === false)
                        this.warn(error, scope);
                    else
                        throw this.addErrorScope(error, scope);
                }
            })))
                // eslint-disable-next-line unicorn/no-await-expression-member, unicorn/prefer-native-coercion-functions
                .filter((f) => Boolean(f))
                .reduce((commands, [id, c]) => {
                commands[id] = c;
                return commands;
            }, {}),
        };
        marker?.addDetails({ fromCache: false, commandCount: Object.keys(manifest.commands).length });
        marker?.stop();
        return manifest;
    }
    warn(err, scope) {
        if (this.warned)
            return;
        if (typeof err === 'string')
            err = new Error(err);
        process.emitWarning(this.addErrorScope(err, scope));
    }
    addErrorScope(err, scope) {
        err.name = `${err.name} Plugin: ${this.name}`;
        err.detail = (0, util_2.compact)([
            err.detail,
            `module: ${this._base}`,
            scope && `task: ${scope}`,
            `plugin: ${this.name}`,
            `root: ${this.root}`,
            'See more details with DEBUG=*',
        ]).join('\n');
        return err;
    }
}
exports.Plugin = Plugin;
