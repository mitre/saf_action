"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheCommand = void 0;
const aggregate_flags_1 = require("./aggregate-flags");
const cache_default_value_1 = require("./cache-default-value");
const ensure_arg_object_1 = require("./ensure-arg-object");
const util_1 = require("./util");
// In order to collect static properties up the inheritance chain, we need to recursively
// access the prototypes until there's nothing left. This allows us to combine baseFlags
// and flags as well as add in the json flag if enableJsonFlag is enabled.
function mergePrototype(result, cmd) {
    const proto = Object.getPrototypeOf(cmd);
    const filteredProto = (0, util_1.pickBy)(proto, (v) => v !== undefined);
    return Object.keys(proto).length > 0 ? mergePrototype({ ...filteredProto, ...result }, proto) : result;
}
async function cacheFlags(cmdFlags, respectNoCacheDefault) {
    const promises = Object.entries(cmdFlags).map(async ([name, flag]) => [
        name,
        {
            name,
            char: flag.char,
            summary: flag.summary,
            hidden: flag.hidden,
            required: flag.required,
            helpLabel: flag.helpLabel,
            helpGroup: flag.helpGroup,
            description: flag.description,
            dependsOn: flag.dependsOn,
            relationships: flag.relationships,
            exclusive: flag.exclusive,
            deprecated: flag.deprecated,
            deprecateAliases: flag.deprecateAliases,
            aliases: flag.aliases,
            charAliases: flag.charAliases,
            noCacheDefault: flag.noCacheDefault,
            ...(flag.type === 'boolean'
                ? {
                    allowNo: flag.allowNo,
                    type: flag.type,
                }
                : {
                    type: flag.type,
                    helpValue: flag.helpValue,
                    multiple: flag.multiple,
                    options: flag.options,
                    delimiter: flag.delimiter,
                    default: await (0, cache_default_value_1.cacheDefaultValue)(flag, respectNoCacheDefault),
                    hasDynamicHelp: typeof flag.defaultHelp === 'function',
                }),
        },
    ]);
    return Object.fromEntries(await Promise.all(promises));
}
async function cacheArgs(cmdArgs, respectNoCacheDefault) {
    const promises = Object.entries(cmdArgs).map(async ([name, arg]) => [
        name,
        {
            name,
            description: arg.description,
            required: arg.required,
            options: arg.options,
            default: await (0, cache_default_value_1.cacheDefaultValue)(arg, respectNoCacheDefault),
            hidden: arg.hidden,
            noCacheDefault: arg.noCacheDefault,
        },
    ]);
    return Object.fromEntries(await Promise.all(promises));
}
async function cacheCommand(uncachedCmd, plugin, respectNoCacheDefault = false) {
    const cmd = mergePrototype(uncachedCmd, uncachedCmd);
    const flags = await cacheFlags((0, aggregate_flags_1.aggregateFlags)(cmd.flags, cmd.baseFlags, cmd.enableJsonFlag), respectNoCacheDefault);
    const args = await cacheArgs((0, ensure_arg_object_1.ensureArgObject)(cmd.args), respectNoCacheDefault);
    const stdProperties = {
        id: cmd.id,
        summary: cmd.summary,
        description: cmd.description,
        strict: cmd.strict,
        usage: cmd.usage,
        pluginName: plugin && plugin.name,
        pluginAlias: plugin && plugin.alias,
        pluginType: plugin && plugin.type,
        hidden: cmd.hidden,
        state: cmd.state,
        aliases: cmd.aliases || [],
        examples: cmd.examples || cmd.example,
        deprecationOptions: cmd.deprecationOptions,
        deprecateAliases: cmd.deprecateAliases,
        flags,
        args,
        hasDynamicHelp: Object.values(flags).some((f) => f.hasDynamicHelp),
    };
    // do not include these properties in manifest
    const ignoreCommandProperties = [
        'plugin',
        '_flags',
        '_enableJsonFlag',
        '_globalFlags',
        '_baseFlags',
        'baseFlags',
        '_--',
        '_base',
    ];
    // Add in any additional properties that are not standard command properties.
    const stdKeysAndIgnored = new Set([...Object.keys(stdProperties), ...ignoreCommandProperties]);
    const keysToAdd = Object.keys(cmd).filter((property) => !stdKeysAndIgnored.has(property));
    const additionalProperties = Object.fromEntries(keysToAdd.map((key) => [key, cmd[key]]));
    return { ...stdProperties, ...additionalProperties };
}
exports.cacheCommand = cacheCommand;
