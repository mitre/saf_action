"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasPath = exports.getFirstPath = exports.removeNewlinePlaceholders = exports.escapeQuotes = exports.removeWhitespace = exports.unformatText = exports.wrap = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
// Breaks lines down to lineLength number of characters
function wrap(s, lineLength = 80) {
    let newString = '';
    let currentLength = 0;
    let shouldBreakLine = false;
    for (let i = 0; i < s.length; i++) {
        if (shouldBreakLine) {
            newString += '\n';
            currentLength = 0;
            shouldBreakLine = false;
        }
        const currentChar = s.charAt(i);
        const nextChar = s.charAt(i + 1);
        if (nextChar === ' ') {
            if (currentLength >= lineLength) {
                shouldBreakLine = true;
                newString += currentChar;
                currentLength++;
            }
            else {
                newString += currentChar;
                currentLength++;
            }
        }
        else {
            newString += currentChar;
            currentLength++;
        }
    }
    return newString;
}
exports.wrap = wrap;
// Remove new lines and tabs
function unformatText(s) {
    return s.replace(/\n/g, ' ').replace(/\\n/g, ' ').replace(/( +|\t)/g, ' ');
}
exports.unformatText = unformatText;
function removeWhitespace(input) {
    return input.replace(/\s/gi, '');
}
exports.removeWhitespace = removeWhitespace;
const escapeSpecialCaseBackslashes = (s) => {
    return s.replace(/\\\)/g, '\\\\)'); // Escape backslashes if preceding close parentheses
};
const escapeSingleQuotes = (s) => {
    return s.replace(/\\/g, '\\\\').replace(/'/g, "\\'"); // Escape backslashes and quotes
};
const escapeDoubleQuotes = (s) => {
    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"'); // Escape backslashes and double quotes
};
function escapeQuotes(s) {
    if (s.includes("'") && s.includes('"')) {
        return `%q(${escapeSpecialCaseBackslashes(removeNewlinePlaceholders(s))})`;
    }
    else if (s.includes("'")) {
        return `"${escapeDoubleQuotes(removeNewlinePlaceholders(s))}"`;
    }
    else {
        return `'${escapeSingleQuotes(removeNewlinePlaceholders(s))}'`;
    }
}
exports.escapeQuotes = escapeQuotes;
function removeNewlinePlaceholders(s) {
    return s.replace(/\{\{\{\{newlineHERE\}\}\}\}/g, '\n');
}
exports.removeNewlinePlaceholders = removeNewlinePlaceholders;
function getFirstPath(object, paths) {
    const index = lodash_1.default.findIndex(paths, (p) => hasPath(object, p));
    if (index === -1) {
        throw new Error(`Attestation is missing one of these paths: ${paths.join(', ')}`);
    }
    else {
        return lodash_1.default.get(object, paths[index]);
    }
}
exports.getFirstPath = getFirstPath;
function hasPath(file, path) {
    let pathArray;
    if (typeof path === 'string') {
        pathArray = [path];
    }
    else {
        pathArray = path;
    }
    return lodash_1.default.some(pathArray, (p) => lodash_1.default.has(file, p));
}
exports.hasPath = hasPath;
