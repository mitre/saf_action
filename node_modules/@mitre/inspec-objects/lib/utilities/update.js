"use strict";
// Utilities to update a profile or control with new metadata
// The ultimate goal is to preserve all the metadata that is already there and only add what is new
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateProfileUsingXCCDF = exports.updateProfile = exports.updateControl = exports.findUpdatedControlByAllIdentifiers = exports.getExistingDescribeFromControl = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const profile_1 = tslib_1.__importDefault(require("../objects/profile"));
const xccdf_1 = require("../parsers/xccdf");
const diff_1 = require("./diff");
const diffMarkdown_1 = require("./diffMarkdown");
function projectValuesOntoExistingObj(dst, src, currentPath = '') {
    for (const updatedValue in src) {
        const existingValue = lodash_1.default.get(dst, updatedValue);
        // We have a new value for something that already exists in dst
        if (existingValue !== undefined) {
            if (typeof existingValue === 'object' && existingValue !== null && !Array.isArray(existingValue)) {
                dst[updatedValue] = projectValuesOntoExistingObj(existingValue, src[updatedValue], currentPath + updatedValue + '.');
            }
            else if (typeof src[updatedValue] === 'string') {
                lodash_1.default.set(dst, updatedValue, src[updatedValue].trim());
            }
            else if (typeof src[updatedValue] === 'number') {
                lodash_1.default.set(dst, updatedValue, src[updatedValue]);
            }
            else if (Array.isArray(src[updatedValue])) {
                const uniqueArrayValues = [...new Set(lodash_1.default.get(dst, updatedValue, []).concat(src[updatedValue]))];
                lodash_1.default.set(dst, updatedValue, uniqueArrayValues);
            }
        }
    }
    return dst;
}
function getRangesForLines(text) {
    /*
      Returns an array containing two numerical indices (i.e., start and stop
      line numbers) for each string or multi-line comment, given raw text as
      an input parameter. The raw text is a string containing the entirety of an
      InSpec control.
  
      Algorithm utilizes a pair of stacks (i.e., `stack`, `rangeStack`) to keep
      track of string delimiters and their associated line numbers, respectively.
  
      Combinations Handled:
      - Single quotes (')
      - Double quotes (")
      - Back ticks (`)
      - Mixed quotes ("`'")
      - Percent strings (%; keys: q, Q, r, i, I, w, W, x; delimiters: (), {},
        [], <>, most non-alphanumeric characters); (e.g., "%q()")
      - Percent literals (%; delimiters: (), {}, [], <>, most non-
        alphanumeric characters); (e.g., "%()")
      - Multi-line comments (e.g., =begin\nSome comment\n=end)
      - Variable delimiters (i.e., paranthesis: (); array: []; hash: {})
    */
    const stringDelimiters = { '(': ')', '{': '}', '[': ']', '<': '>' };
    const variableDelimiters = { '(': ')', '{': '}', '[': ']' };
    const quotes = '\'"`';
    const strings = 'qQriIwWxs';
    let skipCharLength;
    (function (skipCharLength) {
        skipCharLength[skipCharLength["string"] = '('.length] = "string";
        skipCharLength[skipCharLength["percentString"] = 'q('.length] = "percentString";
        skipCharLength[skipCharLength["commentBegin"] = '=begin'.length] = "commentBegin";
    })(skipCharLength || (skipCharLength = {}));
    const stack = [];
    const rangeStack = [];
    const ranges = [];
    const lines = text.split('\n');
    for (let i = 0; i < lines.length; i++) {
        let j = 0;
        while (j < lines[i].length) {
            const line = lines[i];
            let char = line[j];
            const isEmptyStack = (stack.length == 0);
            const isNotEmptyStack = (stack.length > 0);
            const isQuoteChar = quotes.includes(char);
            const isNotEscapeChar = ((j == 0) || (j > 0 && line[j - 1] != '\\'));
            const isPercentChar = (char == '%');
            const isVariableDelimiterChar = Object.keys(variableDelimiters).includes(char);
            const isStringDelimiterChar = ((j < line.length - 1) && (/^[^A-Za-z0-9]$/.test(line[j + 1])));
            const isCommentBeginChar = ((j == 0) && (line.length >= 6) && (line.slice(0, 6) == '=begin'));
            const isPercentStringKeyChar = ((j < line.length - 1) && (strings.includes(line[j + 1])));
            const isPercentStringDelimiterChar = ((j < line.length - 2) && (/^[^A-Za-z0-9]$/.test(line[j + 2])));
            const isPercentString = (isPercentStringKeyChar && isPercentStringDelimiterChar);
            let baseCondition = (isEmptyStack && isNotEscapeChar);
            const quotePushCondition = (baseCondition && isQuoteChar);
            const variablePushCondition = (baseCondition && isVariableDelimiterChar);
            const stringPushCondition = (baseCondition && isPercentChar && isStringDelimiterChar);
            const percentStringPushCondition = (baseCondition && isPercentChar && isPercentString);
            const commentBeginCondition = (baseCondition && isCommentBeginChar);
            if (stringPushCondition) {
                j += skipCharLength.string; // j += 1
            }
            else if (percentStringPushCondition) {
                j += skipCharLength.percentString; // j += 2
            }
            else if (commentBeginCondition) {
                j += skipCharLength.commentBegin; // j += 6
            }
            char = line[j];
            baseCondition = (isNotEmptyStack && isNotEscapeChar);
            const delimiterCondition = (baseCondition && Object.keys(stringDelimiters).includes(stack[stack.length - 1]));
            const delimiterPushCondition = (delimiterCondition && (stack[stack.length - 1] == char));
            const delimiterPopCondition = (delimiterCondition && (stringDelimiters[stack[stack.length - 1]] == char));
            const basePopCondition = (baseCondition && (stack[stack.length - 1] == char) && !Object.keys(stringDelimiters).includes(char));
            const isCommentEndChar = ((j == 0) && (line.length >= 4) && (line.slice(0, 4) == '=end'));
            const commentEndCondition = (baseCondition && isCommentEndChar && (stack[stack.length - 1] == '=begin'));
            const popCondition = (basePopCondition || delimiterPopCondition || commentEndCondition);
            const pushCondition = (quotePushCondition || variablePushCondition || stringPushCondition ||
                percentStringPushCondition || delimiterPushCondition || commentBeginCondition);
            if (popCondition) {
                stack.pop();
                rangeStack[rangeStack.length - 1].push(i);
                const range_ = rangeStack.pop();
                if (rangeStack.length == 0) {
                    ranges.push(range_);
                }
            }
            else if (pushCondition) {
                if (commentBeginCondition) {
                    stack.push('=begin');
                }
                else {
                    stack.push(char);
                }
                rangeStack.push([i]);
            }
            j++;
        }
    }
    return ranges;
}
function joinMultiLineStringsFromRanges(text, ranges) {
    /*
      Returns an array of strings and joined strings at specified ranges, given
      raw text as an input parameter.
    */
    const originalLines = text.split('\n');
    const joinedLines = [];
    let i = 0;
    while (i < originalLines.length) {
        let foundInRanges = false;
        for (const [startIndex, stopIndex] of ranges) {
            if (i >= startIndex && i <= stopIndex) {
                joinedLines.push(originalLines.slice(startIndex, stopIndex + 1).join('\n'));
                foundInRanges = true;
                i = stopIndex;
                break;
            }
        }
        if (!foundInRanges) {
            joinedLines.push(originalLines[i]);
        }
        i++;
    }
    return joinedLines;
}
function getMultiLineRanges(ranges) {
    /*
      Drops ranges with the same start and stop line numbers (i.e., strings
      that populate a single line)
    */
    const multiLineRanges = [];
    for (const [start, stop] of ranges) {
        if (start !== stop) {
            multiLineRanges.push([start, stop]);
        }
    }
    return multiLineRanges;
}
/*
  This is the most likely thing to break if you are getting code formatting issues.
  Extract the existing describe blocks (what is actually run by inspec for validation)
*/
function getExistingDescribeFromControl(control) {
    if (control.code) {
        // Join multi-line strings in InSpec control.
        const ranges = getRangesForLines(control.code);
        const multiLineRanges = getMultiLineRanges(ranges);
        const lines = joinMultiLineStringsFromRanges(control.code, multiLineRanges); // Array of lines representing the full InSpec control, with multi-line strings collapsed
        // Define RegExp for lines to skip when searching for describe block.
        const skip = ['control\\W', '  title\\W', '  desc\\W', '  impact\\W', '  tag\\W', '  ref\\W'];
        const skipRegExp = RegExp(skip.map(x => `(^${x})`).join('|'));
        // Extract describe block from InSpec control with collapsed multiline strings.
        const describeBlock = [];
        let ignoreNewLine = true;
        for (const line of lines) {
            const checkRegExp = ((line.trim() !== '') && !skipRegExp.test(line));
            const checkNewLine = ((line.trim() === '') && !ignoreNewLine);
            // Include '\n' if it is part of describe block, otherwise skip line.
            if (checkRegExp || checkNewLine) {
                describeBlock.push(line);
                ignoreNewLine = false;
            }
            else {
                ignoreNewLine = true;
            }
        }
        return describeBlock.slice(0, describeBlock.length - 2).join('\n'); // Drop trailing ['end', '\n'] from Control block.
    }
    else {
        return '';
    }
}
exports.getExistingDescribeFromControl = getExistingDescribeFromControl;
function findUpdatedControlByAllIdentifiers(existingControl, updatedControls) {
    // Try to match based on IDs
    let updatedControl = updatedControls.find((updatedControl) => {
        return updatedControl.id.toLowerCase() === existingControl.id.toLowerCase();
    });
    if (updatedControl) {
        return updatedControl;
    }
    // Try to match based on legacy identifiers
    updatedControl = updatedControls.find((updatedControl) => {
        var _a;
        return (_a = updatedControl.tags.legacy) === null || _a === void 0 ? void 0 : _a.some((legacyTag) => {
            var _a;
            return legacyTag.toLowerCase() === ((_a = existingControl.id) === null || _a === void 0 ? void 0 : _a.toLowerCase());
        });
    });
    if (updatedControl) {
        return updatedControl;
    }
    return undefined;
}
exports.findUpdatedControlByAllIdentifiers = findUpdatedControlByAllIdentifiers;
function updateControl(from, update, logger) {
    const existingDescribeBlock = getExistingDescribeFromControl(from);
    logger.debug(`Existing describe block for control ${from.id}: ${JSON.stringify(existingDescribeBlock)}`);
    const projectedControl = projectValuesOntoExistingObj(from, update);
    projectedControl.describe = existingDescribeBlock;
    return projectedControl;
}
exports.updateControl = updateControl;
function updateProfile(from, using, logger) {
    // Update the profile with the new metadata
    const to = new profile_1.default(lodash_1.default.omit(from, 'controls'));
    // Find the diff
    const diff = (0, diff_1.diffProfile)(from, using, logger);
    // Add the new controls
    diff.ignoreFormattingDiff.addedControlIDs.forEach(id => {
        const addedControl = diff.ignoreFormattingDiff.addedControls[id];
        if (addedControl) {
            logger.debug(`New Control: ${addedControl.id} - ${addedControl.title}`);
            to.controls.push(addedControl);
        }
        else {
            throw new Error(`New control ${id} added but don't have the control data`);
        }
    });
    // Update the existing controls
    for (const existingControl of from.controls) {
        const updatedControl = findUpdatedControlByAllIdentifiers(existingControl, using.controls);
        if (updatedControl) {
            const controlDiff = diff.ignoreFormattingDiff.changedControls[updatedControl.id];
            if (controlDiff) {
                to.controls.push(updateControl(existingControl, controlDiff, logger));
            }
            else {
                to.controls.push(existingControl);
            }
        }
    }
    return {
        profile: to,
        diff,
    };
}
exports.updateProfile = updateProfile;
function updateProfileUsingXCCDF(from, using, id, logger, ovalDefinitions) {
    logger.debug(`Updating profile ${from.name} with control IDs: ${id}`);
    // Parse the XCCDF benchmark and convert it into a Profile
    logger.debug('Loading XCCDF File');
    const xccdfProfile = (0, xccdf_1.processXCCDF)(using, false, id, ovalDefinitions);
    logger.debug('Loaded XCCDF File');
    // Update the profile and return
    logger.debug('Creating updated profile');
    const updatedProfile = updateProfile(from, xccdfProfile, logger);
    logger.debug('Creating diff markdown');
    // Create the markdown
    const markdown = (0, diffMarkdown_1.createDiffMarkdown)(updatedProfile.diff);
    logger.debug('Profile update complete');
    return {
        profile: updatedProfile.profile,
        diff: updatedProfile.diff,
        markdown: markdown
    };
}
exports.updateProfileUsingXCCDF = updateProfileUsingXCCDF;
