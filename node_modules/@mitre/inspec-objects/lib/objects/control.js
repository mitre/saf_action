"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.objectifyDescriptions = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const flat_1 = require("flat");
const global_1 = require("../utilities/global");
const logging_1 = require("../utilities/logging");
function objectifyDescriptions(descs) {
    if (Array.isArray(descs)) {
        const descriptions = {};
        descs.forEach((description) => {
            descriptions[description.label] = description.data;
        });
        return descriptions;
    }
    return descs || {};
}
exports.objectifyDescriptions = objectifyDescriptions;
class Control {
    constructor(data) {
        this.tags = {};
        this.refs = [];
        this.tags = {};
        if (data) {
            Object.entries(data).forEach(([key, value]) => {
                lodash_1.default.set(this, key, value);
            });
        }
    }
    toUnformattedObject() {
        const flattened = (0, flat_1.flatten)(this);
        Object.entries(flattened).forEach(([key, value]) => {
            if (typeof value === 'string') {
                lodash_1.default.set(flattened, key, value);
            }
        });
        return new Control((0, flat_1.unflatten)(flattened));
    }
    // WIP - provides the ability to get the control in its raw form
    toString() {
        let result = '';
        result += `control '${this.id}' do\n`;
        if (this.title) {
            result += `  title "${this.title}"\n`;
        }
        // This is the known 'default' description - on previous version this content was repeated on descriptions processed by "descs"
        if (this.desc) {
            result += `  desc "${this.desc}"\n`;
        }
        if (this.descs) {
            Object.entries(this.descs).forEach(([key, subDesc]) => {
                if (subDesc) {
                    result += `  desc '${key}', "${subDesc}"\n`;
                }
            });
        }
        if (this.impact) {
            result += `  impact ${this.impact}\n`;
        }
        if (this.refs) {
            this.refs.forEach((ref) => {
                var _a;
                if (typeof ref === 'string') {
                    result += `  ref "${ref}"\n`;
                }
                else {
                    result += `  ref ${((_a = ref.ref) === null || _a === void 0 ? void 0 : _a.toString()) || ''}, url: ${ref.url || ''}`;
                }
            });
        }
        Object.entries(this.tags).forEach(([tag, value]) => {
            if (typeof value === 'object') {
                if (Array.isArray(value) && typeof value[0] === 'string') {
                    result += `  tag ${tag}: ${JSON.stringify(value)}\n`;
                }
                else {
                    result += `  tag '${tag}': ${(value == null ? 'nil' : value)}\n`;
                }
            }
            else if (typeof value === 'string') {
                if (value.includes('"')) {
                    result += `  tag "${tag}": "${value}"\n`;
                }
                else {
                    result += `  tag '${tag}': '${value}'\n`;
                }
            }
        });
        if (this.describe) {
            result += '\n';
            result += this.describe;
        }
        if (!result.slice(-1).match('\n')) {
            result += '\n';
        }
        result += 'end\n';
        return result;
    }
    toRuby(verbose = true) {
        const logger = (0, logging_1.createWinstonLogger)();
        let result = '';
        result += `control '${this.id}' do\n`;
        if (this.title) {
            result += `  title ${(0, global_1.escapeQuotes)(this.title)}\n`;
        }
        else {
            if (verbose) {
                logger.error(`${this.id} does not have a title`);
            }
        }
        // This is the known 'default' description - on previous version this content was repeated on descriptions processed by "descs"
        if (this.desc) {
            result += `  desc ${(0, global_1.escapeQuotes)(this.desc)}\n`;
        }
        else {
            if (verbose) {
                logger.error(`${this.id} does not have a desc`);
            }
        }
        if (this.descs) {
            Object.entries(this.descs).forEach(([key, subDesc]) => {
                if (subDesc) {
                    if (key.match('default') && this.desc) {
                        if (subDesc != this.desc) {
                            // The "default" keyword may have the same content as the desc content for backward compatibility with different historical InSpec versions.
                            // In that case, we can ignore writing the "default" subdescription field.
                            // If they are different, however, someone may be trying to use the keyword "default" for a unique subdescription, which should not be done.
                            if (verbose) {
                                logger.error(`${this.id} has a subdescription called "default" with contents that do not match the main description. "Default" should not be used as a keyword for unique sub-descriptions.`);
                            }
                        }
                    }
                    else {
                        result += `  desc '${key}', ${(0, global_1.escapeQuotes)(subDesc)}\n`;
                    }
                }
                else {
                    if (verbose) {
                        logger.error(`${this.id} does not have a desc for the value ${key}`);
                    }
                }
            });
        }
        if (this.impact !== undefined) {
            result += `  impact ${(this.impact <= 0 ? this.impact.toFixed(1) : this.impact)}\n`;
        }
        else {
            if (verbose) {
                logger.error(`${this.id} does not have an impact`);
            }
        }
        if (this.refs) {
            this.refs.forEach((ref) => {
                var _a;
                if (typeof ref === 'string') {
                    result += `  ref ${(0, global_1.escapeQuotes)(ref)}\n`;
                }
                else {
                    result += `  ref ${(0, global_1.escapeQuotes)(((_a = ref.ref) === null || _a === void 0 ? void 0 : _a.toString()) || '')}, url: ${(0, global_1.escapeQuotes)(ref.url || '')}`;
                }
            });
        }
        Object.entries(this.tags).forEach(([tag, value]) => {
            if (value) {
                if (typeof value === 'object') {
                    if (Array.isArray(value) && typeof value[0] === 'string') {
                        // The goal is to keep the style similar to cookstyle formatting
                        result += `  tag ${tag}: ${JSON.stringify(value)
                            .replace(/"/g, "'") // replace the double quotes with single quotes, ex: ["V-72029","SV-86653"] -> ['V-72029','SV-86653']
                            .split("','") // split the items in the string
                            .join("', '")}\n`; // join them together using single quote and a space, ex: ['V-72029','SV-86653'] -> ['V-72029', 'SV-86653']
                    }
                    else {
                        // Convert JSON Object to Ruby Hash
                        const stringifiedObject = JSON.stringify(value, null, 2)
                            .replace(/\n/g, '\n  ')
                            .replace(/\{\n {6}/g, '{')
                            .replace(/\[\n {8}/g, '[')
                            .replace(/\n {6}\]/g, ']')
                            .replace(/\n {4}\}/g, '}')
                            .replace(/": \[/g, '" => [');
                        result += `  tag ${tag}: ${stringifiedObject}\n`;
                    }
                }
                else if (typeof value === 'string') {
                    result += `  tag ${tag}: ${(0, global_1.escapeQuotes)(value)}\n`;
                }
            }
            else {
                const nilTagList = ['severity', 'satisfies'];
                if (nilTagList.includes(tag)) {
                    result += `  tag ${tag}: nil\n`;
                }
                else {
                    result += `  tag '${tag}'\n`;
                }
                if (verbose) {
                    logger.info(`${this.id} does not have a value for tag: ${tag}`);
                }
            }
        });
        if (this.describe) {
            result += '\n';
            result += this.describe;
        }
        if (!result.slice(-1).match('\n')) {
            result += '\n';
        }
        result += 'end\n';
        return result;
    }
}
exports.default = Control;
