"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processXCCDF = exports.extractAllComplexChecks = exports.extractAllRules = void 0;
const tslib_1 = require("tslib");
const profile_1 = tslib_1.__importDefault(require("../objects/profile"));
const xccdf_1 = require("../utilities/xccdf");
const control_1 = tslib_1.__importDefault(require("../objects/control"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const CciNistMappingData_1 = require("../mappings/CciNistMappingData");
const pretty_1 = tslib_1.__importDefault(require("pretty"));
const logging_1 = require("../utilities/logging");
function extractAllRules(groups) {
    const rules = [];
    groups.forEach((group) => {
        if (group.Rule) {
            rules.push(...(group.Rule.map((rule) => {
                return {
                    ...rule,
                    group: lodash_1.default.omit(group, ['Rule', 'Group'])
                };
            })));
        }
        if (group.Group) {
            rules.push(...extractAllRules(group.Group));
        }
    });
    return rules;
}
exports.extractAllRules = extractAllRules;
function extractAllComplexChecks(complexCheck) {
    const complexChecks = [lodash_1.default.omit(complexCheck, 'complex-check')];
    if (complexCheck['complex-check']) {
        complexChecks.push(...complexCheck['complex-check'].map((subComplexCheck) => lodash_1.default.omit(subComplexCheck, 'complex-check')));
        complexCheck['complex-check'].forEach((subComplexCheck) => {
            complexChecks.push(...extractAllComplexChecks(subComplexCheck));
        });
    }
    return complexChecks;
}
exports.extractAllComplexChecks = extractAllComplexChecks;
function ensureDecodedXMLStringValue(input) {
    return lodash_1.default.get(input, '[0].#text') ? lodash_1.default.get(input, '[0].#text') : input;
}
// Moving the newline removal to diff library rather than processXCCDF level
function processXCCDF(xml, removeNewlines, useRuleId, ovalDefinitions) {
    const logger = (0, logging_1.createWinstonLogger)();
    const parsedXML = (0, xccdf_1.convertEncodedXmlIntoJson)(xml);
    if (parsedXML.Benchmark === undefined) {
        throw new Error('Could not process the XCCDF file, check the input to make sure this is a properly formatted XCCDF file.');
    }
    const rules = extractAllRules(parsedXML.Benchmark[0].Group);
    const profile = new profile_1.default({
        name: parsedXML.Benchmark[0]['@_id'],
        title: parsedXML.Benchmark[0].title[0]['#text'],
        summary: parsedXML.Benchmark[0].description[0]['#text']
    });
    rules.forEach(rule => {
        var _a, _b, _c;
        let extractedDescription;
        if (typeof rule.description === 'object') {
            if (Array.isArray(rule.description) && lodash_1.default.get(rule, "description[0]['#text']")) {
                extractedDescription = rule.description[0]['#text'];
            }
            else {
                if (typeof lodash_1.default.get(rule.description, '[0].p') === 'string') {
                    extractedDescription = (0, pretty_1.default)(lodash_1.default.get(rule.description, '[0].p'));
                }
                else {
                    if (Array.isArray(lodash_1.default.get(rule.description, '[0].p'))) {
                        const joinedDescriptions = lodash_1.default.get(rule.description, '[0].p');
                        extractedDescription = (0, pretty_1.default)(joinedDescriptions.join('\n\n'));
                    }
                    else {
                        extractedDescription = JSON.stringify(rule.description);
                    }
                }
            }
        }
        else {
            extractedDescription = (0, xccdf_1.convertEncodedHTMLIntoJson)(rule.description);
        }
        const control = new control_1.default();
        switch (useRuleId) {
            case 'group':
                control.id = rule.group['@_id'];
                break;
            case 'rule':
                if (rule['@_id'].toLowerCase().startsWith('sv')) {
                    control.id = rule['@_id'].split('r')[0];
                }
                else {
                    control.id = rule['@_id'];
                }
                break;
            case 'version':
                control.id = rule.version;
                break;
            case 'cis':
                // eslint-disable-next-line  no-case-declarations
                const controlIdRegex = /\d(\d?)(\d?)(\d?)(.\d(\d?)(\d?)(\d?))?(.\d(\d?)(\d?)(\d?))?(.\d(\d?)(\d?)(\d?))?(.\d(\d?)(\d?)(\d?))?/g;
                // eslint-disable-next-line  no-case-declarations
                const controlIdMatch = controlIdRegex.exec(rule['@_id']);
                if (controlIdMatch) {
                    control.id = controlIdMatch[0];
                }
                else {
                    throw new Error(`Could not parse control ID from rule ID: ${rule['@_id']}. Expecting something in this example format: 'xccdf_org.cisecurity.benchmarks_rule_1.1.11_Rule_title_summary`);
                }
                break;
            default:
                throw new Error('useRuleId must be one of "group", "rule", or "version"');
        }
        control.title = (0, xccdf_1.removeXMLSpecialCharacters)(rule['@_severity'] ? ensureDecodedXMLStringValue(rule.title) : `[[[MISSING SEVERITY FROM BENCHMARK]]] ${ensureDecodedXMLStringValue(rule.title)}`);
        if (typeof extractedDescription === 'object' && !Array.isArray(extractedDescription)) {
            control.desc = ((_a = extractedDescription.VulnDiscussion) === null || _a === void 0 ? void 0 : _a.split('Satisfies: ')[0]) || '';
        }
        else if (typeof extractedDescription === 'object') {
            control.desc = JSON.stringify(extractedDescription);
        }
        else if (typeof extractedDescription === 'string') {
            control.desc = extractedDescription || '';
        }
        else {
            logger.warn(`Invalid value for extracted description: ${extractedDescription}`);
        }
        control.impact = (0, xccdf_1.severityStringToImpact)(rule['@_severity'] || 'medium', rule.group['@_id']);
        if (!control.descs || Array.isArray(control.descs)) {
            control.descs = {};
        }
        if (rule.check) {
            if (rule.check.some((ruleValue) => 'check-content' in ruleValue)) {
                control.descs.check = (0, xccdf_1.removeXMLSpecialCharacters)(rule.check ? rule.check[0]['check-content'] : 'Missing description');
                control.tags.check_id = rule.check[0]['@_system'];
            }
            else if (rule.check.some((ruleValue) => 'check-content-ref' in ruleValue) && ovalDefinitions) {
                let referenceID = null;
                for (const checkContent of rule.check) {
                    if ('check-content-ref' in checkContent && checkContent['@_system'].includes('oval')) {
                        logger.info(`Found OVAL reference: ${checkContent['@_system']}`);
                        for (const checkContentRef of checkContent['check-content-ref']) {
                            if (checkContentRef['@_name']) {
                                referenceID = checkContentRef['@_name'];
                            }
                        }
                    }
                }
                if (referenceID && referenceID in ovalDefinitions) {
                    control.descs.check = (0, xccdf_1.removeXMLSpecialCharacters)(ovalDefinitions[referenceID].metadata[0].title);
                }
                else if (referenceID) {
                    logger.warn(`Could not find OVAL definition for ${referenceID}`);
                }
            }
        }
        // Very CIS specific
        else if (rule['complex-check']) {
            const checkTexts = [];
            for (const complexChecks of rule['complex-check']) {
                const allComplexChecks = extractAllComplexChecks(complexChecks);
                if (control.id === '1.1.1.5') {
                    logger.info(allComplexChecks);
                }
                allComplexChecks.forEach((complexCheck) => {
                    if (complexCheck.check) {
                        complexCheck.check.forEach((check) => {
                            var _a;
                            if ((_a = check['@_system']) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes('oval')) {
                                const ovalReference = check['check-content-ref'][0]['@_name'];
                                if (!ovalDefinitions) {
                                    logger.warn(`Missing OVAL definitions! Unable to process OVAL reference: ${ovalReference}`);
                                }
                                else if (ovalReference && ovalReference in ovalDefinitions) {
                                    ovalDefinitions[ovalReference].resolvedValues.forEach((resolvedValue) => {
                                        const comment = resolvedValue['@_comment'];
                                        if (comment) {
                                            checkTexts.push(comment + '\n');
                                        }
                                        resolvedValue.resolvedObjects.forEach((resolvedObject) => {
                                            // Try to find the associated state for a resolved object
                                            const resolvedId = resolvedObject['@_id'].split(':')[resolvedValue['@_id'].split(':').length - 1];
                                            if (resolvedId) {
                                                const relatedResolvedState = resolvedValue.resolvedStates.find((resolvedState) => resolvedState['@_id'].toLowerCase().includes(resolvedId.toLowerCase()));
                                                if (relatedResolvedState) {
                                                    lodash_1.default.set(resolvedObject, 'expectedState', lodash_1.default.pickBy(relatedResolvedState, (value, key) => !key.startsWith('@_')));
                                                }
                                            }
                                            checkTexts.push(JSON.stringify(lodash_1.default.pickBy(resolvedObject, (value, key) => !key.startsWith('@_')), null, 2));
                                        });
                                    });
                                }
                            }
                            else {
                                logger.warn(`Found external reference to unknown system: ${check['@_system']}, only OVAL is supported`);
                            }
                        });
                    }
                });
            }
            if (checkTexts.length >= 1) {
                control.descs.check = checkTexts.join('\n');
            }
        }
        if (lodash_1.default.get(rule.fixtext, '[0]["#text"]')) {
            control.descs.fix = (0, xccdf_1.removeXMLSpecialCharacters)(rule.fixtext[0]['#text']);
        }
        else if (typeof rule.fixtext === 'string') {
            control.descs.fix = (0, xccdf_1.removeXMLSpecialCharacters)(rule.fixtext);
        }
        else if (typeof rule.fixtext === 'object') {
            if (Array.isArray(rule.fixtext)) {
                control.descs.fix = (0, xccdf_1.removeXMLSpecialCharacters)((0, pretty_1.default)((0, xccdf_1.convertJsonIntoXML)(rule.fixtext.map((fixtext) => {
                    if (fixtext.div) {
                        return fixtext.div;
                    }
                    else {
                        return fixtext;
                    }
                }))));
            }
            else {
                control.descs.fix = (0, xccdf_1.removeXMLSpecialCharacters)((0, pretty_1.default)((0, xccdf_1.convertJsonIntoXML)(rule.fixtext)));
            }
        }
        else if (typeof rule.fixtext === 'undefined') {
            if (rule.fix && rule.fix[0]) {
                control.descs.fix = (0, xccdf_1.removeXMLSpecialCharacters)(rule.fix[0]['#text'] || 'Missing fix text');
            }
        }
        else {
            control.descs.fix = 'Missing fix text';
        }
        control.tags.severity = (0, xccdf_1.impactNumberToSeverityString)((0, xccdf_1.severityStringToImpact)(rule['@_severity'] || 'medium', control.id || 'Unknown'));
        control.tags.gid = rule.group['@_id'],
            control.tags.rid = rule['@_id'];
        control.tags.stig_id = rule['version'];
        if (typeof rule.group.title === 'string') {
            control.tags.gtitle = (0, xccdf_1.removeXMLSpecialCharacters)(rule.group.title);
        }
        else {
            control.tags.gtitle = (0, xccdf_1.removeXMLSpecialCharacters)(lodash_1.default.get(rule.group, 'title[0].#text'));
        }
        if (rule['fix'] && rule['fix'].length > 0) {
            control.tags.fix_id = rule['fix'][0]['@_id'];
        }
        if (rule['rationale']) {
            control.tags.rationale = rule['rationale'][0]['#text'];
        }
        if (typeof extractedDescription === 'object') {
            control.tags.satisfies = ((_b = extractedDescription.VulnDiscussion) === null || _b === void 0 ? void 0 : _b.includes('Satisfies: ')) && extractedDescription.VulnDiscussion.split('Satisfies: ').length >= 1 ? extractedDescription.VulnDiscussion.split('Satisfies: ')[1].split(',').map(satisfaction => satisfaction.trim()) : undefined;
            control.tags.false_negatives = extractedDescription.FalseNegatives || undefined;
            control.tags.false_positives = extractedDescription.FalsePositives || undefined;
            control.tags.documentable = typeof extractedDescription.Documentable === 'boolean' ? extractedDescription.Documentable : undefined;
            control.tags.mitigations = extractedDescription.Mitigations || undefined;
            control.tags.severity_override_guidance = extractedDescription.SeverityOverrideGuidance || undefined;
            control.tags.potential_impacts = extractedDescription.PotentialImpacts || undefined;
            control.tags.third_party_tools = extractedDescription.ThirdPartyTools || undefined;
            control.tags.mitigation_control = extractedDescription.MitigationControl || undefined;
            control.tags.mitigation_controls = extractedDescription.MitigationControls || undefined;
            control.tags.responsibility = extractedDescription.Responsibility || undefined;
            control.tags.ia_controls = extractedDescription.IAControls || undefined;
        }
        control.tags = lodash_1.default.mapValues(lodash_1.default.omitBy(control.tags, (value) => value === undefined), (value) => {
            if (typeof value === 'string') {
                return (0, xccdf_1.removeXMLSpecialCharacters)(value);
            }
            else {
                return value;
            }
        });
        // Get all identifiers from the rule
        if (rule.ident) {
            rule.ident.forEach((identifier) => {
                var _a, _b, _c;
                // Get CCIs
                if (identifier['@_system'].toLowerCase().includes('cci')) {
                    if (!('cci' in control.tags)) {
                        control.tags.cci = [];
                    }
                    (_a = control.tags.cci) === null || _a === void 0 ? void 0 : _a.push(identifier['#text']);
                }
                // Get legacy identifiers
                else if (identifier['@_system'].toLowerCase().includes('legacy')) {
                    if (!('legacy' in control.tags)) {
                        control.tags.legacy = [];
                    }
                    (_b = control.tags.legacy) === null || _b === void 0 ? void 0 : _b.push(identifier['#text']);
                }
                // Get NIST identifiers
                else if (identifier['@_system'].toLowerCase().includes('nist')) {
                    if (!('nist' in control.tags)) {
                        control.tags.nist = [];
                    }
                    (_c = control.tags.nist) === null || _c === void 0 ? void 0 : _c.push(identifier['#text']);
                }
            });
        }
        (_c = rule.reference) === null || _c === void 0 ? void 0 : _c.forEach((reference) => {
            var _a, _b, _c, _d;
            if (lodash_1.default.get(reference, '@_href') === '') {
                (_a = control.refs) === null || _a === void 0 ? void 0 : _a.push(lodash_1.default.get(reference, '#text'));
            }
            else {
                try {
                    const referenceText = lodash_1.default.get(reference, '#text') || '';
                    const referenceURL = lodash_1.default.get(reference, '@_href') || '';
                    if (referenceURL) {
                        const parsedURL = new URL(lodash_1.default.get(reference, '@_href'));
                        if (parsedURL.protocol.toLowerCase().includes('http') || parsedURL.protocol.toLowerCase().includes('https')) {
                            (_b = control.refs) === null || _b === void 0 ? void 0 : _b.push({
                                ref: referenceText,
                                url: referenceURL
                            });
                        }
                        else {
                            (_c = control.refs) === null || _c === void 0 ? void 0 : _c.push({
                                ref: referenceText,
                                uri: referenceURL
                            });
                        }
                    }
                    else {
                        if ('title' in reference) {
                            (_d = control.refs) === null || _d === void 0 ? void 0 : _d.push(lodash_1.default.get(reference, 'title'));
                        }
                    }
                    // Add the reference to the control tags when separated by §
                    if (typeof referenceText === 'string' && referenceText.indexOf('§') !== -1) {
                        const referenceParts = referenceText.split('§');
                        if (referenceParts.length == 2) {
                            // eslint-disable-next-line  prefer-const
                            let [identifierType, identifier] = referenceText.split('§');
                            identifierType = identifierType.toLowerCase();
                            if (!(identifierType in control.tags)) {
                                control.tags[identifierType] = [identifier];
                            }
                            else if (Array.isArray(control.tags[identifierType])) {
                                control.tags[identifierType] = lodash_1.default.union(control.tags[identifierType], [identifier]);
                            }
                            else {
                                logger.warn(`Attempted to push identifier to control tags when identifier already exists: ${identifierType}: ${identifier}`);
                            }
                        }
                        else {
                            logger.warn('Reference parts of invalid length:');
                            logger.info(referenceParts);
                        }
                    }
                }
                catch (e) {
                    logger.warn(`Error parsing ref for control ${control.id}: `);
                    logger.warn(JSON.stringify(reference, null, 2));
                    logger.warn(e);
                }
            }
        });
        // Associate any CCIs with NIST tags
        if (control.tags.cci) {
            control.tags.cci.forEach((cci) => {
                var _a;
                if (!('nist' in control.tags)) {
                    control.tags.nist = [];
                }
                if (cci in CciNistMappingData_1.data) {
                    (_a = control.tags.nist) === null || _a === void 0 ? void 0 : _a.push(lodash_1.default.get(CciNistMappingData_1.data, cci));
                }
            });
        }
        profile.controls.push(control);
    });
    profile.controls = lodash_1.default.sortBy(profile.controls, 'id');
    return profile.toUnformattedObject();
}
exports.processXCCDF = processXCCDF;
