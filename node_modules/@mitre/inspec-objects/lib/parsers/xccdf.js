"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processXCCDF = exports.extractAllRules = void 0;
const tslib_1 = require("tslib");
const profile_1 = tslib_1.__importDefault(require("../objects/profile"));
const xccdf_1 = require("../utilities/xccdf");
const control_1 = tslib_1.__importDefault(require("../objects/control"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const CciNistMappingData_1 = require("../mappings/CciNistMappingData");
function extractAllRules(groups) {
    const rules = [];
    groups.forEach((group) => {
        if (group.Rule) {
            rules.push(...(group.Rule.map((rule) => {
                return {
                    ...rule,
                    group: lodash_1.default.omit(group, ['Rule', 'Group'])
                };
            })));
        }
        if (group.Group) {
            rules.push(...extractAllRules(group.Group));
        }
    });
    return rules;
}
exports.extractAllRules = extractAllRules;
function ensureDecodedXMLStringValue(input) {
    return lodash_1.default.get(input, '[0].#text') ? lodash_1.default.get(input, '[0].#text') : input;
}
function processXCCDF(xml, removeNewlines = false, useRuleId, ovalDefinitions) {
    const parsedXML = (0, xccdf_1.convertEncodedXmlIntoJson)(xml);
    const rules = extractAllRules(parsedXML.Benchmark[0].Group);
    const profile = new profile_1.default({
        name: parsedXML.Benchmark[0]['@_id'],
        title: parsedXML.Benchmark[0].title[0]['#text'],
        summary: parsedXML.Benchmark[0].description[0]['#text']
    });
    rules.forEach(rule => {
        var _a, _b, _c;
        let extractedDescription;
        if (Array.isArray(rule.description)) {
            extractedDescription = rule.description[0]['#text'];
        }
        else {
            extractedDescription = (0, xccdf_1.convertEncodedHTMLIntoJson)(rule.description);
        }
        const control = new control_1.default();
        switch (useRuleId) {
            case 'group':
                control.id = rule.group['@_id'];
                break;
            case 'rule':
                if (rule['@_id'].toLowerCase().startsWith('sv')) {
                    control.id = rule['@_id'].split('r')[0];
                }
                else {
                    control.id = rule['@_id'];
                }
                break;
            case 'version':
                control.id = rule.version;
                break;
            case 'cis':
                const controlIdRegex = /\d(\d?)(\d?)(\d?)(.\d(\d?)(\d?)(\d?))?(.\d(\d?)(\d?)(\d?))?(.\d(\d?)(\d?)(\d?))?(.\d(\d?)(\d?)(\d?))?/g;
                const controlIdMatch = controlIdRegex.exec(rule['@_id']);
                if (controlIdMatch) {
                    control.id = controlIdMatch[0];
                }
                else {
                    throw new Error(`Could not parse control ID from rule ID: ${rule['@_id']}. Expecting format: 'xccdf_org.cisecurity.benchmarks_rule_1.1.11_Rule_title_summary`);
                }
                break;
            default:
                throw new Error('useRuleId must be one of "group", "rule", or "version"');
        }
        control.title = (0, xccdf_1.removeXMLSpecialCharacters)(rule['@_severity'] ? ensureDecodedXMLStringValue(rule.title) : `[[[MISSING SEVERITY FROM STIG]]] ${ensureDecodedXMLStringValue(rule.title)}`);
        const descriptionText = (typeof extractedDescription === 'object' && !Array.isArray(extractedDescription)) ? ((_a = extractedDescription.VulnDiscussion) === null || _a === void 0 ? void 0 : _a.split('Satisfies: ')[0]) || 'Missing Description' : '';
        control.desc = (0, xccdf_1.removeXMLSpecialCharacters)(descriptionText);
        control.impact = (0, xccdf_1.severityStringToImpact)(rule['@_severity'] || 'medium', rule.group['@_id']);
        if (!control.descs || Array.isArray(control.descs)) {
            control.descs = {};
        }
        if (rule.check) {
            if (rule.check.some((ruleValue) => 'check-content' in ruleValue)) {
                control.descs.check = (0, xccdf_1.removeXMLSpecialCharacters)(rule.check ? rule.check[0]['check-content'] : 'Missing description');
                control.tags.check_id = rule.check[0]['@_system'];
            }
            else if (rule.check.some((ruleValue) => 'check-content-ref' in ruleValue) && ovalDefinitions) {
                let referenceID = null;
                for (const checkContent of rule.check) {
                    if ('check-content-ref' in checkContent && checkContent['@_system'].includes('oval')) {
                        for (const checkContentRef of checkContent['check-content-ref']) {
                            if (checkContentRef['@_name']) {
                                referenceID = checkContentRef['@_name'];
                            }
                        }
                    }
                }
                if (referenceID && referenceID in ovalDefinitions) {
                    control.descs.check = (0, xccdf_1.removeXMLSpecialCharacters)(ovalDefinitions[referenceID].metadata[0].title);
                }
                else if (referenceID) {
                    console.warn(`Could not find OVAL definition for ${referenceID}`);
                }
            }
        }
        if (lodash_1.default.get(rule.fixtext, '[0]["#text"]')) {
            control.descs.fix = (0, xccdf_1.removeXMLSpecialCharacters)(rule.fixtext[0]['#text']);
        }
        else if (typeof rule.fixtext === 'string') {
            control.descs.fix = (0, xccdf_1.removeXMLSpecialCharacters)(rule.fixtext);
        }
        else if (typeof rule.fixtext === 'object') {
            if (Array.isArray(rule.fixtext)) {
                control.descs.fix = (0, xccdf_1.removeXMLSpecialCharacters)(JSON.stringify(rule.fixtext));
            }
        }
        else if (typeof rule.fixtext === 'undefined') {
            if (rule.fix && rule.fix[0]) {
                control.descs.fix = (0, xccdf_1.removeXMLSpecialCharacters)(rule.fix[0]['#text'] || 'Missing fix text');
            }
        }
        else {
            control.descs.fix = 'Missing fix text';
        }
        control.tags.severity = (0, xccdf_1.impactNumberToSeverityString)((0, xccdf_1.severityStringToImpact)(rule['@_severity'] || 'critical', control.id || 'Unknown'));
        control.tags.gid = rule.group['@_id'],
            control.tags.rid = rule['@_id'];
        control.tags.stig_id = rule['version'];
        if (typeof rule.group.title === "string") {
            control.tags.gtitle = (0, xccdf_1.removeXMLSpecialCharacters)(rule.group.title);
        }
        else {
            control.tags.gtitle = (0, xccdf_1.removeXMLSpecialCharacters)(lodash_1.default.get(rule.group, 'title[0].#text'));
        }
        if (rule['fix'] && rule['fix'].length > 0) {
            control.tags.fix_id = rule['fix'][0]['@_id'];
        }
        if (rule['rationale']) {
            control.tags.rationale = rule['rationale'][0]['#text'];
        }
        if (typeof extractedDescription === 'object') {
            control.tags.satisfies = ((_b = extractedDescription.VulnDiscussion) === null || _b === void 0 ? void 0 : _b.includes('Satisfies: ')) && extractedDescription.VulnDiscussion.split('Satisfies: ').length >= 1 ? extractedDescription.VulnDiscussion.split('Satisfies: ')[1].split(',').map(satisfaction => satisfaction.trim()) : undefined;
            control.tags.false_negatives = extractedDescription.FalseNegatives || undefined;
            control.tags.false_positives = extractedDescription.FalsePositives || undefined;
            control.tags.documentable = typeof extractedDescription.Documentable === 'boolean' ? extractedDescription.Documentable : undefined;
            control.tags.mitigations = extractedDescription.Mitigations || undefined;
            control.tags.severity_override_guidance = extractedDescription.SeverityOverrideGuidance || undefined;
            control.tags.potential_impacts = extractedDescription.PotentialImpacts || undefined;
            control.tags.third_party_tools = extractedDescription.ThirdPartyTools || undefined;
            control.tags.mitigation_control = extractedDescription.MitigationControl || undefined;
            control.tags.mitigation_controls = extractedDescription.MitigationControls || undefined;
            control.tags.responsibility = extractedDescription.Responsibility || undefined;
            control.tags.ia_controls = extractedDescription.IAControls || undefined;
        }
        control.tags = lodash_1.default.mapValues(lodash_1.default.omitBy(control.tags, (value) => value === undefined), (value) => {
            if (typeof value === 'string') {
                return (0, xccdf_1.removeXMLSpecialCharacters)(value);
            }
            else {
                return value;
            }
        });
        // Get all identifiers from the rule
        if (rule.ident) {
            rule.ident.forEach((identifier) => {
                var _a, _b, _c;
                // Get CCIs
                if (identifier['@_system'].toLowerCase().includes('cci')) {
                    if (!('cci' in control.tags)) {
                        control.tags.cci = [];
                    }
                    (_a = control.tags.cci) === null || _a === void 0 ? void 0 : _a.push(identifier['#text']);
                }
                // Get legacy identifiers
                else if (identifier['@_system'].toLowerCase().includes('legacy')) {
                    if (!('legacy' in control.tags)) {
                        control.tags.legacy = [];
                    }
                    (_b = control.tags.legacy) === null || _b === void 0 ? void 0 : _b.push(identifier['#text']);
                }
                // Get NIST identifiers
                else if (identifier['@_system'].toLowerCase().includes('nist')) {
                    if (!('nist' in control.tags)) {
                        control.tags.nist = [];
                    }
                    (_c = control.tags.nist) === null || _c === void 0 ? void 0 : _c.push(identifier['#text']);
                }
            });
        }
        (_c = rule.reference) === null || _c === void 0 ? void 0 : _c.forEach((reference) => {
            var _a, _b, _c, _d;
            if (lodash_1.default.get(reference, '@_href') === '') {
                (_a = control.refs) === null || _a === void 0 ? void 0 : _a.push(lodash_1.default.get(reference, '#text'));
            }
            else {
                try {
                    const referenceText = lodash_1.default.get(reference, '#text') || '';
                    const referenceURL = lodash_1.default.get(reference, '@_href') || '';
                    if (referenceURL) {
                        const parsedURL = new URL(lodash_1.default.get(reference, '@_href'));
                        if (parsedURL.protocol.toLowerCase().includes('http') || parsedURL.protocol.toLowerCase().includes('https')) {
                            (_b = control.refs) === null || _b === void 0 ? void 0 : _b.push({
                                ref: referenceText,
                                url: referenceURL
                            });
                        }
                        else {
                            (_c = control.refs) === null || _c === void 0 ? void 0 : _c.push({
                                ref: referenceText,
                                uri: referenceURL
                            });
                        }
                    }
                    else {
                        if ('title' in reference) {
                            (_d = control.refs) === null || _d === void 0 ? void 0 : _d.push(lodash_1.default.get(reference, 'title'));
                        }
                    }
                    // Add the reference to the control tags when separated by ยง
                    if (typeof referenceText === 'string' && referenceText.indexOf('ยง') !== -1) {
                        const referenceParts = referenceText.split('ยง');
                        if (referenceParts.length == 2) {
                            let [identifierType, identifier] = referenceText.split('ยง');
                            identifierType = identifierType.toLowerCase();
                            if (!(identifierType in control.tags)) {
                                control.tags[identifierType] = [identifier];
                            }
                            else if (Array.isArray(control.tags[identifierType])) {
                                control.tags[identifierType] = lodash_1.default.union(control.tags[identifierType], [identifier]);
                            }
                            else {
                                console.warn(`Attempted to push identifier to control tags when identifier already exists: ${identifierType}: ${identifier}`);
                            }
                        }
                        else {
                            console.warn("Reference parts of invalid length:");
                            console.log(referenceParts);
                        }
                    }
                }
                catch (e) {
                    console.warn(`Error parsing ref for control ${control.id}: `);
                    console.warn(JSON.stringify(reference, null, 2));
                    console.warn(e);
                }
            }
        });
        // Associate any CCIs with NIST tags
        if (control.tags.cci) {
            control.tags.cci.forEach((cci) => {
                var _a;
                if (!('nist' in control.tags)) {
                    control.tags.nist = [];
                }
                if (cci in CciNistMappingData_1.data) {
                    (_a = control.tags.nist) === null || _a === void 0 ? void 0 : _a.push(lodash_1.default.get(CciNistMappingData_1.data, cci));
                }
            });
        }
        profile.controls.push(control);
    });
    profile.controls = lodash_1.default.sortBy(profile.controls, 'id');
    return profile.toUnformattedObject();
}
exports.processXCCDF = processXCCDF;
