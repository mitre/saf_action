"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/no-explicit-any */
const core_1 = require("@oclif/core");
const fs_1 = tslib_1.__importStar(require("fs"));
const inspec_objects_1 = require("@mitre/inspec-objects");
const path_1 = tslib_1.__importDefault(require("path"));
const logging_1 = require("../../utils/logging");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const fuse_js_1 = tslib_1.__importDefault(require("fuse.js"));
const child_process_1 = require("child_process");
const tmp_1 = tslib_1.__importDefault(require("tmp"));
const lodash_1 = tslib_1.__importStar(require("lodash"));
const cliHelper_1 = require("../../utils/oclif/cliHelper");
const baseCommand_1 = require("../../utils/oclif/baseCommand");
const events_1 = require("events");
const colors_1 = tslib_1.__importDefault(require("colors"));
const prompts_1 = require("@inquirer/prompts");
const global_1 = require("../../utils/global");
/**
 * This class extends the capabilities of the update_controls4delta providing the following capabilities:
 *   1 - Creates new controls found in updated guidances
*    2 - Fuzzy matching capability (optional)
*        a - Maps controls based on similarity and not control IDs
*        b - For controls which a match is found, the describe block (code)
*            within the old control is mapped over to the new control
*    3 - Detailed logging
*        a - report file (.md), mapping statistics (CliProcessOutput.log)
*/
class GenerateDelta extends baseCommand_1.BaseCommand {
    static description = 'Update an existing InSpec profile with new or updated XCCDF guidance';
    static flags = {
        inspecJsonFile: core_1.Flags.string({
            char: 'J', required: false, exclusive: ['interactive'],
            description: 'InSpec Profile Controls JSON summary file - can be generated using the "[cinc-auditor or inspec] json <profile path> | jq . > profile.json" command',
        }),
        xccdfXmlFile: core_1.Flags.string({
            char: 'X', exclusive: ['interactive', 'xccdfUrl'],
            description: '\x1B[31m(required [-X or -U] or --interactive)\x1B[34m The XCCDF File containing the new guidance (.xml or .zip)',
        }),
        xccdfUrl: core_1.Flags.url({
            char: 'U', exclusive: ['interactive', 'xccdfXmlFile'],
            description: '\x1B[31m(required [-X or -U] or --interactive)\x1B[34m The URL for the XCCDF package containing the new guidance (.zip, e.g., DISA STIG downloads)',
        }),
        deltaOutputDir: core_1.Flags.string({
            char: 'o', required: false, exclusive: ['interactive'],
            description: '\x1B[31m(required if not --interactive)\x1B[34m The output folder for the updated profile (this will contain the new controls modified by delta) - if it is not empty, it will be overwritten.'
        }),
        ovalXmlFile: core_1.Flags.string({
            char: 'O', required: false, exclusive: ['interactive'],
            description: 'The OVAL XML file containing definitions used in the new guidance - in the form of .xml file'
        }),
        reportFile: core_1.Flags.string({
            char: 'r', required: false, exclusive: ['interactive'],
            description: 'Output markdown report file - must have an extension of .md'
        }),
        idType: core_1.Flags.string({
            char: 'T', required: false, exclusive: ['interactive'],
            default: 'rule', options: ['rule', 'group', 'cis', 'version'],
            description: "Control ID Types: 'rule' - Vulnerability IDs (ex. 'SV-XXXXX'), 'group' - Group IDs (ex. 'V-XXXXX'), 'cis' - CIS Rule IDs (ex. C-1.1.1.1), 'version' - Version IDs (ex. RHEL-07-010020 - also known as STIG IDs)",
        }),
        // New flag -M for whether to try mapping controls to new profile
        runMapControls: core_1.Flags.boolean({
            char: 'M', required: false,
            exclusive: ['interactive'],
            dependsOn: ['controlsDir'],
            description: 'Run the approximate string matching process',
        }),
        controlsDir: core_1.Flags.string({
            char: 'c', required: false, exclusive: ['interactive'],
            description: '\x1B[31m(required with -M or -J not provided)\x1B[34m The InSpec profile directory containing the controls to update (controls Delta is processing)'
        }),
    };
    static examples = [
        {
            description: '\x1B[93mRunning the CLI interactively\x1B[0m',
            command: '<%= config.bin %> <%= command.id %> --interactive',
        },
        {
            description: '\x1B[93mProviding a XCCDF (File), a Profile Controls Summary, and no Fuzzy matching)\x1B[0m',
            command: '<%= config.bin %> <%= command.id %> -X <xccdf_benchmarks.[xml, zip]>, -J <profile_summary.json> -c <current-controls-dir> -o <updated_controls_dir>, [options]',
        },
        {
            description: '\x1B[93mProviding a XCCDF (URL), a Profile Controls Summary, and no Fuzzy matching)\x1B[0m',
            command: '<%= config.bin %> <%= command.id %> -U <URL-to-benchmark.zip>, -J <profile_summary.json> -c <current-controls-dir> -o <updated_controls_dir>, [options]',
        },
        {
            description: '\x1B[93mProviding a XCCDF (File), a Profile Controls Summary, with Fuzzy matching)\x1B[0m',
            command: '<%= config.bin %> <%= command.id %> -X <xccdf_benchmarks.[xml, zip]>, -J <profile_summary.json> -c <current-controls-dir> -o <updated_controls_dir>, -M, [options]',
        },
        {
            description: '\x1B[93mProviding a XCCDF (URL), a Profile Controls Summary, with Fuzzy matching)\x1B[0m',
            command: '<%= config.bin %> <%= command.id %> -U <URL-to-benchmark.zip>, -J <profile_summary.json> -c <current-controls-dir> -o <updated_controls_dir>, -M, [options]',
        },
    ];
    // Statistics variables
    static logger;
    static match = 0;
    static noMatch = 0;
    static dupMatch = 0;
    static posMisMatch = 0;
    static newXccdfControl = 0;
    static oldControlsLength = 0;
    static newControlsLength = 0;
    // eslint-disable-next-line complexity
    async run() {
        const { flags } = await this.parse(GenerateDelta);
        // If not interactive must provide either -X or -U
        if (!flags.interactive && !flags.xccdfXmlFile && !flags.xccdfUrl) {
            this.error('\x1B[31mIf not interactive you must specify either [-X, --xccdfXmlFile or -U --xccdfUrl]\x1B[0m');
        }
        // If not interactive and -J not provided the -c must be provided
        if (!flags.interactive && !flags.inspecJsonFile && !flags.controlsDir) {
            this.error('\x1B[31mIf not interactive and -J not provided the Controls Directory (-c) must be provided\x1B[0m');
        }
        if (flags.runMapControls && !flags.controlsDir) {
            this.error('\x1B[31mIf not interactive and -M is provided the Controls Directory (-c) must be provided\x1B[0m');
        }
        // Set the log level to debug until we get the user selected level
        GenerateDelta.logger = (0, logging_1.createWinstonLogger)('generate:delta', 'debug');
        // Flag variables
        let inspecJsonFile = '';
        let xccdfXmlFile = '';
        let xccdfContent = '';
        let deltaOutputDir = '';
        let ovalXmlFile = '';
        let reportFile = '';
        let idType = '';
        let runMapControls = true;
        let controlsDir = '';
        let logLevel = '';
        // Process variables
        let existingProfile = null;
        let ovalDefinitions = {};
        let processedXCCDF = {};
        let markDownFile = '';
        let outputProfileFolderPath = '';
        let mappedControls = {};
        const thisLogger = GenerateDelta.logger;
        thisLogger.warn(colors_1.default.green('╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════╗'));
        thisLogger.warn(colors_1.default.green('║ saf generate delta is officially released - report any questions/bugs to https://github.com/mitre/saf/issues ║'));
        thisLogger.warn(colors_1.default.green('╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════╝'));
        (0, cliHelper_1.addToProcessLogData)('==================== Delta Process =====================');
        (0, cliHelper_1.addToProcessLogData)(`Date: ${new Date().toISOString()}`);
        if (flags.interactive) {
            const interactiveFlags = await getFlags();
            // Required flags
            const dataFileContent = interactiveFlags.xccdfTye === 'file'
                ? await this.getXccdfContent('File', interactiveFlags.xccdfXmlFile)
                : interactiveFlags.xccdfUrl ? await this.getXccdfContent('URL', interactiveFlags.xccdfUrl.toString()) : '';
            xccdfXmlFile = dataFileContent ? dataFileContent.xccdfFile : '';
            xccdfContent = dataFileContent ? dataFileContent.xccdfContent : '';
            deltaOutputDir = interactiveFlags.deltaOutputDir;
            // Optional flags
            inspecJsonFile = interactiveFlags.inspecJsonFile;
            ovalXmlFile = interactiveFlags.ovalXmlFile;
            if (interactiveFlags.reportDirectory) {
                reportFile = path_1.default.join(interactiveFlags.reportDirectory, interactiveFlags.reportFileName);
            }
            idType = interactiveFlags.idType;
            runMapControls = interactiveFlags.runMapControls;
            controlsDir = interactiveFlags.controlsDir;
            logLevel = interactiveFlags.logLevel;
        }
        else if (this.requiredFlagsProvided(flags)) {
            // Required flags
            const dataFileContent = flags.xccdfXmlFile
                ? await this.getXccdfContent('File', flags.xccdfXmlFile)
                : flags.xccdfUrl ? await this.getXccdfContent('URL', flags.xccdfUrl.toString()) : '';
            xccdfXmlFile = dataFileContent ? dataFileContent.xccdfFile : '';
            xccdfContent = dataFileContent ? dataFileContent.xccdfContent : '';
            deltaOutputDir = flags.deltaOutputDir;
            // Optional flags
            inspecJsonFile = flags.inspecJsonFile;
            ovalXmlFile = flags.ovalXmlFile;
            reportFile = flags.reportFile;
            idType = flags.idType;
            runMapControls = flags.runMapControls;
            controlsDir = flags.controlsDir;
            logLevel = flags.logLevel;
            // Save the flags to the log object
            (0, cliHelper_1.addToProcessLogData)('Process Flags ===========================================');
            for (const key in flags) {
                if (Object.prototype.hasOwnProperty.call(flags, key)) {
                    (0, cliHelper_1.addToProcessLogData)(key + '=' + flags[key]);
                }
            }
        }
        else {
            return;
        }
        (0, cliHelper_1.addToProcessLogData)('\n');
        GenerateDelta.logger.level = logLevel;
        // -------------------------------------------------------------------------
        // Check if we have an InSpec json file, generate if not provided
        // Process the InSpec json content, convert entries into a Profile object
        // NOTE: If mapping controls to new profile (using the -M) the
        //       existingProfile variable is re-generated as the controls change.
        this.logThis('Processing the InSpec Profiles JSON summary (generate if not provided)...', 'info');
        if (inspecJsonFile) {
            this.logThis(`  Using profile controls summary file: ${(0, global_1.basename)(inspecJsonFile)}`, 'info');
            try {
                if (fs_1.default.lstatSync(inspecJsonFile).isFile()) {
                    this.logThis(`  Loading ${inspecJsonFile} as Profile JSON/Execution JSON`, 'debug');
                    existingProfile = (0, inspec_objects_1.processInSpecProfile)(fs_1.default.readFileSync(inspecJsonFile, 'utf8'));
                    this.logThis(`  Loaded ${inspecJsonFile} as Profile JSON/Execution JSON`, 'debug');
                }
                else {
                    saveLogs(`  ERROR: An InSpec Profile JSON file was not provided ${inspecJsonFile}`);
                    await sleep(2000).then(() => process.exit(1));
                }
            }
            catch (error) {
                if (error.code === 'ENOENT') {
                    saveLogs(`  ERROR: File (entity) not found: ${inspecJsonFile}.\n  Run the --help command for more information on expected input files.`);
                    await sleep(2000).then(() => process.exit(1));
                }
                else {
                    saveLogs(`  ERROR: Unable to process Input execution/profile JSON ${inspecJsonFile}\n  ${error}`);
                    await sleep(2000).then(() => process.exit(1));
                }
            }
        }
        else {
            // Shorten the controls directory to show the 'controls' directory and its parent
            const shortControlsDir = path_1.default.sep + (0, global_1.basename)(path_1.default.dirname(controlsDir))
                + path_1.default.sep + (0, global_1.basename)(controlsDir);
            // Generate the profile json
            try {
                this.logThis(`  Generating the summary file on directory: ${shortControlsDir}`, 'info');
                // Generate the profile controls summary from the `controlsDir` without the trailing "controls" directory
                const inspecJsonFile = (0, child_process_1.execSync)(`cinc-auditor json '${path_1.default.dirname(controlsDir)}'`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 });
                this.logThis('  Generated InSpec Profiles from InSpec JSON summary', 'info');
                existingProfile = (0, inspec_objects_1.processInSpecProfile)(inspecJsonFile);
            }
            catch (error) {
                if (error instanceof Error) {
                    this.logThis(`ERROR: Unable to generate the profile JSON because: ${error.message}`, 'error');
                    throw error;
                }
                // Handle cases where error is not an instance of Error
                // logger.error('ERROR: An unknown error occurred while generating the profile JSON.')
                this.logThis('ERROR: An unknown error occurred while generating the profile JSON.', 'error');
                throw new Error('Unknown error occurred while generating the profile JSON.');
            }
        }
        // -------------------------------------------------------------------------
        // Process the OVAL XML file
        this.logThis('Checking if an OVAL XML file was provided...', 'info');
        try {
            if (ovalXmlFile) {
                if (fs_1.default.lstatSync(ovalXmlFile).isFile()) {
                    const inputFile = fs_1.default.readFileSync(ovalXmlFile, 'utf8');
                    const inputFirstLine = inputFile.split('\n').slice(0, 10).join('').toLowerCase();
                    if (inputFirstLine.includes('oval_definitions')) {
                        this.logThis(`  Loading ${ovalXmlFile} as OVAL`, 'debug');
                        ovalDefinitions = (0, inspec_objects_1.processOVAL)(inputFile);
                        this.logThis(`  Loaded ${ovalXmlFile} as OVAL`, 'debug');
                    }
                    else {
                        saveLogs(`  ERROR: Unable to load OVAL file: ${ovalXmlFile}\n  Ensure it is an OVAL file`);
                        await sleep(2000).then(() => process.exit(1));
                    }
                }
                else {
                    saveLogs(`  ERROR: An OVAL flag option was detected, but no file was provided\n  Ensure ${ovalXmlFile} is an OVAL file`);
                    await sleep(2000).then(() => process.exit(1));
                }
            }
            else {
                this.logThis('  An OVAL XML file was not provided', 'debug');
            }
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                saveLogs(`  ERROR: File (entity) not found: ${ovalXmlFile}.\n  Run the --help command to more information on expected input files.`);
                await sleep(2000).then(() => process.exit(1));
            }
            else {
                saveLogs(`  ERROR: Unable to process the OVAL XML file: ${ovalXmlFile}\n  ${error}`);
                await sleep(2000).then(() => process.exit(1));
            }
        }
        // -------------------------------------------------------------------------
        // Process the fuzzy search logic
        // logger.info('Checking if control mapping is required...')
        this.logThis('Checking if control mapping is required...', 'info');
        try {
            if (runMapControls && controlsDir) {
                this.logThis('  Mapping controls (using fuzzy logic - lower value = best match) from the old profile to the new profile', 'info');
                (0, cliHelper_1.addToProcessLogData)('Mapping controls (using fuzzy logic - lower value = best match) from the old profile to the new profile\n');
                // Process XCCDF of new profile to get controls
                processedXCCDF = (0, inspec_objects_1.processXCCDF)(xccdfContent, false, idType, ovalDefinitions);
                // Create a dictionary mapping new control GIDs to their old control counterparts
                mappedControls = await this.mapControls(existingProfile, processedXCCDF);
                // Iterate through each mapped control
                // key = new control, controls[key] = old control
                const controls = mappedControls;
                // Create a directory where we are storing the newly created mapped controls
                // Do not over right the original controls in the directory (controlsDir)
                const mappedDir = this.createMappedDirectory(controlsDir);
                const shortRunningDir = path_1.default.sep + (0, global_1.basename)(path_1.default.dirname(controlsDir));
                const shortProfileDir = shortRunningDir + path_1.default.sep + (0, global_1.basename)(controlsDir);
                const shortMappedDir = shortRunningDir + path_1.default.sep + (0, global_1.basename)(mappedDir);
                // const controls + path.sep + basename(controlsDir)
                // logger.info('  Updating controls with new control number')
                this.logThis('  Updating controls with new control number', 'info');
                (0, cliHelper_1.printCyan)('Updating Controls ===========================================================================');
                // We need to update controls that a mapping were found executing the mapControls method.
                // This is needed because when we re-generate the new profile summary we need the controls
                // to have the new name/Id. So, for each control, modify the control file in the old controls
                // directory with the proper name and Id, than regenerate json profile summary.
                for (const key in controls) { // skipcq: JS-0051
                    const sourceShortControlFile = path_1.default.join(shortProfileDir, `${controls[key]}.rb`);
                    const mappedShortControlFile = path_1.default.join(shortMappedDir, `${controls[key]}.rb`);
                    const sourceControlFile = path_1.default.join(controlsDir, `${controls[key]}.rb`);
                    const mappedControlFile = path_1.default.join(mappedDir, `${controls[key]}.rb`);
                    (0, cliHelper_1.printYellowGreen)('Mapping (From --> To): ', `${controls[key]} --> ${key}`);
                    let lines;
                    if (fs_1.default.existsSync(sourceControlFile)) {
                        lines = fs_1.default.readFileSync(sourceControlFile, 'utf8').split('\n');
                    }
                    else {
                        (0, cliHelper_1.printBgRedRed)('    File not found at:', ` ${sourceControlFile}\n`);
                        (0, cliHelper_1.printRed)('╔═══════════════════════════════════════════════════════════════════════════════╗');
                        (0, cliHelper_1.printRed)('║ Make sure the appropriate Input execution/profile JSON file is being used (-J)║');
                        (0, cliHelper_1.printRed)('╚═══════════════════════════════════════════════════════════════════════════════╝');
                        return;
                    }
                    // If the key equals the controls[key], the update_controls4delta process was ran
                    // and the controls were properly updated to the proper control number and name.
                    if (controls[key] === key) {
                        // The controls are up to date with the xccdf
                        (0, cliHelper_1.printYellowGreen)('   Control is Current: ', `${sourceShortControlFile}`);
                        // Saved processed control to the 'mapped_controls' directory
                        (0, cliHelper_1.printYellowGreen)('    Processed control: ', `${mappedShortControlFile}\n`);
                        fs_1.default.writeFileSync(mappedControlFile, lines.join('\n'));
                    }
                    else {
                        (0, cliHelper_1.printYellowGreen)('   Processing control: ', `${sourceShortControlFile}`);
                        // Find the line with the control name and replace it with the new control name
                        // single or double quotes are used on this line, check for both
                        // Template literals (`${controls[key]}`) must be used with dynamically created regular expression (RegExp() not / ... /)
                        const controlLineIndex = lines.findIndex(line => new RegExp(`control ['"]${controls[key]}['"] do`).test(line));
                        if (controlLineIndex === -1) {
                            (0, cliHelper_1.printBgRedRed)('    Control not found:', ` ${sourceControlFile}\n`);
                        }
                        else {
                            lines[controlLineIndex] = lines[controlLineIndex].replace(new RegExp(`control ['"]${controls[key]}['"] do`), `control '${key}' do`);
                            // Saved processed control to the 'mapped_controls' directory
                            (0, cliHelper_1.printYellowGreen)('    Processed control: ', `${mappedShortControlFile}`);
                            fs_1.default.writeFileSync(mappedControlFile, lines.join('\n'));
                            // TODO: Maybe copy files from the source directory and rename for duplicates and to preserve source files // skipcq: JS-0099
                            (0, cliHelper_1.printYellowGreen)('  Mapped control file: ', `${sourceShortControlFile} to reference ID ${key}`);
                            (0, cliHelper_1.printYellowBgGreen)('     New control name: ', `${key}.rb\n`);
                        }
                    }
                }
                // Regenerate the profile json summary based on the updated mapped controls
                try {
                    this.logThis(`  Generating the profile json using the new mapped controls on: '${mappedDir}'`, 'info');
                    // Get the directory name without the trailing "controls" directory
                    // Here we are using the newly updated (mapped) controls
                    // const profileDir = path.dirname(controlsDir)
                    const inspecJsonFileNew = (0, child_process_1.execSync)(`cinc-auditor json '${path_1.default.dirname(mappedDir)}'`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 });
                    // const inspecJsonFileNew = execSync(`cinc-auditor json '${mappedDir}'`, {encoding: 'utf8', maxBuffer: 50 * 1024 * 1024})
                    // Replace existing profile (inputted JSON of source profile to be mapped)
                    // Allow delta to take care of the rest
                    existingProfile = (0, inspec_objects_1.processInSpecProfile)(inspecJsonFileNew);
                }
                catch (error) {
                    saveLogs(`  ERROR: Unable to generate the profile json summary for the updated controls.  \n ${(0, global_1.getErrorMessage)(error)}`);
                    await sleep(2000).then(() => process.exit(1));
                }
            }
        }
        catch (error) {
            saveLogs('  ERROR: Could not process fuzzy search logic. Check the --help command for more '
                + 'information on the deltaOutputDir(-o) or controlsDir(-c) flags.\n'
                + `  ${(0, global_1.getErrorMessage)(error)}`);
            await sleep(2000).then(() => process.exit(1));
        }
        // -------------------------------------------------------------------------
        // Process the output folder
        // logger.info('Checking if provided output directory exists (create it if does not, clear if exists)...')
        this.logThis('Checking if provided output directory exists (create it if does not, clear if exists)...', 'info');
        try {
            // Create the folder if it doesn't exist
            if (!fs_1.default.existsSync(deltaOutputDir)) {
                fs_1.default.mkdirSync(path_1.default.join(deltaOutputDir), { recursive: true });
            }
            if ((0, global_1.basename)(deltaOutputDir) === 'controls') {
                this.logThis(`  Deleting existing profile folder ${deltaOutputDir}`, 'debug');
                fs_extra_1.default.emptyDirSync(deltaOutputDir);
                outputProfileFolderPath = path_1.default.dirname(deltaOutputDir);
            }
            else {
                const controlDir = path_1.default.join(deltaOutputDir, 'controls');
                if (fs_1.default.existsSync(controlDir)) {
                    this.logThis(`  Deleting content within existing controls folder within the profile folder ${deltaOutputDir}`, 'debug');
                    fs_extra_1.default.emptyDirSync(controlDir);
                }
                else {
                    fs_extra_1.default.mkdirSync(controlDir);
                }
                outputProfileFolderPath = deltaOutputDir;
            }
        }
        catch (error) {
            this.logThis(`  ERROR: Could not process delta output directory: ${deltaOutputDir}. Check the --help command for more information on the -o flag.`, 'error');
            this.logThis(`  ${error}`, 'error');
            saveLogs(`  ERROR: Unable to process delta output directory: ${deltaOutputDir}\n  Check the --help command for more information on the -o flag.\n  ${error}`);
            await sleep(2000).then(() => process.exit(1));
        }
        // -------------------------------------------------------------------------
        // Set the report markdown file location
        // logger.info('Checking if an output markdown report was requested...')
        this.logThis('Checking if an output markdown report was requested...', 'info');
        if (reportFile) {
            if (fs_1.default.existsSync(reportFile) && fs_1.default.lstatSync(reportFile).isDirectory()) {
                // Not a file - directory provided
                markDownFile = path_1.default.join(reportFile, 'delta.md');
            }
            else if (fs_1.default.existsSync(reportFile) && fs_1.default.lstatSync(reportFile).isFile()) {
                // File name provided and exists - will be overwritten
                markDownFile = reportFile;
            }
            else if (path_1.default.extname(reportFile) === '.md') {
                markDownFile = reportFile;
            }
            else {
                markDownFile = path_1.default.join(outputProfileFolderPath, 'delta.md');
            }
        }
        else {
            this.logThis('  An output markdown reports was not requested', 'debug');
        }
        // -------------------------------------------------------------------------
        // If all variables have been satisfied, we can generate the delta
        // If the -M was used the delta is generated based on the mapped controls
        // NOTE: If the -M was not used and the current control numbers are different
        //       (like V to SV) there will be not matching between current controls
        //       (existingProfile.controls) and updatedResult variable containing
        //       the returned values from the updateProfileUsingXCCDF(...) process.
        //       For this UC, it is best to run the update_controls4delta where the
        //       controls are update with values provided by the xccdf benchmark.
        this.logThis('Executing the Delta process...', 'info');
        if (existingProfile && xccdfContent) {
            let updatedResult;
            this.logThis(`  Processing XCCDF Benchmark file: ${xccdfXmlFile} using ${idType} id.`, 'debug');
            const idTypes = ['rule', 'group', 'cis', 'version'];
            if (idTypes.includes(idType)) {
                updatedResult = (0, inspec_objects_1.updateProfileUsingXCCDF)(existingProfile, xccdfContent, idType, thisLogger, ovalDefinitions);
            }
            else {
                saveLogs(`  ERROR: Invalid ID Type: ${idType}. Check the --help command for the available ID Type options.`);
                await sleep(2000).then(() => process.exit(1));
            }
            this.logThis('  Computed the delta between the existing profile and updated benchmark.', 'debug');
            if (updatedResult) {
                updatedResult.profile.controls.forEach((control) => {
                    const controls = existingProfile.controls;
                    let index = -1;
                    for (const i in controls) { // skipcq: JS-0051
                        const controlLine = controls[i].code.split('\n')[0];
                        // NOTE: The control.id can be in the form of V-123456 or SV-123456
                        //       check the entire value or just the numeric value for a match
                        if (controlLine.includes(control.id) || controlLine.includes(control.id.split('-')[1])) {
                            index = Number.parseInt(i, 10);
                            break;
                        }
                    }
                    // Call the .toRuby verbose if the log level is debug or verbose
                    const processLogLevel = Boolean(logLevel === 'debug' || logLevel === 'verbose');
                    if (index >= 0) {
                        // We found a mapping for this control (aka index >=0)
                        // The new control (control) has the new metadata but doesn't have
                        // the describe block (code). Using the updateControl method with the new
                        // control so we can get the code with the new metadata.
                        // NOTE: Can use the getExistingDescribeFromControl(existingProfile.controls[index])
                        //       method from inspect-objects
                        const newControl = (0, inspec_objects_1.updateControl)(existingProfile.controls[index], control, thisLogger);
                        this.logThis(`Writing updated control with code block for: ${control.id}.`, 'info');
                        fs_1.default.writeFileSync(path_1.default.join(outputProfileFolderPath, 'controls', `${(0, global_1.basename)(control.id)}.rb`), newControl.toRuby(processLogLevel));
                    }
                    else {
                        // We didn't find a mapping for this control - Old style of updating controls
                        this.logThis(`Writing new control without code block for: ${control.id}.`, 'info');
                        fs_1.default.writeFileSync(path_1.default.join(outputProfileFolderPath, 'controls', `${(0, global_1.basename)(control.id)}.rb`), control.toRuby(processLogLevel));
                    }
                });
                this.logThis(`  Writing delta file for ${existingProfile.title}`, 'info');
                fs_1.default.writeFileSync(path_1.default.join(outputProfileFolderPath, 'delta.json'), JSON.stringify(updatedResult.diff, null, 2));
                if (reportFile) {
                    // logger.debug('  Writing report markdown file')
                    this.logThis('  Writing report markdown file', 'debug');
                    if (runMapControls) {
                        const totalMappedControls = Object.keys(mappedControls).length; // skipcq: JS-0339
                        const reportData = '## Map Controls\n'
                            + JSON.stringify(mappedControls, null, 2) // skipcq:  JS-0339
                            + `\nTotal Mapped Controls: ${Object.keys(mappedControls).length}\n\n` // skipcq:  JS-0339
                            + `Total Controls Available for Delta: ${GenerateDelta.oldControlsLength}\n`
                            + `     Total Controls Found on XCCDF: ${GenerateDelta.newControlsLength}\n`
                            + `                    Match Controls: ${GenerateDelta.match}\n`
                            + `        Possible Mismatch Controls: ${GenerateDelta.posMisMatch}\n`
                            + `          Duplicate Match Controls: ${GenerateDelta.dupMatch}\n`
                            + `                 No Match Controls: ${GenerateDelta.noMatch}\n`
                            + `                New XCDDF Controls: ${GenerateDelta.newXccdfControl}\n\n`
                            + 'Statistics Validation ------------------------------------------\n'
                            + `Match + Mismatch = Total Mapped Controls: ${this.getMappedStatisticsValidation(totalMappedControls, 'totalMapped')}\n`
                            + `  Total Processed = Total XCCDF Controls: ${this.getMappedStatisticsValidation(totalMappedControls, 'totalProcessed')}\n\n`
                            + updatedResult.markdown;
                        fs_1.default.writeFileSync(markDownFile, reportData);
                    }
                    else {
                        fs_1.default.writeFileSync(markDownFile, updatedResult.markdown);
                    }
                }
                // Print the process output report to current directory
                (0, cliHelper_1.addToProcessLogData)('Update Results ===========================================================================\n');
                (0, cliHelper_1.addToProcessLogData)(updatedResult.markdown);
                await sleep(2000).then(() => (0, cliHelper_1.printGreen)('\nDelta Process completed successfully\n'));
                (0, cliHelper_1.saveProcessLogData)();
            }
            else {
                (0, cliHelper_1.printRed)('\nDelta Process failed\n');
                saveLogs(`  ERROR: The updateProfileUsingXCCDF process failed to provide updated profiles, received: ${updatedResult}.`);
                await sleep(2000).then(() => process.exit(1));
            }
        }
        else {
            if (!existingProfile) {
                this.logThis('  ERROR: Could not generate delta because the existingProfile variable was not satisfied.', 'error');
                (0, cliHelper_1.printRed)('\nDelta Process failed\n');
            }
            if (!xccdfContent) {
                this.logThis('  ERROR: Could not generate delta because the xccdfContent variable was not satisfied.', 'error');
                (0, cliHelper_1.printRed)('\nDelta Process failed\n');
            }
        }
    }
    // Maps controls from an old profile to a new profile by updating the control IDs
    // based on matching SRG IDs and titles.
    //
    // This method uses Fuse.js for fuzzy searching, a technique of finding
    // strings that are approximately equal to a given pattern (rather than
    // exactly) to find matching controls in the new profile based on the
    // SRG ID (`tags.gtitle`). If a match is found and the titles match, the old
    // control's ID is updated to the new control's ID.
    //
    // Example usage:
    // ```typescript
    // const oldProfile = processInSpecProfile(fs.readFileSync(inspecJsonFile, 'utf8'))
    // const newProfile = processXCCDF(xccdfContent, false, flags.idType as 'cis' | 'version' | 'rule' | 'group', ovalDefinitions)
    // const generateDelta = new GenerateDelta()
    // generateDelta.mapControls(oldProfile, newProfile);
    // ```
    //
    // @param oldProfile - The profile containing the old controls.
    // @param newProfile - The profile containing the new controls.
    async mapControls(oldProfile, newProfile) {
        /*
        If a control isn't found to have a match at all, then req is missing or has been dropped
        Delta *should* be removing it automatically
        */
        const oldControls = oldProfile.controls;
        const newControls = newProfile.controls;
        GenerateDelta.oldControlsLength = oldControls.length;
        GenerateDelta.newControlsLength = newControls.length;
        const fuseOptions = {
            // isCaseSensitive: false,
            includeScore: true,
            shouldSort: true,
            includeMatches: true,
            // findAllMatches: false,
            // minMatchCharLength: 1,
            // location: 0,
            // A threshold of 0.0 requires a perfect match (of both letters and location),
            //   threshold of 1.0 would match anything
            threshold: 0.4,
            // distance: 100,
            // useExtendedSearch: false,
            // text / character movements are inherent when text is changed
            ignoreLocation: true,
            // puts weight on length of field, skews results since often text is expanded in revisions
            ignoreFieldNorm: true,
            // fieldNormWeight: 1,
            keys: ['title'],
        };
        const controlMappings = {};
        (0, cliHelper_1.printCyan)('Mapping Process ===========================================================================');
        // Create fuse object for searching through matchList
        const fuse = await new fuse_js_1.default(oldControls, fuseOptions);
        // Map that holds processed controls and their scores
        // Need to check if a control is process multiple-times and determine which
        // control has the lower score
        const controlIdToScoreMap = new Map();
        for (const newControl of newControls) {
            // Ensure the newControl.id is a string and has no leading or trailing slashes
            const newControlId = (0, global_1.basename)(newControl.id);
            // Check for existence of title, remove non-displayed characters
            // TODO: Determine whether removing symbols other than non-displayed characters is helpful // skipcq: JS-0099
            // words separated by newlines don't have spaces between them
            if (newControl.title) {
                // Regex: [\w\s]     -> match word characters and whitespace
                //        [\r\t\f\v] -> carriage return, tab, form feed and vertical tab
                const result = fuse.search(newControl.title.replaceAll(/[^\w\s]|[\r\t\f\v]/g, '').replaceAll('\n', ''));
                if ((0, lodash_1.isEmpty)(result)) {
                    (0, cliHelper_1.printYellowGreen)('     New XCCDF Control:', ` ${newControlId}`);
                    (0, cliHelper_1.printBgYellow)('* No Mapping Provided *\n');
                    GenerateDelta.newXccdfControl++;
                    continue;
                }
                (0, cliHelper_1.printYellowBgGreen)('Processing New Control: ', `${newControlId}`);
                (0, cliHelper_1.printYellowBgGreen)('     New Control Title: ', `${this.updateTitle(newControl.title)}`);
                if (result[0] && result[0].score && result[0].score < 0.3) { // skipcq: JS-W1044
                    if (controlIdToScoreMap.has(result[0].item.id)) {
                        const score = controlIdToScoreMap.get(result[0].item.id);
                        if (result[0].score < score) {
                            controlIdToScoreMap.set(result[0].item.id, result[0].score);
                        }
                        else {
                            (0, cliHelper_1.printBgMagentaRed)('     Old Control Title:', ` ${this.updateTitle(result[0].item.title)}`);
                            (0, cliHelper_1.printBgMagentaRed)('       Duplicate Match:', ` ${result[0].item.id} --> ${newControlId}`);
                            (0, cliHelper_1.printBgMagentaRed)('        Matching Score:', ` ${result[0].score}\n`);
                            GenerateDelta.dupMatch++;
                            continue;
                        }
                    }
                    if (typeof newControlId === 'string'
                        && typeof result[0].item.id === 'string') {
                        // Check non displayed characters of title
                        (0, cliHelper_1.printYellowGreen)('     Old Control Title: ', `${this.updateTitle(result[0].item.title)}`);
                        // NOTE: We determined that 0.1 needs to be reviewed due to possible
                        // words exchange that could alter the entire meaning of the title.
                        if (result[0].score > 0.1) {
                            // TODO: modify output report or logger to show potential mismatches // skipcq: JS-0099
                            // alternatively: add a match decision feature for high-scoring results
                            (0, cliHelper_1.printBgRed)('** Potential Mismatch **');
                            GenerateDelta.posMisMatch++;
                        }
                        else {
                            GenerateDelta.match++;
                        }
                        (0, cliHelper_1.printYellowGreen)('  Best Match Candidate: ', `${result[0].item.id} --> ${newControlId}`);
                        (0, cliHelper_1.printYellowGreen)('        Matching Score: ', `${result[0].score}\n`);
                        // Check if we have added an entry for the old control being processed
                        // The result[0].item.id is the old control id
                        for (const key in controlMappings) {
                            if (controlMappings[key] === result[0].item.id) {
                                delete controlMappings[key]; // skipcq: JS-0320
                                // Lets now check if this entry was previously processed
                                if (controlIdToScoreMap.has(result[0].item.id)) {
                                    const score = controlIdToScoreMap.get(result[0].item.id);
                                    if (score > 0.1) {
                                        GenerateDelta.posMisMatch--;
                                    }
                                    else {
                                        GenerateDelta.match--;
                                    }
                                    GenerateDelta.noMatch++;
                                }
                                break;
                            }
                        }
                        controlMappings[newControlId] = result[0].item.id;
                        controlIdToScoreMap.set(result[0].item.id, result[0].score);
                    }
                }
                else {
                    (0, cliHelper_1.printBgRedRed)('     Old Control Title:', ` ${this.updateTitle(result[0].item.title)}`);
                    (0, cliHelper_1.printBgRedRed)('    No Match Found for:', ` ${result[0].item.id} --> ${newControlId}`);
                    (0, cliHelper_1.printBgRedRed)('        Matching Score:', ` ${result[0].score} \n`);
                    GenerateDelta.noMatch++;
                }
            }
        }
        (0, cliHelper_1.printCyan)('Mapping Results ===========================================================================');
        (0, cliHelper_1.printYellow)('\tOld Control -> New Control');
        for (const [key, value] of Object.entries(controlMappings)) {
            (0, cliHelper_1.printGreen)(`\t   ${value} -> ${key}`);
        }
        const totalMappedControls = Object.keys(controlMappings).length;
        (0, cliHelper_1.printYellowGreen)('Total Mapped Controls: ', `${totalMappedControls}\n`);
        (0, cliHelper_1.printCyan)('Control Counts ===========================');
        (0, cliHelper_1.printYellowGreen)('Total Controls Available for Delta: ', `${GenerateDelta.oldControlsLength}`);
        (0, cliHelper_1.printYellowGreen)('     Total Controls Found on XCCDF: ', `${GenerateDelta.newControlsLength}\n`);
        (0, cliHelper_1.printCyan)('Match Statistics =========================');
        (0, cliHelper_1.printYellowGreen)('                    Match Controls: ', `${GenerateDelta.match}`);
        (0, cliHelper_1.printYellowGreen)('        Possible Mismatch Controls: ', `${GenerateDelta.posMisMatch}`);
        (0, cliHelper_1.printYellowGreen)('          Duplicate Match Controls: ', `${GenerateDelta.dupMatch}`);
        (0, cliHelper_1.printYellowGreen)('                 No Match Controls: ', `${GenerateDelta.noMatch}`);
        (0, cliHelper_1.printYellowGreen)('                New XCDDF Controls: ', `${GenerateDelta.newXccdfControl}\n`);
        (0, cliHelper_1.printCyan)('Statistics Validation =============================================');
        (0, cliHelper_1.printYellowGreen)('Match + Mismatch = Total Mapped Controls: ', `${this.getMappedStatisticsValidation(totalMappedControls, 'totalMapped')}`);
        (0, cliHelper_1.printYellowGreen)('  Total Processed = Total XCCDF Controls: ', `${this.getMappedStatisticsValidation(totalMappedControls, 'totalProcessed')}\n\n`);
        return controlMappings;
    }
    getMappedStatisticsValidation(totalMappedControls, statValidation) {
        let evalStats = '';
        const match = GenerateDelta.match;
        const misMatch = GenerateDelta.posMisMatch;
        const statMach = ((match + misMatch) === totalMappedControls);
        const dupMatch = GenerateDelta.dupMatch;
        const noMatch = GenerateDelta.noMatch;
        const newXccdfControl = GenerateDelta.newXccdfControl;
        const statTotalMatch = ((totalMappedControls + dupMatch + noMatch + newXccdfControl) === GenerateDelta.newControlsLength);
        evalStats = statValidation === 'totalMapped'
            ? `(${match}+${misMatch}=${totalMappedControls}) ${statMach}`
            : `(${match}+${misMatch}+${dupMatch}+${noMatch}+${newXccdfControl}=${GenerateDelta.newControlsLength}) ${statTotalMatch}`;
        return evalStats;
    }
    requiredFlagsProvided(flags) {
        let missingFlags = false;
        let strMsg = 'Warning: The following errors occurred:\n';
        // If we don't have a Controls Profiles summary file or are conducting
        // a fuzzy matching we need the controls directory
        if (!flags.inspecJsonFile || flags.runMapControls) {
            // Check if the directory exists
            if (fs_1.default.existsSync(flags.controlsDir)) {
                const files = fs_1.default.readdirSync(flags.controlsDir);
                // Filter the files to check if any of them have the .rb extension
                const rbFiles = files.filter(file => path_1.default.extname(file) === '.rb');
                if (rbFiles.length) {
                    missingFlags = false;
                }
                else {
                    strMsg += colors_1.default.dim(`  No Controls found in directory: ${flags.controlsDir}\n`);
                    missingFlags = true;
                }
            }
            else {
                strMsg += colors_1.default.dim(`  Profile Controls directory does not exist: ${flags.controlsDir}\n`);
                missingFlags = true;
            }
        }
        if (!flags.deltaOutputDir) {
            strMsg += colors_1.default.dim('  Missing required flag deltaOutputDir\n');
            missingFlags = true;
        }
        if (missingFlags) {
            strMsg += 'See more help with -h or --help';
            this.warn(strMsg);
        }
        return !missingFlags;
    }
    /**
     * Retrieves the content of an XCCDF file or extracts it from a URL or zip package.
     *
     * @param xccdfType - The type of the XCCDF input, either 'File' or 'URL'.
     * @param xccdfInput - The path to the XCCDF file or the URL containing the XCCDF content.
     * @returns A promise that resolves to an object containing:
     *          - `xccdfFile`: The name of the XCCDF file.
     *          - `xccdfContent`: The content of the XCCDF file as a string.
     *
     * @throws Will terminate the process if the input file or URL is invalid or processing fails.
     */
    async getXccdfContent(xccdfType, xccdfInput) {
        let xccdfFile = '';
        let xccdfContent = '';
        if (xccdfType === 'File') {
            xccdfFile = (0, global_1.basename)(xccdfInput);
            this.logThis(`Verifying that the XCCDF file is valid: ${xccdfFile}...`, 'info');
            if (isXccdfFile(xccdfInput)) {
                // Did we get a .xml file or a zip package
                if (path_1.default.extname(xccdfInput) === '.xml') {
                    xccdfContent = fs_1.default.readFileSync(xccdfInput, 'utf8');
                    this.logThis(`  Retrieved XCCDF from zip package: ${xccdfFile}`, 'debug');
                }
                else {
                    try {
                        const fileNameToExtract = '-xccdf.xml';
                        const result = (0, global_1.extractFileFromZip)(xccdfInput, fileNameToExtract);
                        const fileBuffer = result[0];
                        xccdfFile = result[1].split('/')[1];
                        if (fileBuffer) {
                            this.logThis(`  Retrieved XCCDF from zip package: ${xccdfFile}`, 'debug');
                            xccdfContent = fileBuffer.toString();
                        }
                    }
                    catch (error) {
                        saveLogs(`Processing File failed.', ${error}`);
                        await sleep(2000).then(() => process.exit(1));
                    }
                }
            }
            else {
                saveLogs('Processing XCCDF JSON Summary file failed.');
                await sleep(2000).then(() => process.exit(1));
            }
        }
        else {
            this.logThis(`Verifying that the URL contains a valid XCCDF: ${xccdfInput}...`, 'info');
            const tmpobj = tmp_1.default.dirSync({ unsafeCleanup: true });
            if (xccdfInput === undefined) {
                saveLogs('URL flag is undefined or invalid.');
                await sleep(2000).then(() => process.exit(1));
            }
            const url = xccdfInput;
            await (async () => {
                const zipFile = url.split('/').pop(); // Extracts the last segment
                if (!zipFile) {
                    throw new Error('Failed to extract zip file name from URL');
                }
                const zipFilePath = path_1.default.join(tmpobj.name, zipFile);
                try {
                    await (0, global_1.downloadFile)(url, zipFilePath);
                    this.logThis('  Valid XCCDF URL provided', 'debug');
                    const fileNameToExtract = '-xccdf.xml';
                    const result = (0, global_1.extractFileFromZip)(zipFilePath, fileNameToExtract);
                    const fileBuffer = result[0];
                    xccdfFile = result[1].split('/')[1];
                    if (fileBuffer) {
                        this.logThis(`  Extracted XCCDF from: ${xccdfFile}`, 'debug');
                        xccdfContent = fileBuffer.toString();
                    }
                }
                catch (error) {
                    saveLogs(`Processing URL failed.', ${error}`);
                    await sleep(2000).then(() => process.exit(1));
                }
            })();
            tmp_1.default.setGracefulCleanup();
        }
        return { xccdfFile, xccdfContent };
    }
    updateTitle(str) {
        return str
            .replaceAll('\n', String.raw ``)
            .replaceAll('\r', String.raw ``)
            .replaceAll('\t', String.raw ``)
            .replaceAll('\f', String.raw ``)
            .replaceAll('\v', String.raw ``);
    }
    /**
     * Creates the mapped directory for controls within the specified directory path.
     *
     * This method performs the following steps:
     * 1. Determines the destination file path based on the provided `controlsDir`.
     * 2. Constructs the path for the mapped directory (`mapped_controls/controls`).
     * 3. Deletes the mapped directory if it already exists.
     * 4. Creates the mapped directory recursively.
     * 5. Copies the `inspec.yml` file from the destination directory to the parent
     *    of the mapped directory to ensure proper generation of the profile controls summary.
     *
     * @param controlsDir - The path to the directory containing the controls.
     * @returns The path to the newly created mapped directory.
     * @throws An error if any file system operation fails, with the error message extracted using `getErrorMessage`.
     */
    createMappedDirectory(controlsDir) {
        try {
            const destFilePath = path_1.default.dirname(controlsDir);
            const mappedDir = path_1.default.join(destFilePath, 'mapped_controls', 'controls');
            if (fs_1.default.existsSync(mappedDir)) {
                fs_1.default.rmSync(mappedDir, { recursive: true, force: true });
            }
            fs_1.default.mkdirSync(mappedDir, { recursive: true });
            // Copy the profile inspec.yml to the mapped directory to generate the profile controls summary properly
            (0, fs_1.copyFileSync)(path_1.default.join(destFilePath, 'inspec.yml'), path_1.default.join(path_1.default.dirname(mappedDir), 'inspec.yml'));
            return mappedDir;
        }
        catch (error) {
            throw new Error((0, global_1.getErrorMessage)(error));
        }
    }
    logThis(logMsg, logLevel) {
        switch (logLevel) {
            case 'info': {
                GenerateDelta.logger.info(logMsg);
                (0, cliHelper_1.addToProcessLogData)(logMsg);
                break;
            }
            case 'debug': {
                GenerateDelta.logger.debug(logMsg);
                (0, cliHelper_1.addToProcessLogData)(logMsg);
                break;
            }
            case 'error': {
                GenerateDelta.logger.error(logMsg);
                (0, cliHelper_1.addToProcessLogData)(logMsg);
                break;
            }
            default: {
                GenerateDelta.logger.warn(logMsg);
                (0, cliHelper_1.addToProcessLogData)(logMsg);
                break;
            }
        }
    }
}
exports.default = GenerateDelta;
/**
 * Asynchronously prompts the user for various inputs and selections to configure
 * the delta process for updating profile controls. This function dynamically imports
 * required modules, interacts with the user through a series of prompts, and collects
 * the necessary flags and options for the process.
 *
 * @async
 * @function
 * @returns {Promise<any>} A promise that resolves to an object containing the user's
 * selections and inputs, including required and optional flags for the delta process.
 *
 * The returned object includes:
 * - `xccdfTye`: The type of XCCDF source ('file' or 'url').
 * - `xccdfXmlFile` or `xccdfUrl`: The selected XCCDF file or URL.
 * - `inspecJsonFile`: The Profile Controls summary file or an indication that it is auto-generated.
 * - `controlsDir`: The directory containing the profile controls (if applicable).
 * - `runMapControls`: A boolean indicating whether fuzzy logic is used.
 * - `deltaOutputDir`: The directory for saving the updated profile controls.
 * - `ovalXmlFile`: The OVAL XML file (if included).
 * - `generateReport`: A boolean indicating whether a markdown report is generated.
 * - `reportDirectory` and `reportFileName`: The directory and filename for the markdown report (if applicable).
 * - `idType`: The selected Control ID Type for processing controls.
 * - `logLevel`: The selected log level for the process.
 *
 * @remarks
 * - The function uses `inquirer` for interactive prompts and dynamically imports
 *   `inquirer-file-selector` and `chalk` for enhanced user experience.
 * - It adjusts the `defaultMaxListeners` of the `EventEmitter` to accommodate
 *   the number of listeners required by the prompts.
 * - The function logs user selections to a process log for debugging or auditing purposes.
 *
 * @example
 * const flags = await getFlags();
 * console.log(flags);
 */
async function getFlags() {
    // The default max listeners is set to 10. The inquire checkbox sets a
    // listener for each entry it displays, we are providing 16 entries,
    // does using 16 listeners. Need to increase the defaultMaxListeners.
    events_1.EventEmitter.defaultMaxListeners = 20;
    // Dynamically import inquirer-file-selector and chalk
    // Once we move the SAF CLI from a CommonJS to an ES modules we can use the regular import
    const { default: fileSelector } = await import('inquirer-file-selector');
    const { default: chalk } = await import('chalk');
    const fileSelectorTheme = {
        style: {
            file: (text) => chalk.green(text),
            currentDir: (text) => chalk.blueBright(text),
            help: (text) => chalk.yellow(text),
        },
    };
    // Variable used to store the prompts (question and answers)
    const interactiveValues = {};
    (0, cliHelper_1.printYellow)('Provide the necessary information:');
    (0, cliHelper_1.printGreen)('  Required flag - The XCCDF XML file or URL containing the new guidance - in the form of .xml file');
    (0, cliHelper_1.printGreen)('  Required flag - Controls directory (path to the profile controls to apply the delta process)');
    (0, cliHelper_1.printGreen)('  Required flag - The output folder for the updated profile (will contain the controls that delta was applied too)');
    (0, cliHelper_1.printMagenta)('  Optional flag - InSpec Profiles JSON summary file (JSON) - auto-generated if not provided');
    (0, cliHelper_1.printMagenta)('  Optional flag - The OVAL XML file containing definitions used in the new guidance - in the form of .xml file');
    (0, cliHelper_1.printMagenta)('  Optional flag - Output markdown report file - must have an extension of .md');
    (0, cliHelper_1.printMagenta)('  Optional flag - Control ID Types: [\'rule\', \'group\', \'cis\', \'version\']');
    (0, cliHelper_1.printMagenta)('  Optional flag - Run the approximate string matching process');
    (0, cliHelper_1.printMagenta)('  Optional flag - The InSpec profile directory containing the controls being updated (controls Delta is processing)\n');
    (0, cliHelper_1.addToProcessLogData)('Process Flags ===========================================');
    // Check what XCCDF to use (File or URL)
    const xccdfType = await (0, prompts_1.select)({
        message: 'Select from where to retrieve the XCCDF',
        choices: [
            { name: 'File', value: 'file', description: 'File (.xml) containing the XCCDF benchmark' },
            { name: 'URL', value: 'url', description: 'URL pointing to a package (.zip) containing the XCCDF benchmark' },
        ],
    });
    // Required Flags
    if (xccdfType === 'file') {
        const xccdfXmlFile = await fileSelector({
            message: 'Select the XCCDF benchmark file (.xml) containing the new guidance:',
            pageSize: 15,
            loop: true,
            type: 'file',
            allowCancel: true,
            emptyText: 'Directory is empty',
            showExcluded: false,
            filter: file => file.isDirectory() || file.name.endsWith('.xml'),
            theme: fileSelectorTheme,
        });
        (0, cliHelper_1.addToProcessLogData)('xccdfXmlFile=' + xccdfXmlFile);
        interactiveValues.xccdfTye = 'file';
        interactiveValues.ovalXmlFile = xccdfXmlFile;
    }
    else {
        const xccdfUrl = await (0, prompts_1.input)({
            message: 'Provide an URL pointing to the XCCDF benchmark (.zip) package:',
            validate(input) {
                if (/^(https?|ftp):\/\/[^\s/$.?#].[^\s]*\.zip$/i.test(input)) { // skipcq: JS-0113
                    return true;
                }
                return 'Please enter a valid URL that ends with .zip';
            },
        });
        (0, cliHelper_1.addToProcessLogData)('xccdfUrl=' + xccdfUrl);
        interactiveValues.xccdfTye = 'url';
        interactiveValues.xccdfUrl = xccdfUrl;
    }
    // Check if Profile Controls summary is provided or auto-generate
    const generateSummaryFile = await (0, prompts_1.select)({
        message: 'Auto generate the Profile Controls summary?',
        choices: [
            { name: 'Yes', value: 'yes', description: 'Must provide the directory containing the profile controls' },
            { name: 'No', value: 'no', description: 'Must provide the Profile Controls summary (.json) file' },
        ],
    });
    if (generateSummaryFile === 'no') {
        const inspecJsonFile = await fileSelector({
            message: 'Select the Profile Controls summary (.json) file:',
            pageSize: 15,
            loop: true,
            type: 'file',
            allowCancel: true,
            emptyText: 'Directory is empty',
            showExcluded: false,
            filter: file => file.isDirectory() || file.name.endsWith('.json'),
            theme: fileSelectorTheme,
        });
        (0, cliHelper_1.addToProcessLogData)('inspecJsonFile=' + inspecJsonFile);
        interactiveValues.inspecJsonFile = inspecJsonFile;
    }
    else {
        (0, cliHelper_1.addToProcessLogData)('inspecJsonFile=auto-generated');
        interactiveValues.inspecJsonFile = '';
    }
    // If we are using fuzzy logic or profile controls summary was not provided we need the controls directory
    const useFuzzyLogic = await (0, prompts_1.confirm)({ message: 'Run the approximate string matching process (fuzzy logic)?' });
    if (useFuzzyLogic || generateSummaryFile === 'yes') {
        const controlsDir = await fileSelector({
            message: 'Select the Profile Controls directory (controls Delta is processing):',
            pageSize: 15,
            loop: true,
            type: 'directory',
            allowCancel: true,
            emptyText: 'Directory is empty',
            theme: fileSelectorTheme,
        });
        (0, cliHelper_1.addToProcessLogData)('runMapControls=true');
        interactiveValues.controlsDir = controlsDir;
        interactiveValues.runMapControls = useFuzzyLogic;
    }
    else {
        (0, cliHelper_1.addToProcessLogData)('runMapControls=false');
        interactiveValues.runMapControls = false;
    }
    // Get the directory where to save the delta controls
    const deltaOutputDir = await fileSelector({
        message: 'Select the output folder for the updated profile control(s)',
        pageSize: 15,
        loop: true,
        type: 'directory',
        allowCancel: true,
        emptyText: 'Directory is empty',
        theme: fileSelectorTheme,
    });
    (0, cliHelper_1.addToProcessLogData)('deltaOutputDir=' + deltaOutputDir);
    interactiveValues.deltaOutputDir = deltaOutputDir;
    // Optional - OVAL file Flag
    const useOvalFile = await (0, prompts_1.confirm)({ message: 'Include an OVAL XML file?' });
    if (useOvalFile) {
        const ovalXmlFile = await fileSelector({
            message: 'Select the OVAL XML file containing definitions used in the new guidance - in the form of .xml file:',
            pageSize: 15,
            loop: true,
            type: 'file',
            allowCancel: true,
            emptyText: 'Directory is empty',
            showExcluded: false,
            filter: file => file.isDirectory() || file.name.endsWith('.xml'),
            theme: fileSelectorTheme,
        });
        (0, cliHelper_1.addToProcessLogData)('useOvalFile=true');
        interactiveValues.ovalXmlFile = ovalXmlFile;
    }
    else {
        (0, cliHelper_1.addToProcessLogData)('useOvalFile=false');
    }
    // Optional - Generate markdown report from Inspect-objects process
    const generateReport = await (0, prompts_1.confirm)({ message: 'Generate the Inspect-Object process markdown report file?' });
    if (generateReport) {
        const answers = {
            reportDirectory: await fileSelector({
                message: 'Select the output directory for the markdown report file:',
                pageSize: 15,
                loop: true,
                type: 'directory',
                allowCancel: true,
                emptyText: 'Directory is empty',
                theme: fileSelectorTheme,
            }),
            reportFileName: await (0, prompts_1.input)({
                message: 'Specify the output report filename (must have an extension of .md):',
                default: 'deltaProcessReport.md',
            }),
        };
        (0, cliHelper_1.addToProcessLogData)('generateReport=true');
        for (const tagName in answers) {
            if (Object.prototype.hasOwnProperty.call(answers, tagName)) {
                const answerValue = lodash_1.default.get(answers, tagName);
                if (answerValue !== null) {
                    (0, cliHelper_1.addToProcessLogData)(tagName + '=' + answerValue);
                    interactiveValues[tagName] = answerValue;
                }
            }
        }
    }
    else {
        (0, cliHelper_1.addToProcessLogData)('generateReport=false');
    }
    // Optional - Select what group Id to process the controls and Log Level
    const answers = {
        idType: await (0, prompts_1.select)({
            message: 'Select the Control ID Type used to process the controls:',
            default: 'rule',
            choices: [
                { name: 'rule', value: 'rule' },
                { name: 'group', value: 'group' },
                { name: 'cis', value: 'cis' },
                { name: 'version', value: 'version' },
            ],
        }),
        logLevel: await (0, prompts_1.select)({
            message: 'Select the log level:',
            default: 'info',
            choices: [
                { name: 'info', value: 'info' },
                { name: 'warn', value: 'warn' },
                { name: 'debug', value: 'debug' },
                { name: 'verbose', value: 'verbose' },
            ],
        }),
    };
    for (const tagName in answers) {
        if (Object.prototype.hasOwnProperty.call(answers, tagName)) {
            const answerValue = lodash_1.default.get(answers, tagName);
            if (answerValue !== null) {
                (0, cliHelper_1.addToProcessLogData)(tagName + '=' + answerValue);
                interactiveValues[tagName] = answerValue;
            }
        }
    }
    return interactiveValues;
}
/**
 * Determines whether the provided file is a valid XCCDF file or package.
 *
 * This function checks if the given file path points to a valid XCCDF file
 * or package by performing the following steps:
 * - Verifies if the file exists and is a regular file.
 * - Checks the file extension to determine if it is a `.zip` package or `.xml` file.
 * - Reads the content of `.xml` files to confirm the presence of the "xccdf" keyword
 *   in the first 10 lines.
 *
 * If the file is invalid or an error occurs during processing, appropriate error
 * messages are logged, and the function returns `false`.
 *
 * @param xccdfXmlFile - The file path to the XCCDF file or package to validate.
 * @returns `true` if the file is a valid XCCDF file or package, otherwise `false`.
 */
function isXccdfFile(xccdfXmlFile) {
    let isXccdf = true;
    try {
        if (fs_1.default.lstatSync(xccdfXmlFile).isFile()) {
            // logger.debug(`Processing the ${xccdfXmlFile} XCCDF file`)
            if (path_1.default.extname(xccdfXmlFile) === '.zip') {
                GenerateDelta.logger.debug('  Processing a XCCDF package (.zip)');
                isXccdf = true;
            }
            else {
                GenerateDelta.logger.debug('  Processing a XCCDF file (.xml)');
                const inputFile = fs_1.default.readFileSync(xccdfXmlFile, 'utf8');
                const inputFirstLine = inputFile.split('\n').slice(0, 10).join('').toLowerCase();
                if (inputFirstLine.includes('xccdf')) {
                    GenerateDelta.logger.debug('  Valid XCCDF file provided');
                }
                else {
                    const err = `  ERROR: Unable to load ${xccdfXmlFile} as a valid XCCDF`;
                    GenerateDelta.logger.error(err);
                    (0, cliHelper_1.addToProcessLogData)(err);
                    isXccdf = false;
                }
            }
        }
        else {
            const err = 'No benchmark (XCCDF) file/packages (.xml or .zip) was provided.';
            GenerateDelta.logger.error(err);
            (0, cliHelper_1.addToProcessLogData)(err);
            isXccdf = false;
        }
    }
    catch (error) {
        if (error instanceof Error) {
            const errorCode = error.code; // Type-safe access to `code`
            if (errorCode === 'ENOENT') {
                const err = `  ERROR: File not found: ${xccdfXmlFile}. Run the --help command for more information on expected input files.`;
                GenerateDelta.logger.error(err);
                (0, cliHelper_1.addToProcessLogData)(err);
                isXccdf = false;
            }
            else {
                const err = `  ERROR: Unable to process the XCCDF XML file ${xccdfXmlFile} because: ${error.message}`;
                GenerateDelta.logger.error(err);
                (0, cliHelper_1.addToProcessLogData)(err);
            }
        }
        else {
            const err = `ERROR: An unexpected error occurred: ${(0, global_1.getErrorMessage)(error)}`;
            GenerateDelta.logger.error(err);
            (0, cliHelper_1.addToProcessLogData)(err);
        }
        isXccdf = false;
    }
    return isXccdf;
}
function saveLogs(errorMsg) {
    const strArray = errorMsg.split('\n');
    for (const error of strArray) {
        GenerateDelta.logger.error(error);
        (0, cliHelper_1.addToProcessLogData)(error.trim());
    }
    (0, cliHelper_1.saveProcessLogData)();
}
function sleep(ms) {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}
//# sourceMappingURL=delta.js.map