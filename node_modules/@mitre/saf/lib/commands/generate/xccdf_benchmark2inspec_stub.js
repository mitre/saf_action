"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const logging_1 = require("../../utils/logging");
const inspec_objects_1 = require("@mitre/inspec-objects");
class XCCDFBenchmark2InSpec extends core_1.Command {
    static usage = 'saf generate xccdf_benchmark2inspec_stub -i <stig-xccdf-xml> [-o <output-folder>] [-h] [-m <metadata-json>] [-T (rule|group|cis|version)] [-s] [-L (info|warn|debug|verbose)]';
    static description = 'Translate an XCCDF benchmark file to a skeleton for an InSpec profile';
    static flags = {
        help: core_1.Flags.help({ char: 'h' }),
        input: core_1.Flags.string({ char: 'i', required: true, description: 'Path to the XCCDF benchmark file' }),
        metadata: core_1.Flags.string({ char: 'm', required: false, description: 'Path to a JSON file with additional metadata for the inspec.yml file' }),
        singleFile: core_1.Flags.boolean({ char: 's', required: false, default: false, description: 'Output the resulting controls as a single file' }),
        idType: core_1.Flags.string({
            char: 'T',
            required: false,
            default: 'rule',
            options: ['rule', 'group', 'cis', 'version'],
            description: "Control ID Types: 'rule' - Vulnerability IDs (ex. 'SV-XXXXX'), 'group' - Group IDs (ex. 'V-XXXXX'), 'cis' - CIS Rule IDs (ex. C-1.1.1.1), 'version' - Version IDs (ex. RHEL-07-010020 - also known as STIG IDs)",
        }),
        ovalDefinitions: core_1.Flags.string({ char: 'O', required: false, description: 'Path to an OVAL definitions file to populate profile elements that reference OVAL definitions' }),
        output: core_1.Flags.string({ char: 'o', required: false, default: 'profile', description: 'The output folder to write the generated InSpec content' }),
        logLevel: core_1.Flags.string({ char: 'L', required: false, default: 'info', options: ['info', 'warn', 'debug', 'verbose'] }),
    };
    static examples = [
        'saf generate xccdf_benchmark2inspec_stub -i ./U_RHEL_6_STIG_V2R2_Manual-xccdf.xml -T group --logLevel debug -r rhel-6-update-report.md',
        'saf generate xccdf_benchmark2inspec_stub -i ./CIS_Ubuntu_Linux_18.04_LTS_Benchmark_v1.1.0-xccdf.xml -O ./CIS_Ubuntu_Linux_18.04_LTS_Benchmark_v1.1.0-oval.xml --logLevel debug',
    ];
    async run() {
        const { flags } = await this.parse(XCCDFBenchmark2InSpec);
        const logger = (0, logging_1.createWinstonLogger)('generate:xccdf_benchmark2inspec_stub', flags.logLevel);
        // Check if the output folder already exists
        if (fs_1.default.existsSync(flags.output)) {
            // Folder should not exist already
            throw new Error('Profile output folder already exists, please specify a new folder');
        }
        else {
            logger.debug('Creating output folder with controls and libraries directories');
            fs_1.default.mkdirSync(flags.output);
            fs_1.default.mkdirSync(path_1.default.join(flags.output, 'controls'));
            fs_1.default.mkdirSync(path_1.default.join(flags.output, 'libraries'));
        }
        // This will get overridden if a metadata file is passed
        let metadata = {};
        // Read metadata file if passed
        if (flags.metadata) {
            if (fs_1.default.existsSync(flags.metadata)) {
                logger.debug(`Reading metadata file: ${flags.metadata}.`);
                metadata = JSON.parse(fs_1.default.readFileSync(flags.metadata, 'utf8'));
            }
            else {
                throw new Error('Passed metadata file does not exist');
            }
        }
        // Read OVAL definitions file if passed
        let ovalDefinitions;
        if (flags.ovalDefinitions) {
            if (fs_1.default.existsSync(flags.ovalDefinitions)) {
                logger.debug(`Reading oval definitions file: ${flags.ovalDefinitions}.`);
                ovalDefinitions = (0, inspec_objects_1.processOVAL)(fs_1.default.readFileSync(flags.ovalDefinitions, 'utf8'));
            }
            else {
                throw new Error('Passed OVAL definitions file does not exist');
            }
        }
        // Read the XCCDF file
        const xccdf = fs_1.default.readFileSync(flags.input, 'utf8');
        let profile;
        logger.debug(`Processing XCCDF Benchmark file: ${flags.input} using ${flags.idType} id.`);
        const idTypes = ['rule', 'group', 'cis', 'version'];
        if (idTypes.includes(flags.idType)) {
            profile = (0, inspec_objects_1.processXCCDF)(xccdf, false, flags.idType, ovalDefinitions);
        }
        else {
            logger.error(`Invalid ID Type: ${flags.idType}. Check the --help command for the available ID Type options.`);
            throw new Error('No ID type specified');
        }
        profile.version = '1.0.0';
        // Add metadata if provided
        if (flags.metadata) {
            profile.maintainer = metadata.maintainer;
            profile.copyright = metadata.copyright;
            profile.license = metadata.license;
            profile.version = metadata.version || '1.0.0';
        }
        // Write inspec.yml
        logger.debug(`Writing inspec.yml file to: ${path_1.default.join(flags.output, 'inspec.yml')}`);
        fs_1.default.writeFileSync(path_1.default.join(flags.output, 'inspec.yml'), profile.createInspecYaml());
        // Write all controls
        if (flags.singleFile) {
            const controls = profile.controls
                .map(control => control.toRuby())
                .join('\n\n');
            logger.debug(`Writing control to: ${path_1.default.join(flags.output, 'controls', 'controls.rb')}`);
            fs_1.default.writeFileSync(path_1.default.join(flags.output, 'controls', 'controls.rb'), controls);
        }
        else {
            profile.controls.forEach(control => {
                logger.debug(`Writing control to: ${path_1.default.join(flags.output, 'controls', control.id + '.rb')}`);
                fs_1.default.writeFileSync(path_1.default.join(flags.output, 'controls', control.id + '.rb'), control.toRuby());
            });
        }
    }
}
exports.default = XCCDFBenchmark2InSpec;
