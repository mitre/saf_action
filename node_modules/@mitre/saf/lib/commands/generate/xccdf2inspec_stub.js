"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable no-negated-condition */
const core_1 = require("@oclif/core");
const fs_1 = tslib_1.__importDefault(require("fs"));
const xccdf2inspec_1 = require("../../utils/xccdf2inspec");
const path_1 = tslib_1.__importDefault(require("path"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const yaml_1 = tslib_1.__importDefault(require("yaml"));
const hdf_converters_1 = require("@mitre/hdf-converters");
class XCCDF2InSpec extends core_1.Command {
    async run() {
        var _a;
        const { flags } = await this.parse(XCCDF2InSpec);
        // Check if the output folder already exists
        if (!fs_1.default.existsSync(flags.output)) {
            fs_1.default.mkdirSync(flags.output);
            fs_1.default.mkdirSync(path_1.default.join(flags.output, 'controls'));
            fs_1.default.mkdirSync(path_1.default.join(flags.output, 'libraries'));
        }
        else {
            // Folder should not exist already
            throw new Error('Profile output folder already exists, please specify a new folder');
        }
        // This will get overridden if a metadata file is passed
        let metadata = {};
        // Read metadata file if passed
        if (flags.metadata) {
            if (fs_1.default.existsSync(flags.metadata)) {
                metadata = JSON.parse(fs_1.default.readFileSync(flags.metadata, 'utf8'));
            }
            else {
                throw new Error('Passed metadata file does not exist');
            }
        }
        // Read XCCDF file
        const parsedXML = (0, xccdf2inspec_1.convertEncodedXmlIntoJson)(fs_1.default.readFileSync(flags.input, 'utf8'));
        // Extract groups (these contain controls)
        const groups = parsedXML.Benchmark.Group;
        // All of our extracted controls to be converted into Ruby/InSpec code
        const inspecControls = [];
        // Convert profile inspec.yml
        const profileInfo = {
            name: parsedXML.Benchmark['@_id'],
            title: parsedXML.Benchmark.title,
            maintainer: metadata.maintainer || 'The Authors',
            copyright: metadata.copyright || 'The Authors',
            copyright_email: metadata.copyright_email || 'you@example.com',
            license: metadata.license || 'Apache-2.0',
            summary: `"${parsedXML.Benchmark.description}"`,
            version: metadata.version || '0.1.0',
        };
        // Write inspec.yml
        fs_1.default.writeFileSync(path_1.default.join(flags.output, 'inspec.yml'), yaml_1.default.stringify(profileInfo));
        // Add Status, release, and reference information for README.md
        if (parsedXML.Benchmark.status && parsedXML.Benchmark.status['#text'] && parsedXML.Benchmark.status['@_date']) {
            profileInfo.status = `${parsedXML.Benchmark.status['#text']} on ${parsedXML.Benchmark.status['@_date']}`;
        }
        if (parsedXML.Benchmark['plain-text']) {
            const plainTextMetaDataValues = Array.isArray(parsedXML.Benchmark['plain-text']) ? parsedXML.Benchmark['plain-text'] : [parsedXML.Benchmark['plain-text']];
            profileInfo.release = (_a = plainTextMetaDataValues.find(metadataValue => metadataValue['@_id'].toLowerCase().trim() === 'release-info')) === null || _a === void 0 ? void 0 : _a['#text'];
        }
        profileInfo.reference = parsedXML.Benchmark.reference['@_href'];
        profileInfo.referenceBy = parsedXML.Benchmark.reference['dc:publisher'];
        profileInfo.referenceSource = parsedXML.Benchmark.reference['dc:source'];
        // Convert camelCase and snake_case to human readable for README.md
        const readableMetadata = {};
        Object.entries(profileInfo).forEach(([key, value]) => {
            // Filter out any undefined values and omit summary and title
            if (value && key !== 'summary' && key !== 'summary') {
                readableMetadata[lodash_1.default.startCase(key)] = value;
            }
        });
        // Write README.md
        fs_1.default.writeFileSync(path_1.default.join(flags.output, 'README.md'), `# ${profileInfo.name}\n${profileInfo.summary}\n---\n${yaml_1.default.stringify(readableMetadata)}`);
        // Convert Controls
        groups.forEach(group => {
            var _a;
            // Extract encoded XML values from the rule description
            const extractedDescription = (0, xccdf2inspec_1.convertEncodedHTMLIntoJson)((_a = group.Rule) === null || _a === void 0 ? void 0 : _a.description);
            // Group must contain a vulnerability
            if (!group.Rule) {
                throw new Error(`Group exists without vulnerability ${group['@_id']}`);
            }
            if (!extractedDescription.VulnDiscussion) {
                throw new Error('Vulnerability exists without VulnDiscussion');
            }
            let controlID = group['@_id'];
            if (flags.useVulnerabilityId) {
                controlID = group.Rule['@_id'].split('r')[0];
            }
            else if (flags.useStigID) {
                controlID = group.Rule.version;
            }
            // Create a barebones InSpec control
            const inspecControl = {
                id: controlID,
                title: group.Rule['@_severity'] ? group.Rule.title : `[[[MISSING SEVERITY FROM STIG]]] ${group.Rule.title}`,
                desc: extractedDescription.VulnDiscussion.split('Satisfies: ')[0],
                impact: (0, xccdf2inspec_1.severityStringToImpact)(group.Rule['@_severity'] || 'critical'),
                rationale: '',
                descs: {
                    check: typeof group.Rule.check === 'string' ? group.Rule.check : group.Rule.check['check-content'],
                    fix: typeof group.Rule.fixtext === 'string' ? group.Rule.fixtext : group.Rule.fixtext['#text'],
                },
                tags: {
                    severity: (0, xccdf2inspec_1.impactNumberToSeverityString)((0, xccdf2inspec_1.severityStringToImpact)(group.Rule['@_severity'] || 'critical')),
                    gtitle: group.title,
                    satisfies: extractedDescription.VulnDiscussion.includes('Satisfies: ') && extractedDescription.VulnDiscussion.split('Satisfies: ').length >= 1 ? extractedDescription.VulnDiscussion.split('Satisfies: ')[1].split(',').map(satisfaction => satisfaction.trim()) : undefined,
                    gid: group['@_id'],
                    rid: group.Rule['@_id'],
                    stig_id: group.Rule.version,
                    fix_id: group.Rule.fix ? group.Rule.fix['@_id'] : undefined,
                    false_negatives: extractedDescription.FalseNegatives,
                    false_positives: extractedDescription.FalsePositives,
                    documentable: extractedDescription.Documentable,
                    mitigations: extractedDescription.Mitigations,
                    severity_override_guidance: extractedDescription.SeverityOverrideGuidance,
                    potential_impacts: extractedDescription.PotentialImpacts,
                    third_party_tools: extractedDescription.ThirdPartyTools,
                    mitigation_control: extractedDescription.MitigationControl,
                    mitigation_controls: extractedDescription.MitigationControls,
                    responsibility: extractedDescription.Responsibility,
                    ia_controls: extractedDescription.IAControls,
                },
            };
            if ('ident' in group.Rule) {
                const identifiers = Array.isArray(group.Rule.ident) ? group.Rule.ident : [group.Rule.ident];
                // Grab CCI/NIST/Legacy identifiers
                identifiers.forEach(identifier => {
                    var _a, _b, _c, _d;
                    if (identifier['@_system'].toLowerCase().endsWith('cci')) {
                        lodash_1.default.set(inspecControl, 'tags.cci', lodash_1.default.get(inspecControl, 'tags.cci') || []);
                        (_a = inspecControl.tags.cci) === null || _a === void 0 ? void 0 : _a.push(identifier['#text']);
                        if (identifier['#text'] in hdf_converters_1.CciNistMappingData.data) {
                            lodash_1.default.set(inspecControl, 'tags.nist', lodash_1.default.get(inspecControl, 'tags.nist') || []);
                            const nistMapping = lodash_1.default.get(hdf_converters_1.CciNistMappingData.data, identifier['#text']);
                            if (((_b = inspecControl.tags.nist) === null || _b === void 0 ? void 0 : _b.indexOf(nistMapping)) === -1) {
                                (_c = inspecControl.tags.nist) === null || _c === void 0 ? void 0 : _c.push(nistMapping);
                            }
                        }
                    }
                    if (identifier['@_system'].toLowerCase().endsWith('legacy')) {
                        lodash_1.default.set(inspecControl, 'tags.legacy', lodash_1.default.get(inspecControl, 'tags.legacy') || []);
                        (_d = inspecControl.tags.legacy) === null || _d === void 0 ? void 0 : _d.push(identifier['#text']);
                    }
                });
            }
            inspecControls.push(inspecControl);
        });
        // Convert all extracted controls to Ruby/InSpec code
        if (!flags.singleFile) {
            inspecControls.forEach(control => {
                fs_1.default.writeFileSync(path_1.default.join(flags.output, 'controls', control.id + '.rb'), (0, xccdf2inspec_1.inspecControlToRubyCode)(control, flags.lineLength, flags.encodingHeader));
            });
        }
        else {
            const controlOutfile = fs_1.default.createWriteStream(path_1.default.join(flags.output, 'controls', 'controls.rb'), { flags: 'w' });
            inspecControls.forEach(control => {
                controlOutfile.write((0, xccdf2inspec_1.inspecControlToRubyCode)(control, flags.lineLength, flags.encodingHeader) + '\n\n');
            });
            controlOutfile.close();
        }
    }
}
exports.default = XCCDF2InSpec;
XCCDF2InSpec.usage = 'generate xccdf2inspec_stub -i, --input=XML -o, --output=FOLDER';
XCCDF2InSpec.description = 'Translate a DISA STIG XCCDF XML file to a skeleton for an InSpec profile';
XCCDF2InSpec.flags = {
    help: core_1.Flags.help({ char: 'h' }),
    input: core_1.Flags.string({ char: 'i', required: true, description: 'Path to the DISA STIG XCCDF file' }),
    metadata: core_1.Flags.string({ char: 'm', required: false, description: 'Path to a JSON file with additional metadata for the inspec.yml file' }),
    singleFile: core_1.Flags.boolean({ char: 's', required: false, default: false, description: 'Output the resulting controls as a single file' }),
    useVulnerabilityId: core_1.Flags.boolean({ char: 'r', required: false, default: false, description: "Use Vulnerability IDs (ex. 'SV-XXXXX') instead of Group IDs (ex. 'V-XXXXX')", exclusive: ['useStigID'] }),
    useStigID: core_1.Flags.boolean({ char: 'S', required: false, default: false, description: "Use STIG IDs (<Group/Rule/Version>) instead of Group IDs (ex. 'V-XXXXX') for InSpec Control IDs", exclusive: ['useVulnerabilityId'] }),
    lineLength: core_1.Flags.integer({ char: 'l', required: false, default: 80, description: 'Characters between lines within InSpec controls' }),
    encodingHeader: core_1.Flags.boolean({ char: 'e', required: false, default: false, description: 'Add the "# encoding: UTF-8" comment at the top of each control' }),
    output: core_1.Flags.string({ char: 'o', required: true, default: 'profile' }),
};
