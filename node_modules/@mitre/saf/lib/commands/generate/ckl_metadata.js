"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const fs_1 = tslib_1.__importDefault(require("fs"));
const hdf_converters_1 = require("@mitre/hdf-converters");
const path_1 = tslib_1.__importDefault(require("path"));
const baseCommand_1 = require("../../utils/oclif/baseCommand");
const json_colorizer_1 = require("json-colorizer");
const global_1 = require("../../utils/global");
const cliHelper_1 = require("../../utils/oclif/cliHelper");
const prompts_1 = require("@inquirer/prompts");
const lodash_1 = tslib_1.__importStar(require("lodash"));
const os_1 = require("os");
class GenerateCKLMetadata extends baseCommand_1.BaseCommand {
    static usage = '<%= command.id %> [-h] [-L info|warn|debug|verbose] [-o <value> | --interactive]';
    static description = 'Generate a checklist metadata template for use by the "saf convert hdf2ckl" CLI command';
    static examples = [
        '<%= config.bin %> <%= command.id %> -o rhel_metadata.json',
        'The metadata file contains checklist supplemental data.',
        'The metadata file is composed of "profile(s)" and "asset" data.',
        '\x1B[1mExample of "One Profile" metadata:\x1B[0m',
        (0, json_colorizer_1.colorize)(JSON.stringify((0, global_1.getJsonMetaDataExamples)('ckl-one-metadata'), null, 2)),
        '\x1B[1mExample of "Multiple Profiles" metadata:\x1B[0m',
        (0, json_colorizer_1.colorize)(JSON.stringify((0, global_1.getJsonMetaDataExamples)('ckl-multiple-metadata'), null, 2)),
    ];
    static flags = {
        output: core_1.Flags.string({
            char: 'o', exclusive: ['interactive'],
            description: '\x1B[31m(required -o or --interactive)\x1B[34mThe Output metadata JSON File to be generate',
        }),
    };
    async run() {
        const { flags } = await this.parse(GenerateCKLMetadata);
        // If not interactive must provide -o 0r --output
        if (!flags.interactive && !flags.output) {
            this.error('\x1B[31mIf not interactive you must specify the metadata output json file [-o]\x1B[0m');
        }
        // Flag variables
        let metadataJsonFile = '';
        if (flags.interactive) {
            const interactiveFlags = await getFlags();
            if (interactiveFlags.outputDirectory) {
                metadataJsonFile = path_1.default.join(interactiveFlags.outputDirectory, interactiveFlags.outputFileName);
            }
        }
        else {
            metadataJsonFile = flags.output || 'metadata.json';
        }
        const cklMetadata = await getCklMetaData();
        const validationResults = (0, hdf_converters_1.validateChecklistMetadata)(cklMetadata);
        if (validationResults.ok) {
            fs_1.default.writeFileSync(metadataJsonFile, JSON.stringify(cklMetadata, null, 2));
            console.log(`Checklist metadata file written at: ${path_1.default.resolve(metadataJsonFile)}`);
        }
        else {
            console.error(`Unable to generate checklist metadata:\n${validationResults.error.message}`);
        }
    }
}
exports.default = GenerateCKLMetadata;
/**
 * Asynchronously prompts the user to select an output directory and specify a
 * metadata file name, validates input ends with a `.json` extension.
 *
 * @returns {Promise<unknown>} A promise that resolves to an object containing
 * the user's input values.
 * The object includes:
 * - `outputDirectory`: The selected output directory for the metadata file.
 * - `outputFileName`: The specified metadata file name with a `.json` extension.
 */
async function getFlags() {
    // Dynamically import inquirer-file-selector and chalk
    // Once we move the SAF CLI from a CommonJS to an ES modules we can use the regular import
    const { default: fileSelector } = await import('inquirer-file-selector');
    const { default: chalk } = await import('chalk');
    const fileSelectorTheme = {
        style: {
            file: (text) => chalk.green(text),
            currentDir: (text) => chalk.blueBright(text),
            help: (text) => chalk.yellow(text),
        },
    };
    // Variable used to store the prompts (question and answers)
    const interactiveValues = {};
    (0, cliHelper_1.printYellow)('Provide the necessary information:');
    (0, cliHelper_1.printGreen)('  Required flag - The metadata json file to be generated (full path to include file name)');
    const answers = {
        outputDirectory: await fileSelector({
            message: 'Select the output directory for the Metadata file:',
            pageSize: 15,
            loop: true,
            type: 'directory',
            allowCancel: true,
            emptyText: 'Directory is empty',
            theme: fileSelectorTheme,
        }),
        outputFileName: await (0, prompts_1.input)({
            message: 'Specify the output metadata filename (must have an extension of .json):',
            default: 'ckl_metadata.json',
            validate(input) {
                if (/^[\w]+\.json$/i.test(input)) { // skipcq: JS-0113
                    return true;
                }
                return 'Please enter a metadata file name that ends with .json';
            },
        }),
    };
    for (const tagName in answers) {
        if (Object.prototype.hasOwnProperty.call(answers, tagName)) {
            const answerValue = lodash_1.default.get(answers, tagName);
            if (answerValue !== null) {
                interactiveValues[tagName] = answerValue;
            }
        }
    }
    return interactiveValues;
}
/**
 * Collects metadata information necessary for generating a checklist
 * used by the "saf convert hdf2ckl" command.
 *
 * This function prompts the user to provide various fields of information
 * interactively. If a value is not available, the user can leave the field empty.
 *
 * @returns {Promise<unknown>} A promise that resolves to an object containing
 * the collected metadata values.
 */
async function getCklMetaData() {
    // Variable used to store the prompts (question and answers)
    const interactiveValues = {};
    (0, cliHelper_1.printYellow)('This process collects information necessary to generate a checklist metadata used by the "saf convert hdf2ckl" command.');
    (0, cliHelper_1.printYellow)('Not all fields are visible in the STIG Viewer, some are used for references and may not generate a ckl exactly as the STIG Viewer.\n');
    (0, cliHelper_1.printGreen)('Please fill in the following fields to the best of your ability, if you do not have a value, please leave the field empty.');
    // Collect the "profiles" metadata information
    let addProfile = true;
    const profiles = [];
    while (addProfile) {
        const profile = {
            name: await (0, prompts_1.input)({
                message: 'What is the benchmark name? (Must match the profile name listed in HDF):',
            }),
            title: await (0, prompts_1.input)({
                message: 'What is the benchmark title?:',
            }),
            version: await (0, prompts_1.number)({
                message: 'What is the benchmark version?:',
                default: 1,
            }),
            releasenumber: await (0, prompts_1.number)({
                message: 'What is the benchmark release number?:',
                default: 1,
            }),
            releasedate: await (0, prompts_1.input)({
                message: 'What is the benchmark release date (dd mmm yyyy)?:',
                default: '01 Jan 2025',
                validate(input) {
                    if (/^\d{2} \w{3} \d{4}$/.test(input)) { // skipcq: JS-0113
                        return true;
                    }
                    return 'Please enter a date in the format dd mmm yyyy';
                },
            }),
            showCalendar: await (0, prompts_1.confirm)({ message: 'Show the calendar?', default: true }),
        };
        profiles.push(profile);
        addProfile = await (0, prompts_1.confirm)({ message: 'Do you want to add another profile?', default: false });
    }
    interactiveValues.profiles = profiles;
    // Collect the "assets" metadata information
    const assets = {
        marking: await (0, prompts_1.input)({
            message: 'What is the classification marking? [Unclass, CUI, etc]:',
        }),
        hostname: await (0, prompts_1.input)({
            message: 'What is the asset hostname?:',
            default: (0, os_1.hostname)(),
            validate(input) {
                if ((0, lodash_1.isEmpty)(input) || /^[\w.-]+$/.test(input)) { // skipcq: JS-0113
                    return true;
                }
                return 'Please enter a valid hostname or leave blank';
            },
        }),
        hostip: await (0, prompts_1.input)({
            message: 'What is the asset IP address?:',
            validate(input) {
                if ((0, lodash_1.isEmpty)(input) || /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/.test(input)) { // skipcq: JS-0113
                    return true;
                }
                return 'Please enter a valid IP address or leave blank';
            },
        }),
        hostmac: await (0, prompts_1.input)({
            message: 'What is the asset MAC address?:',
            validate(input) {
                if ((0, lodash_1.isEmpty)(input) || /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/.test(input)) { // skipcq: JS-0113
                    return true;
                }
                return 'Please enter a valid MAC address or leave blank';
            },
        }),
        hostfqdn: await (0, prompts_1.input)({
            message: 'What is the asset FQDN?:',
            validate(input) {
                if ((0, lodash_1.isEmpty)(input) || /^[\w.-]+\.[a-z]{2,}$/.test(input)) { // skipcq: JS-0113
                    return true;
                }
                return 'Please enter a valid FQDN or leave blank';
            },
        }),
        targetcomment: await (0, prompts_1.input)({
            message: 'What are the target comments?:',
        }),
        role: await (0, prompts_1.select)({
            message: 'What is the computing role?:',
            choices: Object.values(hdf_converters_1.Role),
        }),
        assettype: await (0, prompts_1.select)({
            message: 'What is the asset type?:',
            choices: Object.values(hdf_converters_1.Assettype),
        }),
        techarea: await (0, prompts_1.select)({
            message: 'What is the tech area?:',
            choices: Object.values(hdf_converters_1.Techarea),
            // Filter out empty strings from the choices (currently not used as user may not have a value)
            // choices: Object.values(Techarea).filter(item => item !== ''),
        }),
        stigguid: await (0, prompts_1.input)({
            message: 'What is the STIG ID (DISA reference identifier profile belongs too)?:',
        }),
        targetkey: await (0, prompts_1.input)({
            message: 'What is the target key (DISA reference identifier control belongs too)?:',
        }),
        webordatabase: await (0, prompts_1.select)({
            message: 'Is the target a web or database?:',
            choices: ['y', 'n'],
        }),
        vulidmapping: await (0, prompts_1.select)({
            message: 'Use gid or id for vuln number?:',
            choices: ['gid', 'id'],
        }),
    };
    if (assets.webordatabase === 'y') {
        assets.webdbsite = await (0, prompts_1.input)({
            message: 'What is the Web or DB site?:',
        });
        assets.webdbinstance = await (0, prompts_1.input)({
            message: 'What is the Web or DB instance?:',
        });
    }
    for (const tagName in assets) {
        if (Object.prototype.hasOwnProperty.call(assets, tagName)) {
            const answerValue = lodash_1.default.get(assets, tagName);
            if (!(0, lodash_1.isEmpty)(answerValue)) {
                interactiveValues[tagName] = answerValue;
            }
        }
    }
    return interactiveValues;
}
//# sourceMappingURL=ckl_metadata.js.map