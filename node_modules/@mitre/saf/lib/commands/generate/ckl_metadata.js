"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const fs_1 = tslib_1.__importDefault(require("fs"));
const prompt_sync_1 = tslib_1.__importDefault(require("prompt-sync"));
const hdf_converters_1 = require("@mitre/hdf-converters");
const path_1 = tslib_1.__importDefault(require("path"));
const baseCommand_1 = require("../../utils/oclif/baseCommand");
const prompt = (0, prompt_sync_1.default)();
// Ensures that no empty strings are passed into the metadata
// by returning undefined instead
function enforceNonEmptyString(ask) {
    const response = prompt({ ask });
    if (response)
        return response;
    return null;
}
function enforceInteger(ask) {
    let response = prompt({ ask });
    let intRep = Number.parseInt(response, 10);
    let floatRep = Number.parseFloat(response);
    while (!(intRep === floatRep && intRep >= 0 && !Number.isNaN(intRep))) {
        if (!response)
            return null;
        console.log(`${response} is not a valid non-negative integer. Please try again`);
        response = prompt({ ask });
        intRep = Number.parseInt(response, 10);
        floatRep = Number.parseFloat(response);
    }
    return intRep;
}
function enforceEnum(ask, options) {
    // format prompt to show valid options (removes empty string options)
    ask = `${ask} (${options.filter(Boolean).join('/')}) `;
    let response = prompt({ ask });
    while (!options.includes(response)) {
        if (!response)
            return null;
        console.log(`${response} is not a valid option. Spelling and letter casing matters. Please try again.`);
        response = prompt({ ask });
    }
    return response;
}
class GenerateCKLMetadata extends baseCommand_1.BaseCommand {
    static usage = '<%= command.id %> -o <json-file> [-h]';
    static description = 'Generate a checklist metadata template for "saf convert hdf2ckl"';
    static examples = ['<%= config.bin %> <%= command.id %> -o rhel_metadata.json'];
    static flags = {
        output: core_1.Flags.string({ char: 'o', required: true, description: 'Output JSON File' }),
    };
    async run() {
        const { flags } = await this.parse(GenerateCKLMetadata);
        console.log('Please fill in the following fields to the best of your ability, if you do not have a value, please leave the field empty.');
        const cklMetadata = {
            profiles: [
                {
                    name: enforceNonEmptyString('What is the benchmark name? (Must match with profile name listed in HDF) ') || undefined,
                    title: enforceNonEmptyString('What is the benchmark title? ') || undefined,
                    version: enforceInteger('What is the benchmark version? ') || undefined,
                    releasenumber: enforceInteger('What is the benchmark release number? ') || undefined,
                    releasedate: enforceNonEmptyString('What is the benchmark release date (YYYY/MM/DD)? ') || undefined,
                    showCalendar: true,
                },
            ],
            marking: enforceNonEmptyString('What is the marking? ') || undefined,
            hostname: enforceNonEmptyString('What is the asset hostname? ') || undefined,
            hostip: enforceNonEmptyString('What is the asset IP address? ') || undefined,
            hostmac: enforceNonEmptyString('What is the asset MAC address? ') || undefined,
            hostfqdn: enforceNonEmptyString('What is the asset FQDN? ') || undefined,
            targetcomment: enforceNonEmptyString('What are the target comments? ') || undefined,
            role: enforceEnum('What is the computing role?', Object.values(hdf_converters_1.Role)) || undefined,
            assettype: enforceEnum('What is the asset type?', Object.values(hdf_converters_1.Assettype)) || undefined,
            // Resulting techarea options have typos. Yes, these typos really are how the enumerations are defined in STIG viewer's source code
            techarea: enforceEnum('What is the tech area? ', Object.values(hdf_converters_1.Techarea)) || undefined,
            stigguid: enforceNonEmptyString('What is the STIG ID? ') || undefined,
            targetkey: enforceNonEmptyString('What is the target key? ') || undefined,
            webordatabase: String(enforceEnum('Is the target a web or database?', ['y', 'n']) === 'y'),
            webdbsite: enforceNonEmptyString('What is the Web or DB site? ') || undefined,
            webdbinstance: enforceNonEmptyString('What is the Web or DB instance? ') || undefined,
            vulidmapping: enforceEnum('Use gid or id for vuln number?', ['gid', 'id']) || undefined,
        };
        const validationResults = (0, hdf_converters_1.validateChecklistMetadata)(cklMetadata);
        if (validationResults.ok) {
            fs_1.default.writeFileSync(flags.output, JSON.stringify(cklMetadata, null, 2));
            console.log(`Checklist metadata file written at: ${path_1.default.resolve(flags.output)}`);
        }
        else {
            console.error(`Unable to generate checklist metadata:\n${validationResults.error.message}`);
        }
    }
}
exports.default = GenerateCKLMetadata;
//# sourceMappingURL=ckl_metadata.js.map