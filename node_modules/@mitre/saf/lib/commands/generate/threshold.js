"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const inspecjs_1 = require("inspecjs");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const yaml_1 = tslib_1.__importDefault(require("yaml"));
const threshold_1 = require("../../utils/threshold");
class GenerateThreshold extends core_1.Command {
    async run() {
        const { flags } = await this.parse(GenerateThreshold);
        const thresholds = {};
        const parsedExecJSON = (0, inspecjs_1.convertFileContextual)(fs_1.default.readFileSync(flags.input, 'utf8'));
        const parsedProfile = parsedExecJSON.contains[0];
        const overallStatusCounts = (0, threshold_1.extractStatusCounts)(parsedProfile);
        const overallCompliance = (0, threshold_1.calculateCompliance)(overallStatusCounts);
        // Overall compliance counts
        lodash_1.default.set(thresholds, 'compliance.min', overallCompliance);
        if (flags.exact) {
            lodash_1.default.set(thresholds, 'compliance.max', overallCompliance);
        }
        // Severity counts
        for (const [severity, severityTargets] of Object.entries(threshold_1.severityTargetsObject)) {
            const severityStatusCounts = (0, threshold_1.extractStatusCounts)(parsedProfile, severity);
            for (const severityTarget of severityTargets) {
                const [statusName, _total, thresholdType] = severityTarget.split('.');
                if ((statusName === 'passed' && thresholdType === 'min') || flags.exact) {
                    lodash_1.default.set(thresholds, severityTarget, lodash_1.default.get(severityStatusCounts, (0, threshold_1.renameStatusName)(statusName)));
                }
                else if ((statusName !== 'passed' && thresholdType === 'max') || flags.exact) {
                    lodash_1.default.set(thresholds, severityTarget, lodash_1.default.get(severityStatusCounts, (0, threshold_1.renameStatusName)(statusName)));
                }
            }
        }
        // Total counts
        const severityStatusCounts = (0, threshold_1.extractStatusCounts)(parsedProfile);
        lodash_1.default.set(thresholds, 'passed.total.min', severityStatusCounts.Passed);
        lodash_1.default.set(thresholds, 'failed.total.max', severityStatusCounts.Failed);
        lodash_1.default.set(thresholds, 'skipped.total.max', severityStatusCounts['Not Reviewed']);
        lodash_1.default.set(thresholds, 'error.total.max', severityStatusCounts['Profile Error']);
        lodash_1.default.set(thresholds, 'no_impact.total.max', severityStatusCounts['Not Applicable']);
        // Expected control ID status and severity
        if (flags.generateControlIds) {
            (0, threshold_1.getControlIdMap)(parsedProfile, thresholds);
        }
        fs_1.default.writeFileSync(flags.output, yaml_1.default.stringify(thresholds));
    }
}
exports.default = GenerateThreshold;
GenerateThreshold.usage = 'generate threshold -i, --input=JSON -o, --output=YAML -e, --exact -c, --generateControlIds';
GenerateThreshold.description = 'Generate a compliance template for "saf validate threshold". Default output states that you must have your current control counts or better (More Passes and/or less Fails/Skips/Not Applicable/No Impact/Errors)';
GenerateThreshold.examples = ['saf generate threshold -i rhel7-results.json -e -c -o output.yaml'];
GenerateThreshold.flags = {
    help: core_1.Flags.help({ char: 'h' }),
    input: core_1.Flags.string({ char: 'i', required: true }),
    output: core_1.Flags.string({ char: 'o', required: true }),
    exact: core_1.Flags.boolean({ char: 'e', description: 'All counts should be exactly the same when validating, not just less than or greater than' }),
    generateControlIds: core_1.Flags.boolean({ char: 'c', required: false }),
};
