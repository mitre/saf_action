"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const promises_1 = require("fs/promises");
const child_process_1 = require("child_process");
const core_1 = require("@oclif/core");
const logging_1 = require("../../utils/logging");
const inspec_objects_1 = require("@mitre/inspec-objects");
const colors_1 = tslib_1.__importDefault(require("colors")); // eslint-disable-line no-restricted-imports
class GenerateUpdateControls extends core_1.Command {
    static usage = '<%= command.id %> [ARGUMENTS]';
    static description = 'Update the control names and/or format for an existing InSpec profile with updated XCCDF guidance, old controls are saved by default';
    static flags = {
        help: core_1.Flags.help({ char: 'h' }),
        xccdfXmlFile: core_1.Flags.string({ char: 'X', required: true, description: 'The XCCDF XML file containing the new guidance - in the form of .xml file' }),
        inspecJsonFile: core_1.Flags.string({ char: 'J', required: false, description: 'Input execution/profile JSON file - can be generated using the "inspec json <profile path> > profile.json" command' }),
        controlsDir: core_1.Flags.string({ char: 'c', required: true, description: 'The InSpec profile controls directory containing the profiles to be updated' }),
        controlPrefix: core_1.Flags.string({ char: 'P', required: false, default: 'V', options: ['V', 'SV'], description: 'Old control number prefix V or SV, default V' }),
        formatControls: core_1.Flags.boolean({ char: 'f', required: false, default: true, allowNo: true, description: 'Format control contents in the same way `generate delta` will write controls\n[default: true]' }),
        backupControls: core_1.Flags.boolean({ char: 'b', required: false, default: true, allowNo: true, description: 'Preserve modified controls in a backup directory (oldControls) inside the controls directory\n[default: true]' }),
        logLevel: core_1.Flags.string({ char: 'L', required: false, default: 'info', options: ['info', 'warn', 'debug', 'verbose'] }),
    };
    static examples = [
        'saf generate update_controls4delta -X ./the_xccdf_guidance_file.xml  -c the_controls_directory -L debug',
        'saf generate update_controls4delta -X ./the_xccdf_guidance_file.xml  -J ./the_profile_json -c the_controls_directory -L debug',
        'saf generate update_controls4delta -X ./the_xccdf_guidance_file.xml  -c the_controls_directory --no-formatControls -P SV -L debug',
        'saf generate update_controls4delta -X ./the_xccdf_guidance_file.xml  -c the_controls_directory --no-backupControls --no-formatControls -P SV -L debug',
    ];
    async run() {
        const { flags } = await this.parse(GenerateUpdateControls);
        const logger = (0, logging_1.createWinstonLogger)('generate:update_controls', flags.logLevel);
        this.warn(colors_1.default.yellow('╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════╗'));
        this.warn(colors_1.default.yellow('║ Make sure that profile controls are in cookstyle format - see https://docs.chef.io/workstation/cookstyle/ ║'));
        this.warn(colors_1.default.yellow('╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════╝'));
        let inspecProfile;
        // Process the XCCDF XML file containing the new/updated profile guidance
        try {
            if (fs_1.default.lstatSync(flags.xccdfXmlFile).isFile()) {
                const xccdfXmlFile = flags.xccdfXmlFile;
                logger.debug(`Processing the ${xccdfXmlFile} XCCDF file`);
                const inputFile = fs_1.default.readFileSync(xccdfXmlFile, 'utf8');
                const inputFirstLine = inputFile.split('\n').slice(0, 10).join('').toLowerCase();
                if (inputFirstLine.includes('xccdf')) {
                    logger.debug(`The ${xccdfXmlFile} is a valid XCCDF file`);
                }
                else {
                    logger.error(`ERROR: Unable to load ${xccdfXmlFile} as XCCDF`);
                    throw new Error('Cannot load XCCDF file');
                }
                logger.debug(`Loaded ${xccdfXmlFile} as XCCDF`);
            }
            else {
                throw new Error('No benchmark (XCCDF) file was provided.');
            }
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                logger.error(`ERROR: No entity found for: ${flags.xccdfXmlFile}. Run the --help command to more information on expected input files.`);
                throw error;
            }
            else {
                logger.error(`ERROR: Unable to process the XCCDF XML file ${flags.xccdfXmlFile} because: ${error}`);
                throw error;
            }
        }
        // Check if we have a controls folder
        if (fs_1.default.existsSync(flags.controlsDir)) {
            logger.debug('Found controls directory');
            fs_1.default.readdir(flags.controlsDir, function (err, files) {
                if (err) {
                    logger.error(`ERROR: Checking in controls directory is empty, received: ${err.message}`);
                    throw new Error(`Error checking controls directory, error: ${err.message}`);
                }
                else if (files.length) {
                    logger.debug(`Found ${files.length} InSpec Profiles in the controls directory`);
                    if (flags.backupControls) {
                        const oldControlsDir = path_1.default.join(flags.controlsDir, 'oldControls');
                        if (fs_1.default.existsSync(oldControlsDir)) {
                            fs_1.default.rmSync(oldControlsDir, { recursive: true, force: true });
                        }
                        fs_1.default.mkdirSync(oldControlsDir);
                    }
                }
                else {
                    // directory appears to be empty
                    logger.error(`No controls were found in the provide directory: ${flags.controlsDir}`);
                    throw new Error(`No controls were found in the provide directory: ${flags.controlsDir}`);
                }
            });
        }
        else {
            throw new Error('Controls folder not specified or does not exist');
        }
        // Generate or Process the Input execution/profile JSON file
        if (flags.formatControls) {
            // Process provided Profile JSON file
            if (flags.inspecJsonFile) {
                try {
                    if (fs_1.default.lstatSync(flags.inspecJsonFile).isFile()) {
                        const inspecJsonFile = flags.inspecJsonFile;
                        logger.debug(`Loading ${inspecJsonFile} as Profile JSON/Execution JSON`);
                        inspecProfile = (0, inspec_objects_1.processInSpecProfile)(fs_1.default.readFileSync(inspecJsonFile, 'utf8'));
                        logger.debug(`Loaded ${inspecJsonFile} as Profile JSON/Execution JSON`);
                    }
                    else {
                        throw new Error(`No entity found for: ${flags.inspecJsonFile}. Run the --help command to more information on expected input files.`);
                    }
                }
                catch (error) {
                    if (error.code === 'ENOENT') {
                        logger.error(`ERROR: No entity found for: ${flags.inspecJsonFile}. Run the --help command to more information on expected input files.`);
                        throw error;
                    }
                    else {
                        logger.error(`ERROR: Unable to process Input execution/profile JSON ${flags.inspecJsonFile} because: ${error}`);
                        throw error;
                    }
                }
            }
            else {
                // Generate the profile json
                try {
                    logger.info(`Generating the profile json using inspec json command on '${flags.controlsDir}'`);
                    // Get the directory name without the trailing "controls" directory
                    const profileDir = path_1.default.dirname(flags.controlsDir);
                    const inspecJsonFile = (0, child_process_1.execSync)(`inspec json '${profileDir}'`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 });
                    logger.info('Generating InSpec Profiles from InSpec JSON summary');
                    inspecProfile = (0, inspec_objects_1.processInSpecProfile)(inspecJsonFile);
                }
                catch (error) {
                    logger.error(`ERROR: Unable to generate the profile json because: ${error}`);
                    throw error;
                }
            }
        }
        // Process the XCCDF file and convert entries into a Profile object
        // The XCCDF contains the profiles metadata - it does not have the code descriptions
        logger.debug(`Processing XCCDF Benchmark file: ${flags.xccdfXmlFile} using rule id.`);
        const xccdf = fs_1.default.readFileSync(flags.xccdfXmlFile, 'utf8');
        /* eslint-disable prefer-const, max-depth */
        let xccdfProfile;
        xccdfProfile = (0, inspec_objects_1.processXCCDF)(xccdf, false, 'rule'); // skipcq: JS-0242
        // Create a map data type with: key = legacy Id (V or SV number) and value = new Id (SV number)
        // Create a map data type to be used as a flag to identify new controls (key and value are the new control Id)
        // Create a map data type to be used as a flag to identify legacy controls (key and value are the legacy control Id)
        // The new and legacy controls Map is used used so we can invoke .has(key) method (test if map contains provide key)
        const xccdfLegacyToControlMap = new Map();
        const xccdfLegacyControlsMap = new Map();
        const xccdfControlsMap = new Map();
        xccdfProfile.controls.forEach(control => {
            const controlId = control.tags.legacy?.map(value => {
                const control = flags.controlPrefix === 'V' ? value.match(/^V-\d+/)?.toString() : value.match(/^SV-\d+/)?.toString();
                return (control === undefined) ? '' : control;
            }).find(Boolean);
            xccdfLegacyToControlMap.set(controlId, control.id);
            xccdfLegacyControlsMap.set(controlId, controlId);
            xccdfControlsMap.set(control.id, control.id);
        });
        // Create a map data type containing the controls found in the processed InSpec JSON file
        //   The InSpec JSON file contains the controls and associated code block (these are
        //   created from the existing controls - They are updated via the Delta process)
        // Lint the controls using the toRuby method provided by the Controls class
        const inspecProfileFormattedControls = new Map();
        if (flags.formatControls) {
            logger.debug('Formatting the existing controls with no diff.');
            inspecProfile.controls.forEach(control => {
                inspecProfileFormattedControls.set(control.id, control.toRuby(false));
            });
        }
        logger.debug(`Processing controls directory: ${flags.controlsDir} and updating controls file name and new control number (id).`);
        const ext = '.rb';
        let skipped = 0;
        let processed = 0;
        let isCorrectControl = 0;
        let notInProfileJSON = 0;
        const controlsDir = flags.controlsDir;
        const files = await (0, promises_1.readdir)(controlsDir);
        // Iterate trough all files processing ony control files, have a .rb extension
        const skippedControls = [];
        const skippedFormatting = [];
        const isCorrectControlMap = new Map();
        const controlsProcessedMap = new Map();
        for (const file of files) {
            const fileExt = path_1.default.extname(file);
            if (fileExt === ext) {
                const currentFileFullPath = path_1.default.join(controlsDir, file);
                const currentControlNumber = path_1.default.parse(file).name;
                const newXCCDFControlNumber = xccdfLegacyToControlMap.get(currentControlNumber);
                const xccdfControlNumber = xccdfControlsMap.get(currentControlNumber);
                const xccdfLegacyControlNumber = xccdfLegacyControlsMap.get(currentControlNumber);
                let updatedControl;
                // FILE = XCCDF
                if (currentControlNumber === xccdfControlNumber) {
                    logger.debug(`Control Profile number is current: ${currentControlNumber} `);
                    isCorrectControl++;
                    isCorrectControlMap.set(currentControlNumber, currentControlNumber); // Map used to compute output statistics (value does not matter)
                    if (flags.formatControls) {
                        // Check if the formatted control is indexed by current control - if it isn't, this control was already processed
                        /* eslint-disable-next-line unicorn/prefer-ternary */
                        if (inspecProfileFormattedControls.get(currentControlNumber)) {
                            updatedControl = inspecProfileFormattedControls.get(currentControlNumber);
                        }
                        else {
                            updatedControl = getUpdatedControl(currentFileFullPath, currentControlNumber, 'undefined');
                        }
                    }
                    else {
                        // Just get the control data
                        updatedControl = getUpdatedControl(currentFileFullPath, currentControlNumber, 'undefined');
                    }
                    // Save file
                    saveControl(currentFileFullPath, currentControlNumber, currentControlNumber, updatedControl, flags.backupControls, false);
                    // FILE = LEGACY NUMBER
                }
                else if (currentControlNumber === xccdfLegacyControlNumber) {
                    logger.debug(`Control Profile number is not current - changing: ${currentControlNumber} with: ${newXCCDFControlNumber}`);
                    // Change the V or SV Id to the SV Id based on format flag
                    if (flags.formatControls) {
                        if (inspecProfileFormattedControls.has(xccdfLegacyControlNumber)) {
                            updatedControl = inspecProfileFormattedControls.get(xccdfLegacyControlNumber).replace(`${currentControlNumber}`, `${newXCCDFControlNumber}`);
                        }
                        else {
                            notInProfileJSON++;
                            skippedFormatting.push(`(Profile: ${currentControlNumber} XCCDF: ${newXCCDFControlNumber})`);
                            updatedControl = getUpdatedControl(currentFileFullPath, currentControlNumber, 'undefined');
                        }
                        // Don't format, just replace the control name (SV or V) and assign value to the updatedControl variable
                    }
                    else {
                        updatedControl = getUpdatedControl(currentFileFullPath, currentControlNumber, newXCCDFControlNumber);
                    }
                    saveControl(currentFileFullPath, newXCCDFControlNumber, currentControlNumber, updatedControl, flags.backupControls, true);
                    processed++;
                    controlsProcessedMap.set(newXCCDFControlNumber, 'processed');
                    // FILE ≠ XCCDF
                }
                else if (xccdfControlNumber === undefined) {
                    logger.debug(`Found a Control Profile not included in the XCCDF: ${currentControlNumber}`);
                    skipped++;
                    skippedControls.push(currentControlNumber);
                    // FILE ≠ XCCDF ≠ LEGACY NUMBER
                }
                else {
                    logger.debug(`No logic found processing Control Profile: ${currentControlNumber}`);
                }
            }
        }
        let newControls = 0;
        const newControlsFound = [];
        for (const newControl of xccdfControlsMap.values()) {
            if (!controlsProcessedMap.has(newControl) && !isCorrectControlMap.has(newControl)) {
                newControls++;
                newControlsFound.push(newControl);
            }
        }
        console.log(colors_1.default.yellow('\n     Total skipped files - no mapping to new control Id:'), colors_1.default.green(`${skipped.toString().padStart(4)}`));
        console.log(colors_1.default.yellow('Total processed files - found mapping to new control Id: '), colors_1.default.green(`${processed.toString().padStart(3)}`));
        console.log(colors_1.default.yellow('\n    Total controls with correct identification: '), colors_1.default.green(`${isCorrectControl.toString().padStart(3)}`));
        console.log(colors_1.default.yellow('Total new controls found in the XCCDF guidance: '), colors_1.default.green(`${newControls.toString().padStart(3)}`));
        console.log(colors_1.default.yellow('\nSkipped control(s) - not included in XCCDF guidance: '), `${colors_1.default.green(skippedControls.toString())}`);
        console.log(colors_1.default.yellow('\n  New control(s) found - included in XCCDF guidance: '), `${colors_1.default.green(newControlsFound.toString())}`);
        if (flags.formatControls && notInProfileJSON > 0) {
            console.log(colors_1.default.bold.red('\nTotal skipped formatting - not found in the profile json: '), colors_1.default.green(`${notInProfileJSON.toString().padStart(3)}`));
            console.log(colors_1.default.bold.red('Control(s) skipped formatting: '), colors_1.default.green(`${skippedFormatting.toString()}`));
        }
    }
}
exports.default = GenerateUpdateControls;
function getUpdatedControl(path, currentControlNumber, newControlNumber) {
    // Read the control content
    const controlData = fs_1.default.readFileSync(path, { encoding: 'utf8', flag: 'r' });
    if (newControlNumber !== undefined) {
        controlData.replace(currentControlNumber, newControlNumber);
    }
    return controlData;
}
/* eslint-disable-next-line max-params */
function saveControl(filePath, newXCCDFControlNumber, currentControlNumber, updatedControl, backupControls, renamedControl) {
    const controlsDir = path_1.default.dirname(filePath);
    const newFileName = path_1.default.join(controlsDir, newXCCDFControlNumber + '.rb');
    // Move processed (old) control to oldControls folder
    if (backupControls) {
        const destFilePath = path_1.default.resolve(path_1.default.join(controlsDir, 'oldControls', currentControlNumber + '.rb'));
        if (renamedControl) {
            fs_1.default.renameSync(filePath, destFilePath);
        }
        else {
            fs_1.default.copyFileSync(filePath, destFilePath);
        }
        // Deleted processed (old) file
    }
    else if (renamedControl) {
        fs_1.default.unlinkSync(filePath);
    }
    // Save new file
    fs_1.default.writeFileSync(newFileName, updatedControl);
}
