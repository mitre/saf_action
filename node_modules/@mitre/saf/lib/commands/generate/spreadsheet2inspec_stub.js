"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const sync_1 = tslib_1.__importDefault(require("csv-parse/lib/sync"));
const yaml_1 = tslib_1.__importDefault(require("yaml"));
const xlsx_populate_1 = tslib_1.__importDefault(require("xlsx-populate"));
const xccdf2inspec_1 = require("../../utils/xccdf2inspec");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const global_1 = require("../../utils/global");
const hdf_converters_1 = require("@mitre/hdf-converters");
const cis2nist_json_1 = tslib_1.__importDefault(require("../../resources/cis2nist.json"));
const files_json_1 = tslib_1.__importDefault(require("../../resources/files.json"));
class Spreadsheet2HDF extends core_1.Command {
    static usage = 'generate spreadsheet2inspec_stub -i, --input=<XLSX or CSV> -o, --output=FOLDER';
    static description = 'Convert CSV STIGs or CIS XLSX benchmarks into a skeleton InSpec profile';
    static examples = ['saf generate spreadsheet2inspec_stub -i spreadsheet.xlsx -o profile'];
    static flags = {
        help: core_1.Flags.help({ char: 'h' }),
        input: core_1.Flags.string({ char: 'i', required: true }),
        controlNamePrefix: core_1.Flags.string({ char: 'c', required: false, default: '', description: 'Prefix for all control IDs' }),
        format: core_1.Flags.string({ char: 'f', required: false, default: 'general', options: ['cis', 'disa', 'general'] }),
        encodingHeader: core_1.Flags.boolean({ char: 'e', required: false, default: false, description: 'Add the "# encoding: UTF-8" comment at the top of each control' }),
        metadata: core_1.Flags.string({ char: 'm', required: false, description: 'Path to a JSON file with additional metadata for the inspec.yml file' }),
        mapping: core_1.Flags.string({ char: 'M', required: false, description: 'Path to a YAML file with mappings for each field, by default, CIS Benchmark fields are used for XLSX, STIG Viewer CSV export is used by CSV' }),
        lineLength: core_1.Flags.integer({ char: 'l', required: false, default: 80, description: 'Characters between lines within InSpec controls' }),
        output: core_1.Flags.string({ char: 'o', required: true, description: 'Output InSpec profile folder' }),
    };
    // Extract URLs for references
    matchReferences(control) {
        if (control.ref) {
            const urlMatches = control.ref.replaceAll('\r', '').replaceAll('\n', '').match(/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/g);
            if (urlMatches) {
                control.refs = urlMatches;
            }
            control.ref = undefined;
        }
        return control;
    }
    // Set impact from tags.severity if impact is not defined
    matchImpactFromSeverityIfImpactNotSet(control) {
        if (!control.impact && control.tags?.severity) {
            control.impact = (0, xccdf2inspec_1.severityStringToImpact)(control.tags.severity);
        }
        return control;
    }
    // Extract CIS controls from control.tags.cis_controls (as string) into
    matchCISControls(control, flags) {
        if (flags.format === 'cis' && control.tags && control.tags.cis_controls && typeof control.tags.cis_controls === 'string') {
            // Match standard CIS benchmark XLSX spreadsheets
            // CIS controls are a string before they are parsed
            let cisControlMatches = control.tags.cis_controls.match(/CONTROL:v(\d) (\d+)\.?(\d*)/);
            if (cisControlMatches) {
                control.tags.cis_controls = [];
                const mappedCISControlsByVersion = {};
                cisControlMatches.map(cisControl => cisControl.split(' ')).forEach(([revision, cisControl]) => {
                    const controlRevision = revision.split('CONTROL:v')[1];
                    const existingControls = lodash_1.default.get(mappedCISControlsByVersion, controlRevision) || [];
                    existingControls.push(cisControl);
                    mappedCISControlsByVersion[controlRevision] = existingControls;
                });
                Object.entries(mappedCISControlsByVersion).forEach(([version, controls]) => {
                    if (version !== 'undefined') {
                        control.tags?.cis_controls?.push({
                            [version]: controls,
                        });
                    }
                });
            }
            else {
                // Match parsed CIS benchmark PDFs
                // CIS controls are a string before they are parsed
                cisControlMatches = (control.tags?.cis_controls).match(/v\d\W\r?\n\d.?\d?\d?/gi);
                if (cisControlMatches && control.tags) {
                    control.tags.cis_controls = [];
                    const mappedCISControlsByVersion = {};
                    cisControlMatches.map((cisControl => cisControl.replace(/\r?\n/, '').split(' '))).forEach(([revision, cisControl]) => {
                        if (revision === 'v7' && cisControl in cis2nist_json_1.default) {
                            control.tags?.nist?.push(lodash_1.default.get(cis2nist_json_1.default, cisControl));
                        }
                        const revisionNumber = revision.replace('v', '');
                        const existingControls = lodash_1.default.get(mappedCISControlsByVersion, revisionNumber) || [];
                        existingControls.push(cisControl);
                        mappedCISControlsByVersion[revisionNumber] = existingControls;
                    });
                    console.log(mappedCISControlsByVersion);
                    Object.entries(mappedCISControlsByVersion).forEach(([version, controls]) => {
                        if (version !== 'undefined') {
                            control.tags?.cis_controls?.push({
                                [version]: controls,
                            });
                        }
                    });
                }
            }
        }
        return control;
    }
    extractCCIsFromText(control) {
        if (control.tags?.cci) {
            const extractedCCIs = [];
            control.tags.cci.forEach(cci => {
                const cciMatches = cci.match(/CCI-\d{4,}/g);
                if (cciMatches) {
                    cciMatches.forEach(match => {
                        extractedCCIs.push(match);
                    });
                }
            });
            control.tags.cci = extractedCCIs;
        }
        return control;
    }
    async run() {
        const { flags } = await this.parse(Spreadsheet2HDF);
        if (flags.format === 'general' && !flags.mapping) {
            throw new Error('Please provide your own mapping file for spreadsheets that do not follow CIS or DISA specifications, or use --format to specify a template');
        }
        // Check if the output folder already exists
        if (fs_1.default.existsSync(flags.output)) {
            // Folder should not exist already
            throw new Error('Profile output folder already exists, please specify a new folder');
        }
        else {
            fs_1.default.mkdirSync(flags.output);
            fs_1.default.mkdirSync(path_1.default.join(flags.output, 'controls'));
            fs_1.default.mkdirSync(path_1.default.join(flags.output, 'libraries'));
        }
        let metadata = {};
        let mappings = {};
        // Read metadata file if passed
        if (flags.metadata) {
            if (fs_1.default.existsSync(flags.metadata)) {
                metadata = JSON.parse(fs_1.default.readFileSync(flags.metadata, 'utf8'));
            }
            else {
                throw new Error('Passed metadata file does not exist');
            }
        }
        // Read mapping file
        if (flags.mapping) {
            if (fs_1.default.existsSync(flags.mapping)) {
                mappings = yaml_1.default.parse(fs_1.default.readFileSync(flags.mapping, 'utf8'));
            }
            else {
                throw new Error('Passed metadata file does not exist');
            }
        }
        else {
            mappings = yaml_1.default.parse(flags.format === 'disa' ? files_json_1.default['disa.mapping.yml'].data : files_json_1.default['cis.mapping.yml'].data);
        }
        const inspecControls = [];
        // Convert profile inspec.yml
        const profileInfo = {
            name: 'CIS Benchmark',
            title: 'InSpec Profile',
            maintainer: metadata.maintainer || 'The Authors',
            copyright: metadata.copyright || 'The Authors',
            copyright_email: metadata.copyright_email || 'you@example.com',
            license: metadata.license || 'Apache-2.0',
            summary: '"An InSpec Compliance Profile"',
            version: metadata.version || '0.1.0',
        };
        fs_1.default.writeFileSync(path_1.default.join(flags.output, 'inspec.yml'), yaml_1.default.stringify(profileInfo));
        // Write README.md
        const readableMetadata = {};
        Object.entries(profileInfo).forEach(([key, value]) => {
            // Filter out any undefined values and omit summary and title
            if (value && key !== 'summary' && key !== 'summary') {
                readableMetadata[lodash_1.default.startCase(key)] = value;
            }
        });
        fs_1.default.writeFileSync(path_1.default.join(flags.output, 'README.md'), `# ${profileInfo.name}\n${profileInfo.summary}\n---\n${yaml_1.default.stringify(readableMetadata)}`);
        await xlsx_populate_1.default.fromFileAsync(flags.input).then((workBook) => {
            const completedIds = []; // Numbers such as 1.10 can get parsed 1.1 which will over-write controls, keep track of existing controls to prevent this
            workBook.sheets().forEach((sheet) => {
                const usedRange = sheet.usedRange();
                if (usedRange) {
                    // Get data from the spreadsheet into a 2D array
                    const extractedData = usedRange.value();
                    // Map the data into an object array
                    const headers = extractedData[0];
                    const mappedRecords = extractedData.slice(1).map(record => {
                        const mappedRecord = {};
                        record.forEach((record, index) => {
                            if (typeof record === 'string') {
                                mappedRecord[headers[index]] = record;
                            }
                            if (typeof record === 'number') {
                                mappedRecord[headers[index]] = record.toString();
                            }
                        });
                        return mappedRecord;
                    });
                    // Convert the mapped objects into controls
                    mappedRecords.forEach((record, index) => {
                        // Get the control ID
                        let controlId = (0, global_1.extractValueViaPathOrNumber)('mappings.id', mappings.id, record);
                        if (controlId) {
                            // Prevent controls that get parsed from 1.10 to 1.1 from being over-written, this assumes the controls are in order
                            while (completedIds.includes(controlId)) {
                                controlId += '0';
                            }
                            completedIds.push(controlId);
                            let newControl = {
                                refs: [],
                                tags: {
                                    nist: [],
                                    severity: (0, xccdf2inspec_1.impactNumberToSeverityString)((0, global_1.extractValueViaPathOrNumber)('mappings.impact', mappings.impact, record)),
                                },
                            };
                            Object.entries(mappings).forEach(mapping => {
                                if (mapping[0] === 'id' && flags.controlNamePrefix) {
                                    lodash_1.default.set(newControl, mapping[0].toLowerCase().replace('desc.', 'descs.'), `${flags.controlNamePrefix ? flags.controlNamePrefix + '-' : ''}${(0, global_1.extractValueViaPathOrNumber)(mapping[0], mapping[1], record)}`);
                                }
                                else {
                                    lodash_1.default.set(newControl, mapping[0].toLowerCase().replace('desc.', 'descs.'), (0, global_1.extractValueViaPathOrNumber)(mapping[0], mapping[1], record));
                                }
                            });
                            newControl = this.matchReferences(newControl);
                            newControl = this.matchCISControls(newControl, flags);
                            newControl = this.matchImpactFromSeverityIfImpactNotSet(newControl);
                            newControl = this.extractCCIsFromText(newControl);
                            inspecControls.push(newControl);
                        }
                        else {
                            // Possibly a section divider, possibly a bad mapping. Let the user know to verify
                            console.error(`Control at index "${index}" has no ID... skipping`);
                        }
                    });
                }
            });
        }).catch(() => {
            // Assume we have a CSV file
            // Read the input file into lines
            const inputDataLines = fs_1.default.readFileSync(flags.input, 'utf8').split('\n');
            // Replace BOM if it exists
            inputDataLines[0] = inputDataLines[0].replaceAll('\u{FEFF}', '');
            // STIG Viewer embeds the classification level in the first and last line for CSV export, breaking parsing
            if (/~~~~~.*~~~~~/.test(inputDataLines[0])) {
                inputDataLines.shift();
            }
            if (/~~~~~.*~~~~~/.test(inputDataLines.at(-1) || '')) {
                inputDataLines.pop();
            }
            const records = (0, sync_1.default)(inputDataLines.join('\n'), {
                columns: true,
                skip_empty_lines: true,
            });
            records.forEach((record, index) => {
                let skipControlDueToError = false;
                let newControl = {
                    refs: [],
                    tags: {
                        nist: [],
                        severity: (0, xccdf2inspec_1.impactNumberToSeverityString)((0, global_1.extractValueViaPathOrNumber)('mappings.impact', mappings.impact, record)),
                    },
                };
                Object.entries(mappings).forEach(mapping => {
                    if (mapping[0] === 'id') {
                        const value = (0, global_1.extractValueViaPathOrNumber)(mapping[0], mapping[1], record);
                        if (value) {
                            lodash_1.default.set(newControl, mapping[0], `${flags.controlNamePrefix ? flags.controlNamePrefix + '-' : ''}${value}`);
                        }
                        else {
                            console.error(`Control at index ${index} has no mapped control ID... skipping`);
                            skipControlDueToError = true;
                        }
                    }
                    else {
                        lodash_1.default.set(newControl, mapping[0].toLowerCase().replace('desc.', 'descs.'), (0, global_1.extractValueViaPathOrNumber)(mapping[0], mapping[1], record));
                    }
                });
                if (skipControlDueToError) {
                    return;
                }
                if (newControl.tags && newControl.tags?.cci) {
                    newControl.tags.nist = [];
                    newControl.tags.cci.forEach(cci => {
                        if (cci in hdf_converters_1.CciNistMappingData.data) {
                            newControl.tags?.nist?.push(lodash_1.default.get(hdf_converters_1.CciNistMappingData.data, cci));
                        }
                    });
                }
                newControl = this.matchReferences(newControl);
                newControl = this.matchCISControls(newControl, flags);
                newControl = this.matchImpactFromSeverityIfImpactNotSet(newControl);
                newControl = this.extractCCIsFromText(newControl);
                inspecControls.push(newControl);
            });
        });
        // Convert all extracted controls to Ruby/InSpec code
        inspecControls.forEach(control => {
            fs_1.default.writeFileSync(path_1.default.join(flags.output, 'controls', control.id + '.rb'), (0, xccdf2inspec_1.inspecControlToRubyCode)(control, flags.lineLength, flags.encodingHeader));
        });
    }
}
exports.default = Spreadsheet2HDF;
//# sourceMappingURL=spreadsheet2inspec_stub.js.map