"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const hdf_converters_1 = require("@mitre/hdf-converters");
const core_1 = require("@oclif/core");
const global_1 = require("../../utils/global");
const logging_1 = require("../../utils/logging");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
class IonChannel2HDF extends core_1.Command {
    static usage = 'convert ionchannel2hdf -o <hdf-output-folder> [-h] (-i <ionchannel-json>... | -a <api-key> -t <team-name> [--raw ] [-p <project>...] [-A ]) [-L info|warn|debug|verbose]';
    static description = 'Pull and translate SBOM data from Ion Channel into Heimdall Data Format';
    static flags = {
        help: core_1.Flags.help({ char: 'h' }),
        input: core_1.Flags.string({
            char: 'i',
            description: 'Input IonChannel JSON file',
            multiple: true,
            exclusive: ['apiKey'],
        }),
        apiKey: core_1.Flags.string({
            char: 'a',
            description: 'API Key from Ion Channel user settings',
            dependsOn: ['teamName'],
        }),
        teamName: core_1.Flags.string({
            char: 't',
            description: 'Your team name that contains the project(s) you would like to pull data from',
            dependsOn: ['apiKey'],
        }),
        output: core_1.Flags.string({
            char: 'o',
            required: true,
            description: 'Output JSON folder',
        }),
        raw: core_1.Flags.boolean({
            description: 'Output Ion Channel raw data',
            dependsOn: ['apiKey'],
        }),
        project: core_1.Flags.string({
            char: 'p',
            description: 'The name of the project(s) you would like to pull',
            multiple: true,
            dependsOn: ['apiKey'],
        }),
        allProjects: core_1.Flags.boolean({
            char: 'A',
            description: 'Pull all projects available within your team',
            dependsOn: ['apiKey'],
        }),
        logLevel: core_1.Flags.string({
            char: 'L',
            default: 'info',
            options: ['info', 'warn', 'debug', 'verbose'],
        }),
    };
    async run() {
        const { flags } = await this.parse(IonChannel2HDF);
        const logger = (0, logging_1.createWinstonLogger)('IonChannel2HDF', flags.logLevel);
        if (!Array.isArray(flags.input) && !(flags.apiKey && flags.teamName)) {
            throw new Error('Please either provide a list of input files or set the api key and the team name.');
        }
        if (flags.apiKey && flags.teamName && flags.allProjects) {
            logger.debug('Creating Ion Channel API Client');
            const apiClient = new hdf_converters_1.IonChannelAPIMapper(flags.apiKey);
            logger.debug(`Setting team to ${flags.teamName}`);
            await apiClient.setTeam(flags.teamName);
            logger.debug(`Set team to ID ${apiClient.teamId}`);
            fs_1.default.mkdirSync(flags.output);
            const availableProjects = await apiClient.getProjects();
            for (const project of availableProjects) {
                logger.info(`Pulling findings from ${project.name}`);
                apiClient.projectId = project.id;
                apiClient.analysisId = project.analysis_summary.analysis_id;
                let filename = '';
                let json = {};
                if (flags.raw) {
                    filename = project.name + '_raw.json';
                    json = await apiClient.getAnalysis().then(({ analysis }) => analysis);
                }
                else {
                    filename = project.name + '.json';
                    json = await apiClient.toHdf();
                }
                fs_1.default.writeFileSync(path_1.default.join(flags.output, filename), JSON.stringify(json, null, 2));
            }
        }
        else if (flags.apiKey && flags.teamName && Array.isArray(flags.project)) {
            logger.debug('Creating Ion Channel API Client');
            const apiClient = new hdf_converters_1.IonChannelAPIMapper(flags.apiKey);
            logger.debug(`Setting team to ${flags.teamName}`);
            await apiClient.setTeam(flags.teamName);
            logger.debug(`Set team to ID ${apiClient.teamId}`);
            fs_1.default.mkdirSync(flags.output);
            for (const projectName of flags.project) {
                logger.info(`Pulling findings from ${projectName}`);
                await apiClient.setProject(projectName);
                logger.debug(`Set project ID ${apiClient.projectId}`);
                let filename = '';
                let json = {};
                if (flags.raw) {
                    filename = projectName + '_raw.json';
                    json = await apiClient.getAnalysis().then(({ analysis }) => analysis);
                }
                else {
                    filename = projectName + '.json';
                    json = await apiClient.toHdf();
                }
                fs_1.default.writeFileSync(path_1.default.join(flags.output, filename), JSON.stringify(json, null, 2));
            }
        }
        else if (Array.isArray(flags.input)) {
            logger.debug('Processing input files');
            fs_1.default.mkdirSync(flags.output);
            for (const filename of flags.input) {
                // Check for correct input type
                const data = fs_1.default.readFileSync(filename, 'utf8');
                (0, global_1.checkInput)({ data: data, filename: filename }, 'ionchannel', 'IonChannel JSON');
                logger.debug(`Processing...${filename}`);
                fs_1.default.writeFileSync(path_1.default.join(flags.output, (0, global_1.checkSuffix)((0, global_1.convertFullPathToFilename)(filename))), JSON.stringify((new hdf_converters_1.IonChannelMapper(data)).toHdf()));
            }
        }
        else {
            throw new TypeError('Please provide a list of input files, a list of projects, or use the --allProjects flag.');
        }
    }
}
exports.default = IonChannel2HDF;
//# sourceMappingURL=ionchannel2hdf.js.map