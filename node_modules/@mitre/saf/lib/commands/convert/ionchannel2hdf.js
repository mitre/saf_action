"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const hdf_converters_1 = require("@mitre/hdf-converters");
const core_1 = require("@oclif/core");
const global_1 = require("../../utils/global");
const logging_1 = require("../../utils/logging");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
class IonChannel2HDF extends core_1.Command {
    async run() {
        const { flags } = await this.parse(IonChannel2HDF);
        const logger = (0, logging_1.createWinstonLogger)('IonChannel2HDF', flags.logLevel);
        if (!Array.isArray(flags.input) && !(flags.apiKey && flags.teamName)) {
            throw new Error('Please either provide a list of input files or set the api key and the team name.');
        }
        if (flags.apiKey && flags.teamName && flags.allProjects) {
            logger.debug('Creating Ion Channel API Client');
            const apiClient = new hdf_converters_1.IonChannelAPIMapper(flags.apiKey);
            logger.debug(`Setting team to ${flags.teamName}`);
            await apiClient.setTeam(flags.teamName);
            logger.debug(`Set team to ID ${apiClient.teamId}`);
            fs_1.default.mkdirSync(flags.output);
            const availableProjects = await apiClient.getProjects();
            for (const project of availableProjects) {
                logger.info(`Pulling findings from ${project.name}`);
                apiClient.projectId = project.id;
                apiClient.analysisId = project.analysis_summary.analysis_id;
                let filename = '';
                let json = {};
                if (flags.raw) {
                    filename = project.name + '_raw.json';
                    json = await apiClient.getAnalysis().then(({ analysis }) => analysis);
                }
                else {
                    filename = project.name + '.json';
                    json = await apiClient.toHdf();
                }
                fs_1.default.writeFileSync(path_1.default.join(flags.output, filename), JSON.stringify(json));
            }
        }
        else if (flags.apiKey && flags.teamName && Array.isArray(flags.project)) {
            logger.debug('Creating Ion Channel API Client');
            const apiClient = new hdf_converters_1.IonChannelAPIMapper(flags.apiKey);
            logger.debug(`Setting team to ${flags.teamName}`);
            await apiClient.setTeam(flags.teamName);
            logger.debug(`Set team to ID ${apiClient.teamId}`);
            fs_1.default.mkdirSync(flags.output);
            for (const projectName of flags.project) {
                logger.info(`Pulling findings from ${projectName}`);
                await apiClient.setProject(projectName);
                logger.debug(`Set project ID ${apiClient.projectId}`);
                let filename = '';
                let json = {};
                if (flags.raw) {
                    filename = projectName + '_raw.json';
                    json = await apiClient.getAnalysis().then(({ analysis }) => analysis);
                }
                else {
                    filename = projectName + '.json';
                    json = await apiClient.toHdf();
                }
                fs_1.default.writeFileSync(path_1.default.join(flags.output, filename), JSON.stringify(json));
            }
        }
        else if (Array.isArray(flags.input)) {
            logger.debug('Processing input files');
            fs_1.default.mkdirSync(flags.output);
            for (const filename of flags.input) {
                logger.debug(`Processing...${filename}`);
                fs_1.default.writeFileSync(path_1.default.join(flags.output, (0, global_1.checkSuffix)((0, global_1.convertFullPathToFilename)(filename))), JSON.stringify((new hdf_converters_1.IonChannelMapper(fs_1.default.readFileSync(filename, 'utf8'))).toHdf()));
            }
        }
        else {
            throw new TypeError('Please provide a list of input files, a list of projects, or use the --allProjects flag.');
        }
    }
}
exports.default = IonChannel2HDF;
IonChannel2HDF.usage = 'convert ionchannel2hdf -i, --input <ionchannel-results-json> -a, --apiKey -t, --team <team-name> -o, --output <output-folder> --raw -p, --project <project-name> -A, --allProjects (true/false)';
IonChannel2HDF.description = 'Pull and translate SBOM data from Ion Channel into Heimdall Data Format';
IonChannel2HDF.flags = {
    help: core_1.Flags.help({ char: 'h' }),
    input: core_1.Flags.string({
        char: 'i',
        description: 'Input IonChannel JSON file',
        multiple: true,
        exclusive: ['apiKey'],
    }),
    apiKey: core_1.Flags.string({
        char: 'a',
        description: 'API Key from Ion Channel user settings',
        dependsOn: ['teamName'],
    }),
    teamName: core_1.Flags.string({
        char: 't',
        description: 'Your team name that contains the project(s) you would like to pull data from',
        dependsOn: ['apiKey'],
    }),
    output: core_1.Flags.string({
        char: 'o',
        required: true,
        description: 'Output JSON folder',
    }),
    raw: core_1.Flags.boolean({
        description: 'Output Ion Channel raw data',
        dependsOn: ['apiKey'],
    }),
    project: core_1.Flags.string({
        char: 'p',
        description: 'The name of the project(s) you would like to pull',
        multiple: true,
        dependsOn: ['apiKey'],
    }),
    allProjects: core_1.Flags.boolean({
        char: 'A',
        description: 'Pull all projects available within your team',
        dependsOn: ['apiKey'],
    }),
    logLevel: core_1.Flags.string({
        char: 'L',
        default: 'info',
        options: ['info', 'warn', 'debug', 'verbose'],
    }),
};
