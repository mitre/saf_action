"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const hdf_converters_1 = require("@mitre/hdf-converters");
const fs_1 = tslib_1.__importDefault(require("fs"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const global_1 = require("../../utils/global");
const path_1 = tslib_1.__importDefault(require("path"));
const asff2hdf_1 = tslib_1.__importDefault(require("./asff2hdf"));
const core_1 = require("@oclif/core");
const zap2hdf_1 = tslib_1.__importDefault(require("./zap2hdf"));
function getInputFilename() {
    const inputFileIndex = process.argv.findIndex(param => param.toLowerCase() === '-i' || param.toLowerCase() === '--input');
    if (inputFileIndex === -1) {
        return process.env.INPUT_FILE || '';
    }
    return process.argv[inputFileIndex + 1];
}
class Convert extends core_1.Command {
    static description = 'The generic convert command translates any supported file-based security results set into the Heimdall Data Format';
    static examples = ['saf convert -i input -o output'];
    static flags = {
        input: core_1.Flags.string({ char: 'i', required: true, description: 'Input results set file' }),
        output: core_1.Flags.string({ char: 'o', required: true, description: 'Output results sets' }),
        ...Convert.getFlagsForInputFile(getInputFilename()),
    };
    static getFlagsForInputFile(filePath) {
        if (filePath) {
            Convert.detectedType = (0, hdf_converters_1.fingerprint)({ data: fs_1.default.readFileSync(filePath, 'utf8'), filename: (0, global_1.convertFullPathToFilename)(filePath) });
            switch (Convert.detectedType) { // skipcq: JS-0047
                case 'asff': {
                    return asff2hdf_1.default.flags;
                }
                case 'zap': {
                    return zap2hdf_1.default.flags;
                }
                case 'burp':
                case 'dbProtect':
                case 'fortify':
                case 'jfrog':
                case 'nessus':
                case 'netsparker':
                case 'nikto':
                case 'prisma':
                case 'sarif':
                case 'scoutsuite':
                case 'snyk':
                case 'twistlock':
                case 'xccdf': {
                    return {};
                }
            }
        }
        return {};
    }
    static detectedType;
    async run() {
        const { flags } = await this.parse(Convert);
        let converter;
        switch (Convert.detectedType) {
            case 'asff': {
                let securityhub = lodash_1.default.get(flags, 'securityhub');
                if (securityhub) {
                    securityhub = securityhub.map(file => fs_1.default.readFileSync(file, 'utf8'));
                }
                converter = new hdf_converters_1.ASFFResults(fs_1.default.readFileSync(flags.input, 'utf8'), securityhub);
                const results = converter.toHdf();
                fs_1.default.mkdirSync(flags.output);
                lodash_1.default.forOwn(results, (result, filename) => {
                    fs_1.default.writeFileSync(path_1.default.join(flags.output, (0, global_1.checkSuffix)(filename)), JSON.stringify(result));
                });
                break;
            }
            case 'burp': {
                converter = new hdf_converters_1.BurpSuiteMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf()));
                break;
            }
            case 'dbProtect': {
                converter = new hdf_converters_1.DBProtectMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf()));
                break;
            }
            case 'fortify': {
                converter = new hdf_converters_1.FortifyMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf()));
                break;
            }
            case 'jfrog': {
                converter = new hdf_converters_1.JfrogXrayMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf()));
                break;
            }
            case 'nessus': {
                converter = new hdf_converters_1.NessusResults(fs_1.default.readFileSync(flags.input, 'utf8'));
                const result = converter.toHdf();
                if (Array.isArray(result)) {
                    for (const element of result) {
                        fs_1.default.writeFileSync(`${flags.output.replaceAll(/\.json/gi, '')}-${lodash_1.default.get(element, 'platform.target_id')}.json`, JSON.stringify(element));
                    }
                }
                else {
                    fs_1.default.writeFileSync(`${(0, global_1.checkSuffix)(flags.output)}`, JSON.stringify(result));
                }
                break;
            }
            case 'netsparker': {
                converter = new hdf_converters_1.NetsparkerMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf()));
                break;
            }
            case 'nikto': {
                converter = new hdf_converters_1.NiktoMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf()));
                break;
            }
            case 'prisma': {
                converter = new hdf_converters_1.PrismaMapper(fs_1.default.readFileSync(flags.input, { encoding: 'utf8' }));
                const results = converter.toHdf();
                fs_1.default.mkdirSync(flags.output);
                lodash_1.default.forOwn(results, result => {
                    fs_1.default.writeFileSync(path_1.default.join(flags.output, `${lodash_1.default.get(result, 'platform.target_id')}.json`), JSON.stringify(result));
                });
                break;
            }
            case 'sarif': {
                converter = new hdf_converters_1.SarifMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf()));
                break;
            }
            case 'scoutsuite': {
                converter = new hdf_converters_1.ScoutsuiteMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf()));
                break;
            }
            case 'snyk': {
                converter = new hdf_converters_1.SnykResults(fs_1.default.readFileSync(flags.input, 'utf8'));
                const result = converter.toHdf();
                if (Array.isArray(result)) {
                    for (const element of result) {
                        fs_1.default.writeFileSync(`${flags.output.replaceAll(/\.json/gi, '')}-${lodash_1.default.get(element, 'platform.target_id')}.json`, JSON.stringify(element));
                    }
                }
                else {
                    fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(result));
                }
                break;
            }
            case 'twistlock': {
                converter = new hdf_converters_1.TwistlockResults(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf()));
                break;
            }
            case 'xccdf': {
                converter = new hdf_converters_1.XCCDFResultsMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf()));
                break;
            }
            case 'zap': {
                converter = new hdf_converters_1.ZapMapper(fs_1.default.readFileSync(flags.input, 'utf8'), lodash_1.default.get(flags, 'name'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf()));
                break;
            }
            default: {
                throw new Error(`Unknown filetype provided: ${getInputFilename()}
        The generic convert command should only be used for taking supported file-based security results and converting into Heimdall Data Format
        For more information, run "saf convert --help"`);
            }
        }
    }
}
exports.default = Convert;
