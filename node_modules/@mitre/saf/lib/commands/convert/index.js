"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable complexity */
const fs_1 = tslib_1.__importDefault(require("fs"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const path_1 = tslib_1.__importDefault(require("path"));
const hdf_converters_1 = require("@mitre/hdf-converters");
const core_1 = require("@oclif/core");
const global_1 = require("../../utils/global");
const baseCommand_1 = require("../../utils/oclif/baseCommand");
const asff2hdf_1 = tslib_1.__importDefault(require("./asff2hdf"));
const zap2hdf_1 = tslib_1.__importDefault(require("./zap2hdf"));
function getInputFilename() {
    const inputFileIndex = process.argv.findIndex(param => param.toLowerCase() === '-i' || param.toLowerCase() === '--input');
    if (inputFileIndex === -1) {
        return process.env.INPUT_FILE ?? '';
    }
    return process.argv[inputFileIndex + 1];
}
// export default class Convert extends Command {
class Convert extends baseCommand_1.BaseCommand {
    static description = 'The generic convert command translates any supported file-based security results set into the Heimdall Data Format';
    static examples = ['<%= config.bin %> <%= command.id %> -i input -o output'];
    static flags = {
        input: core_1.Flags.string({
            char: 'i',
            required: true,
            description: 'Input results set file',
        }),
        output: core_1.Flags.string({
            char: 'o',
            required: true,
            description: 'Output results sets',
        }),
        ...Convert.getFlagsForInputFile(getInputFilename()),
    };
    static detectedType;
    static getFlagsForInputFile(filePath) {
        if (filePath) {
            Convert.detectedType = (0, hdf_converters_1.fingerprint)({
                data: fs_1.default.readFileSync(filePath, 'utf8'),
                filename: (0, global_1.basename)(filePath),
            });
            switch (Convert.detectedType // skipcq: JS-0047
            ) {
                case 'asff': {
                    return asff2hdf_1.default.flags;
                }
                case 'zap': {
                    return zap2hdf_1.default.flags;
                }
                // catch all other cases:
                // 'anchoregrype', 'burp', 'conveyor' 'checklist', 'dbProtect', 'dependencyTrack', 'fortify',
                // 'jfrog', 'msft_secure_score', 'nessus', 'netsparker', 'neuvector' 'nikto',
                // 'prisma', 'sarif', 'cyclonedx_sbom', 'scoutsuite', 'snyk', 'trufflehog',
                // 'twistlock', 'xccdf'
                default: {
                    return {};
                }
            }
        }
        return {};
    }
    // skipcq: JS-R1005
    async run() {
        // skipcq: JS-0044
        const { flags } = await this.parse(Convert);
        let converter;
        switch (Convert.detectedType) {
            case 'anchoregrype': {
                converter = new hdf_converters_1.AnchoreGrypeMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'asff': {
                const securityhub = lodash_1.default.get(flags, 'securityhub');
                const files = securityhub?.map(file => fs_1.default.readFileSync(file, 'utf8'));
                converter = new hdf_converters_1.ASFFResults(fs_1.default.readFileSync(flags.input, 'utf8'), files);
                const results = converter.toHdf();
                fs_1.default.mkdirSync(flags.output);
                lodash_1.default.forOwn(results, (result, filename) => {
                    fs_1.default.writeFileSync(path_1.default.join(flags.output, (0, global_1.checkSuffix)((0, global_1.basename)(filename))), JSON.stringify(result, null, 2));
                });
                break;
            }
            case 'burp': {
                converter = new hdf_converters_1.BurpSuiteMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'conveyor': {
                converter = new hdf_converters_1.ConveyorResults(fs_1.default.readFileSync(flags.input, 'utf8'));
                const results = converter.toHdf();
                fs_1.default.mkdirSync(flags.output);
                for (const [filename, result] of Object.entries(results)) {
                    fs_1.default.writeFileSync(path_1.default.join(flags.output, (0, global_1.checkSuffix)((0, global_1.basename)(filename))), JSON.stringify(result, null, 2));
                }
                break;
            }
            case 'checklist': {
                converter = new hdf_converters_1.ChecklistResults(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'dbProtect': {
                converter = new hdf_converters_1.DBProtectMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'dependencyTrack': {
                converter = new hdf_converters_1.DependencyTrackMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'cyclonedx_sbom': {
                converter = new hdf_converters_1.CycloneDXSBOMResults(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'fortify': {
                converter = new hdf_converters_1.FortifyMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'jfrog': {
                converter = new hdf_converters_1.JfrogXrayMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'msft_secure_score': {
                converter = new hdf_converters_1.MsftSecureScoreMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'nessus': {
                converter = new hdf_converters_1.NessusResults(fs_1.default.readFileSync(flags.input, 'utf8'));
                const result = converter.toHdf();
                const pluralResults = Array.isArray(result) ? result : [];
                const singularResult = pluralResults.length === 0;
                for (const element of pluralResults) {
                    fs_1.default.writeFileSync(`${flags.output.replaceAll(/\.json/gi, '')}-${(0, global_1.basename)(lodash_1.default.get(element, 'platform.target_id') || '')}.json`, JSON.stringify(element, null, 2));
                }
                if (singularResult) {
                    fs_1.default.writeFileSync(`${(0, global_1.checkSuffix)(flags.output)}`, JSON.stringify(result, null, 2));
                }
                break;
            }
            case 'neuvector': {
                converter = new hdf_converters_1.NeuVectorMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'netsparker': {
                converter = new hdf_converters_1.NetsparkerMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'nikto': {
                converter = new hdf_converters_1.NiktoMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'prisma': {
                converter = new hdf_converters_1.PrismaMapper(fs_1.default.readFileSync(flags.input, { encoding: 'utf8' }));
                const results = converter.toHdf();
                fs_1.default.mkdirSync(flags.output);
                lodash_1.default.forOwn(results, (result) => {
                    fs_1.default.writeFileSync(path_1.default.join(flags.output, (0, global_1.basename)(`${lodash_1.default.get(result, 'platform.target_id')}.json`)), JSON.stringify(result, null, 2));
                });
                break;
            }
            case 'sarif': {
                converter = new hdf_converters_1.SarifMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'scoutsuite': {
                converter = new hdf_converters_1.ScoutsuiteMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'snyk': {
                converter = new hdf_converters_1.SnykResults(fs_1.default.readFileSync(flags.input, 'utf8'));
                const result = converter.toHdf();
                const pluralResults = Array.isArray(result) ? result : [];
                const singularResult = pluralResults.length === 0;
                for (const element of pluralResults) {
                    fs_1.default.writeFileSync(`${flags.output.replaceAll(/\.json/gi, '')}-${(0, global_1.basename)(lodash_1.default.get(element, 'platform.target_id') || '')}.json`, JSON.stringify(element, null, 2));
                }
                if (singularResult) {
                    fs_1.default.writeFileSync(`${(0, global_1.checkSuffix)(flags.output)}`, JSON.stringify(result, null, 2));
                }
                break;
            }
            case 'trufflehog': {
                converter = new hdf_converters_1.TrufflehogResults(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'twistlock': {
                converter = new hdf_converters_1.TwistlockResults(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'xccdf': {
                converter = new hdf_converters_1.XCCDFResultsMapper(fs_1.default.readFileSync(flags.input, 'utf8'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            case 'zap': {
                converter = new hdf_converters_1.ZapMapper(fs_1.default.readFileSync(flags.input, 'utf8'), lodash_1.default.get(flags, 'name'));
                fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(converter.toHdf(), null, 2));
                break;
            }
            default: {
                throw new Error(`Unknown filetype provided: ${getInputFilename()}
        The generic convert command should only be used for taking supported file-based security results and converting into Heimdall Data Format
        For more information, run "saf convert --help"`);
            }
        }
    }
}
exports.default = Convert;
//# sourceMappingURL=index.js.map