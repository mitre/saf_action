"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const fs_1 = tslib_1.__importDefault(require("fs"));
const hdf_converters_1 = require("@mitre/hdf-converters");
const global_1 = require("../../utils/global");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const path_1 = tslib_1.__importDefault(require("path"));
const client_securityhub_1 = require("@aws-sdk/client-securityhub");
const node_http_handler_1 = require("@smithy/node-http-handler");
const https_1 = tslib_1.__importDefault(require("https"));
const logging_1 = require("../../utils/logging");
// Should be no more than 100
const API_MAX_RESULTS = 100;
class ASFF2HDF extends core_1.Command {
    static usage = 'convert asff2hdf -o <hdf-output-folder> [-h] (-i <asff-json> [--securityhub <standard-json>...] | -a -r <region> [-I | -C <certificate>] [-t <target>...]) [-L info|warn|debug|verbose]';
    static description = 'Translate a AWS Security Finding Format JSON into a Heimdall Data Format JSON file(s)';
    static examples = [
        'saf convert asff2hdf -i asff-findings.json -o output-folder-name',
        'saf convert asff2hdf -i asff-findings.json --securityhub standard-1.json standard-2.json -o output-folder-name',
        'saf convert asff2hdf --aws -o out -r us-west-2 --target rhel7',
    ];
    static flags = {
        help: core_1.Flags.help({ char: 'h' }),
        input: core_1.Flags.string({ char: 'i', required: false, description: 'Input ASFF JSON file', exclusive: ['aws', 'region', 'insecure', 'certificate', 'target'] }),
        aws: core_1.Flags.boolean({ char: 'a', required: false, description: 'Pull findings from AWS Security Hub', exclusive: ['input'], dependsOn: ['region'] }),
        region: core_1.Flags.string({ char: 'r', required: false, description: 'Security Hub region to pull findings from', exclusive: ['input'] }),
        insecure: core_1.Flags.boolean({ char: 'I', required: false, default: false, description: 'Disable SSL verification, this is insecure.', exclusive: ['input', 'certificate'] }),
        securityhub: core_1.Flags.string({ required: false, multiple: true, description: 'Additional input files to provide context that an ASFF file needs such as the CIS AWS Foundations or AWS Foundational Security Best Practices documents (in ASFF compliant JSON form)' }),
        output: core_1.Flags.string({ char: 'o', required: true, description: 'Output HDF JSON folder' }),
        certificate: core_1.Flags.string({ char: 'C', required: false, description: 'Trusted signing certificate file', exclusive: ['input', 'insecure'] }),
        logLevel: core_1.Flags.string({ char: 'L', required: false, default: 'info', options: ['info', 'warn', 'debug', 'verbose'] }),
        target: core_1.Flags.string({ char: 't', required: false, multiple: true, description: 'Target ID(s) to pull from Security Hub (maximum 10), leave blank for non-HDF findings', exclusive: ['input'] }),
    };
    async run() {
        const { flags } = await this.parse(ASFF2HDF);
        const logger = (0, logging_1.createWinstonLogger)('asff2hdf', flags.logLevel);
        let securityhub;
        // Check if output folder already exists
        if (fs_1.default.existsSync(flags.output)) {
            throw new Error(`Output folder ${flags.output} already exists`);
        }
        const findings = [];
        // If we've been passed an input file
        if (flags.input) {
            const data = fs_1.default.readFileSync(flags.input, 'utf8');
            // Attempt to convert to one finding per line
            try {
                const convertedJson = JSON.parse(data);
                if (Array.isArray(convertedJson)) {
                    findings.push(...convertedJson.map(finding => JSON.stringify(finding)));
                }
                else if ('Findings' in convertedJson) {
                    findings.push(...convertedJson.Findings.map((finding) => JSON.stringify(finding)));
                }
                else if ('Controls' in convertedJson) {
                    throw new Error('Invalid ASFF findings format - a standards standards was passed to --input instead of --securityhub');
                }
                else {
                    (0, global_1.checkInput)({ data: data, filename: flags.input }, 'asff', 'AWS Security Finding Format JSON');
                }
            }
            catch (error) {
                const splitLines = data.split('\n');
                if (splitLines.length === 0) {
                    logger.error('Invalid ASFF findings format - no lines found');
                    throw error;
                }
                try {
                    findings.push(...splitLines.map(finding => JSON.stringify(JSON.parse(finding))));
                }
                catch (error) {
                    logger.error('Invalid ASFF findings format - unable to parse JSON');
                    throw error;
                }
            }
            // If we've been passed any Security Standards JSONs
            if (flags.securityhub) {
                securityhub = flags.securityhub.map((file) => fs_1.default.readFileSync(file, 'utf8'));
            }
        }
        else if (flags.aws) { // Flag to pull findings from AWS Security Hub
            const clientOptions = {
                region: flags.region,
                requestHandler: new node_http_handler_1.NodeHttpHandler({
                    httpsAgent: new https_1.default.Agent({
                        // Disable HTTPS verification if requested
                        rejectUnauthorized: !flags.insecure,
                        // Pass an SSL certificate to trust
                        ca: flags.certificate ? fs_1.default.readFileSync(flags.certificate, 'utf8') : undefined,
                    }),
                }),
            };
            // Create our SecurityHub client
            const client = new client_securityhub_1.SecurityHub(clientOptions);
            // Pagination
            let nextToken;
            let first = true;
            let filters = {};
            // Filter by target name
            if (flags.target) {
                filters = {
                    Id: flags.target.map((target) => {
                        return { Value: target, Comparison: 'PREFIX' };
                    }),
                };
            }
            logger.info('Starting collection of Findings');
            let queryParams = { Filters: filters, MaxResults: API_MAX_RESULTS };
            // Get findings
            while (first || nextToken !== undefined) {
                first = false;
                logger.debug(`Querying for NextToken: ${nextToken}`);
                lodash_1.default.set(queryParams, 'NextToken', nextToken);
                const getFindingsResult = await client.getFindings(queryParams);
                logger.debug(`Received: ${getFindingsResult.Findings?.length} findings`);
                if (getFindingsResult.Findings) {
                    findings.push(...getFindingsResult.Findings.map(finding => JSON.stringify(finding)));
                }
                nextToken = getFindingsResult.NextToken;
            }
            nextToken = undefined;
            first = true;
            logger.info('Starting collection of enabled security standards');
            const enabledStandards = [];
            queryParams = lodash_1.default.omit(queryParams, ['Filters']);
            // Get active security standards subscriptions (enabled standards)
            while (first || nextToken !== undefined) {
                first = false;
                logger.debug(`Querying for NextToken: ${nextToken}`);
                // type system seems to think that this call / the result is from the callback variant of the function instead of the promise based one and throwing fits
                const getEnabledStandardsResult = (await client.getEnabledStandards({ NextToken: nextToken }));
                logger.debug(`Received: ${getEnabledStandardsResult.StandardsSubscriptions?.length} standards`);
                if (getEnabledStandardsResult.StandardsSubscriptions) {
                    enabledStandards.push(...getEnabledStandardsResult.StandardsSubscriptions);
                }
                nextToken = getEnabledStandardsResult.NextToken;
            }
            securityhub = [];
            // Describe the controls to give context to the mapper
            for (const standard of enabledStandards) {
                nextToken = undefined;
                first = true;
                const standardsControls = [];
                while (nextToken !== undefined) {
                    first = false;
                    logger.debug(`Querying for NextToken: ${nextToken}`);
                    const getEnabledStandardsResult = await client.describeStandardsControls({
                        StandardsSubscriptionArn: standard.StandardsSubscriptionArn,
                        NextToken: nextToken || '',
                    });
                    logger.info(`Received: ${getEnabledStandardsResult.Controls?.length} Controls`);
                    if (getEnabledStandardsResult.Controls) {
                        standardsControls.push(...getEnabledStandardsResult.Controls);
                    }
                    nextToken = getEnabledStandardsResult.NextToken;
                }
                securityhub.push(JSON.stringify({ Controls: standardsControls }));
            }
        }
        else {
            throw new Error('Please select an input file or --aws to pull findings from AWS');
        }
        const converter = new hdf_converters_1.ASFFResults(findings.join('\n'), securityhub);
        const results = converter.toHdf();
        fs_1.default.mkdirSync(flags.output);
        lodash_1.default.forOwn(results, (result, filename) => {
            fs_1.default.writeFileSync(path_1.default.join(flags.output, (0, global_1.checkSuffix)(filename)), JSON.stringify(result));
        });
    }
}
exports.default = ASFF2HDF;
