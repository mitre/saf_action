"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const fs_1 = tslib_1.__importDefault(require("fs"));
const hdf_converters_1 = require("@mitre/hdf-converters");
const global_1 = require("../../utils/global");
const baseCommand_1 = require("../../utils/oclif/baseCommand");
class Sonarqube2HDF extends baseCommand_1.BaseCommand {
    static usage = '<%= command.id %> -n <sonar-project-key> -u <http://your.sonar.instance:9000> -a <your-sonar-api-key>'
        + '[ -b <target-branch> | -p <pull-request-id> ] [ -g <organization-name> ] -o <hdf-scan-results-json> [-h] [-w]';
    static description = 'Pull SonarQube vulnerabilities for the specified project name and optional branch \n'
        + 'or pull/merge request ID name from an API and convert into a Heimdall Data Format JSON file';
    static examples = ['<%= config.bin %> <%= command.id %> -n sonar_project_key -u http://sonar:9000 --auth abcdefg -p 123 -o scan_results.json -w'];
    static flags = {
        auth: core_1.Flags.string({
            char: 'a',
            required: true,
            description: 'SonarQube API Key / User Token - please ensure that the user has permissions for the project (including seeing the code)',
        }),
        projectKey: core_1.Flags.string({
            char: 'n',
            required: true,
            description: 'SonarQube Project Key',
        }),
        url: core_1.Flags.string({
            char: 'u',
            required: true,
            description: "SonarQube Base URL (excluding '/api')",
        }),
        branch: core_1.Flags.string({
            char: 'b',
            required: false,
            exclusive: ['pullRequestID'],
            description: 'Requires Sonarqube Developer Edition or above',
        }),
        pullRequestID: core_1.Flags.string({
            char: 'p',
            required: false,
            exclusive: ['branch'],
            description: 'Requires Sonarqube Developer Edition or above',
        }),
        organization: core_1.Flags.string({
            char: 'g',
            required: false,
            description: 'SonarQube organization name - used as a default when necessary to access rule descriptions',
        }),
        output: core_1.Flags.string({
            char: 'o',
            required: true,
            description: 'Output HDF JSON File',
        }),
        includeRaw: core_1.Flags.boolean({
            char: 'w',
            required: false,
            description: 'Include raw input requests in HDF JSON file',
        }),
    };
    async run() {
        const { flags } = await this.parse(Sonarqube2HDF);
        const converter = new hdf_converters_1.SonarqubeResults(flags.url, flags.projectKey, flags.auth, flags.branch, flags.pullRequestID, flags.organization, flags.includeRaw);
        fs_1.default.writeFileSync((0, global_1.checkSuffix)(flags.output), JSON.stringify(await converter.toHdf(), null, 2));
    }
}
exports.default = Sonarqube2HDF;
//# sourceMappingURL=sonarqube2hdf.js.map