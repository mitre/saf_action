"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const hdf_converters_1 = require("@mitre/hdf-converters");
class HDF2CKL extends core_1.Command {
    static usage = 'saf convert hdf2ckl -i <hdf-scan-results-json> -o <output-ckl> [-h] [-m <metadata>] [--profilename <value>] [--profiletitle <value>] [--version <value>] [--releasenumber <value>] [--releasedate <value>] [--marking <value>] [-H <value>] [-I <value>] [-M <value>] [-F <value>] [--targetcomment <value>] [--role Domain Controller|Member Server|None|Workstation] [--assettype Computing|Non-Computing] [--techarea |Application Review|Boundary Security|CDS Admin Review|CDS Technical Review|Database Review|Domain Name System (DNS)|Exchange Server|Host Based System Security (HBSS)|Internal Network|Mobility|Other Review|Releasable Networks (REL)|Releaseable Networks (REL)|Traditional Security|UNIX OS|VVOIP Review|Web Review|Windows OS] [--stigguid <value>] [--targetkey <value>] [--webdbsite <value> --webordatabase] [--webdbinstance <value> ] [--vulidmapping gid|id]';
    static description = 'Translate a Heimdall Data Format JSON file into a DISA checklist file';
    static flags = {
        help: core_1.Flags.help({ char: 'h' }),
        input: core_1.Flags.string({ char: 'i', required: true, description: 'Input HDF file' }),
        output: core_1.Flags.string({ char: 'o', required: true, description: 'Output CKL file' }),
        metadata: core_1.Flags.string({ char: 'm', required: false, description: 'Metadata JSON file, generate one with "saf generate ckl_metadata"',
            // either a metadata file or a metadata flags can be passed in. Not both.
            relationships: [
                { type: 'none', flags: ['profilename', 'profiletitle', 'version', 'releasenumber', 'releasedate', 'marking', 'marking', 'hostname', 'ip', 'mac', 'fqdn', 'targetcomment', 'role', 'assettype', 'techarea', 'stigguid', 'targetkey', 'webordatabase', 'webdbsite', 'webdbinstance', 'vulidmapping'] },
            ], helpGroup: 'Checklist Metadata' }),
        profilename: core_1.Flags.string({ required: false, description: 'Profile name', helpGroup: 'Checklist Metadata' }),
        profiletitle: core_1.Flags.string({ required: false, description: 'Profile title', helpGroup: 'Checklist Metadata' }),
        version: core_1.Flags.integer({ required: false, description: 'Profile version number', min: 0, helpGroup: 'Checklist Metadata' }),
        releasenumber: core_1.Flags.integer({ required: false, description: 'Profile release number', min: 0, helpGroup: 'Checklist Metadata' }),
        releasedate: core_1.Flags.string({ required: false, description: 'Profile release date', helpGroup: 'Checklist Metadata' }),
        marking: core_1.Flags.string({ required: false, description: 'A security classification or designation of the asset, indicating its sensitivity level', helpGroup: 'Checklist Metadata' }),
        hostname: core_1.Flags.string({ char: 'H', required: false, description: 'The name assigned to the asset within the network', helpGroup: 'Checklist Metadata' }),
        ip: core_1.Flags.string({ char: 'I', required: false, description: 'IP address', helpGroup: 'Checklist Metadata' }),
        mac: core_1.Flags.string({ char: 'M', required: false, description: 'MAC address', helpGroup: 'Checklist Metadata' }),
        fqdn: core_1.Flags.string({ char: 'F', required: false, description: 'Fully Qualified Domain Name', helpGroup: 'Checklist Metadata' }),
        targetcomment: core_1.Flags.string({ required: false, description: 'Additional comments or notes about the asset', helpGroup: 'Checklist Metadata' }),
        role: core_1.Flags.string({ required: false, description: 'The primary function or role of the asset within the network or organization', options: Object.values(hdf_converters_1.Role), helpGroup: 'Checklist Metadata' }),
        assettype: core_1.Flags.string({ required: false, description: 'The category or classification of the asset', options: Object.values(hdf_converters_1.Assettype), helpGroup: 'Checklist Metadata' }),
        techarea: core_1.Flags.string({ required: false, description: 'The technical area or domain to which the asset belongs', options: Object.values(hdf_converters_1.Techarea), helpGroup: 'Checklist Metadata' }),
        stigguid: core_1.Flags.string({ required: false, description: 'A unique identifier associated with the STIG for the asset', helpGroup: 'Checklist Metadata' }),
        targetkey: core_1.Flags.string({ required: false, description: 'A unique key or identifier for the asset within the checklist or inventory system', helpGroup: 'Checklist Metadata' }),
        webordatabase: core_1.Flags.boolean({ required: false, description: 'Indicates whether the STIG is primarily for either a web or database server', helpGroup: 'Checklist Metadata' }),
        webdbsite: core_1.Flags.string({ required: false, description: 'The specific site or application hosted on the web or database server', dependsOn: ['webordatabase'], helpGroup: 'Checklist Metadata' }),
        webdbinstance: core_1.Flags.string({ required: false, description: 'The specific instance of the web application or database running on the server', dependsOn: ['webordatabase'], helpGroup: 'Checklist Metadata' }),
        vulidmapping: core_1.Flags.string({ required: false, description: 'Which type of control identifier to map to the checklist ID', options: ['gid', 'id'], helpGroup: 'Checklist Metadata' }),
    };
    static examples = ['saf convert hdf2ckl -i rhel7-results.json -o rhel7.ckl --fqdn reverseproxy.example.org --hostname reverseproxy --ip 10.0.0.3 --mac 12:34:56:78:90:AB',
        'saf convert hdf2ckl -i rhel8-results.json -o rhel8.ckl -m rhel8-metadata.json'];
    static oldMetadataFormatMapping = {
        'profiles[0].name': 'benchmark.title',
        'profiles[0].title': 'benchmark.title',
        stigguid: 'stigid',
        role: 'role',
        assettype: 'type',
        hostname: 'hostname',
        hostip: 'ip',
        hostmac: 'mac',
        techarea: 'tech_area',
        targetkey: 'target_key',
        webdbsite: 'web_db_site',
        webdbinstance: 'web_db_site',
    };
    async run() {
        const { flags } = await this.parse(HDF2CKL);
        /* Order of precedence for checklist metadata:
          command flags (hostname, ip, etc.) or metadata file (-m flag)
          input hdf file passthrough.metadata
          input hdf file passthrough.checklist.asset */
        const defaultMetadata = {
            role: hdf_converters_1.Role.None, assettype: hdf_converters_1.Assettype.Computing, webordatabase: 'false', profiles: [],
            hostfqdn: '', hostip: '', hostmac: '', marking: '', techarea: hdf_converters_1.Techarea.Empty, vulidmapping: 'id',
            hostname: '', targetcomment: '', webdbinstance: '', webdbsite: '',
        };
        const inputHDF = JSON.parse(fs_1.default.readFileSync(flags.input, 'utf8'));
        let flagMetadata;
        flagMetadata = flags.metadata ?
            JSON.parse(fs_1.default.readFileSync(flags.metadata, 'utf8')) :
            {
                profiles: [{
                        name: flags.profilename,
                        title: flags.profiletitle,
                        version: flags.version,
                        releasenumber: flags.releasenumber,
                        releasedate: flags.releasedate,
                    }],
                marking: flags.marking,
                hostname: flags.hostname,
                hostip: flags.ip,
                hostmac: flags.mac,
                hostfqdn: flags.fqdn,
                targetcomment: flags.targetcomment,
                role: flags.role,
                assettype: flags.assettype,
                techarea: flags.techarea,
                targetkey: flags.targetkey,
                webordatabase: flags.webordatabase,
                webdbsite: flags.webdbsite,
                webdbinstance: flags.webdbinstance,
                vulidmapping: flags.vulidmapping,
            };
        // to preserve backwards compatibility with old metadata format
        if (flags.metadata && lodash_1.default.has(flagMetadata, 'benchmark')) {
            let profile;
            if (lodash_1.default.has(flagMetadata, 'benchmark.version')) {
                const version = lodash_1.default.get(flagMetadata, 'benchmark.version');
                // get sections of numbers in version string
                const parsedVersion = version.split(/\D+/)
                    .filter(Boolean)
                    .map(s => Number.parseInt(s, 10));
                profile = { version: parsedVersion[0], releasenumber: parsedVersion[1] };
            }
            else {
                profile = {};
            }
            const newFlagMetadata = { profiles: [profile] };
            for (const [newKey, oldKey] of Object.entries(HDF2CKL.oldMetadataFormatMapping)) {
                const oldValue = lodash_1.default.get(flagMetadata, oldKey);
                if (oldValue) {
                    lodash_1.default.set(newFlagMetadata, newKey, oldValue);
                }
            }
            flagMetadata = newFlagMetadata;
        }
        const hdfMetadata = lodash_1.default.get(inputHDF, 'passthrough.metadata', lodash_1.default.get(inputHDF, 'passthrough.checklist.asset', {}));
        const metadata = lodash_1.default.merge(defaultMetadata, hdfMetadata, flagMetadata);
        lodash_1.default.set(inputHDF, 'passthrough.metadata', metadata);
        const validationResults = (0, hdf_converters_1.validateChecklistMetadata)(metadata);
        if (validationResults.ok) {
            fs_1.default.writeFileSync(flags.output, new hdf_converters_1.ChecklistResults(inputHDF).toCkl());
        }
        else {
            console.error(`Error creating checklist:\n${validationResults.error.message}`);
        }
    }
}
exports.default = HDF2CKL;
//# sourceMappingURL=hdf2ckl.js.map