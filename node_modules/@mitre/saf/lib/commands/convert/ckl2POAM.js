"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const winston_1 = require("winston");
const xml2js_1 = tslib_1.__importDefault(require("xml2js"));
const prompt_sync_1 = tslib_1.__importDefault(require("prompt-sync"));
const xlsx_populate_1 = tslib_1.__importDefault(require("xlsx-populate"));
const moment_1 = tslib_1.__importDefault(require("moment"));
const ckl2poam_1 = require("../../utils/ckl2poam");
const files_json_1 = tslib_1.__importDefault(require("../../resources/files.json"));
const global_1 = require("../../utils/global");
const prompt = (0, prompt_sync_1.default)();
const { printf } = winston_1.format;
const fmt = printf(({ level, file, message, }) => {
    return `${level.toUpperCase()}: ${file}: ${message}`;
});
const logger = (0, winston_1.createLogger)({
    format: fmt,
    transports: [
        new winston_1.transports.Console(),
    ],
});
const STARTING_ROW = 8; // The row we start inserting controls into
class CKL2POAM extends core_1.Command {
    async run() {
        const { flags } = await this.parse(CKL2POAM);
        // Create output folder if it doesn't exist already
        if (!fs_1.default.existsSync(flags.output)) {
            fs_1.default.mkdirSync(flags.output);
        }
        flags.input.forEach(fileName => {
            // Ignore files that start with . (e.g .gitignore)
            if (fileName.startsWith('.')) {
                return;
            }
            logger.log({
                level: 'info',
                file: fileName,
                message: 'Opening file',
            });
            const parser = new xml2js_1.default.Parser();
            fs_1.default.readFile(fileName, function (readFileError, data) {
                if (readFileError) {
                    logger.log({
                        level: 'error',
                        file: fileName,
                        message: `An error occurred opening the file ${fileName}: ${readFileError}`,
                    });
                }
                // Parse the XML to a javascript object
                parser.parseString(data, function (parseFileError, result) {
                    if (parseFileError) {
                        logger.log({
                            level: 'error',
                            file: fileName,
                            message: `An error occurred parsing the file: ${readFileError}`,
                        });
                    }
                    else {
                        const infos = {};
                        let vulnerabilities = [];
                        const iStigs = [];
                        const stigs = result.CHECKLIST.STIGS;
                        logger.log({
                            level: 'info',
                            file: fileName,
                            message: `Found ${stigs === null || stigs === void 0 ? void 0 : stigs.length} STIGs`,
                        });
                        // Get nested iSTIGs
                        stigs === null || stigs === void 0 ? void 0 : stigs.forEach(stig => {
                            var _a;
                            (_a = stig.iSTIG) === null || _a === void 0 ? void 0 : _a.forEach(iStig => {
                                iStigs.push(iStig);
                            });
                        });
                        logger.log({
                            level: 'info',
                            file: fileName,
                            message: `Found ${iStigs.length} iSTIGs`,
                        });
                        // Get the controls/vulnerabilities from each stig
                        iStigs.forEach(iSTIG => {
                            var _a;
                            (_a = iSTIG.STIG_INFO) === null || _a === void 0 ? void 0 : _a.forEach(info => {
                                var _a;
                                (_a = info.SI_DATA) === null || _a === void 0 ? void 0 : _a.forEach(data => {
                                    if (data.SID_DATA) {
                                        infos[data.SID_NAME[0]] = data.SID_DATA[0];
                                    }
                                });
                            });
                            if (iSTIG.VULN) {
                                vulnerabilities = [
                                    ...vulnerabilities,
                                    ...iSTIG.VULN.map(vulnerability => {
                                        var _a;
                                        const values = {};
                                        // Extract STIG_DATA
                                        (_a = vulnerability.STIG_DATA) === null || _a === void 0 ? void 0 : _a.reverse().forEach(data => {
                                            values[data.VULN_ATTRIBUTE[0]] = data.ATTRIBUTE_DATA[0];
                                        });
                                        // Extract remaining fields (status, finding details, comments, security override, and severity justification)
                                        Object.entries(vulnerability).forEach(([key, value]) => {
                                            values[key] = value[0];
                                        });
                                        return values;
                                    }),
                                ];
                            }
                        });
                        logger.log({
                            level: 'info',
                            file: fileName,
                            message: `Found ${vulnerabilities.length} vulnerabilities`,
                        });
                        const officeOrg = flags.officeOrg || prompt('What should the default value be for Office/org? ');
                        const host = flags.deviceName || prompt('What is the device name? ');
                        // Read our template
                        xlsx_populate_1.default.fromDataAsync((0, global_1.dataURLtoU8Array)(files_json_1.default.POAMTemplate.data)).then((workBook) => {
                            // eMASS reads the first sheet in the notebook
                            const sheet = workBook.sheet(0);
                            // The current row we are on
                            let currentRow = STARTING_ROW;
                            // The scheduled completion date, default of one year from today
                            const aYearFromNow = (0, moment_1.default)(new Date(new Date().setFullYear(new Date().getFullYear() + 1))).format('M/DD/YYYY');
                            // For each vulnerability
                            vulnerabilities.forEach(vulnerability => {
                                var _a;
                                if (vulnerability.STATUS !== 'NotAFinding' && vulnerability.STATUS !== 'Not_Reviewed') {
                                    // Control Vulnerability Description
                                    if (vulnerability.STATUS === 'Not_Applicable') {
                                        sheet.cell(`C${currentRow}`).value('Not Applicable');
                                    }
                                    else {
                                        sheet.cell(`C${currentRow}`).value((0, ckl2poam_1.replaceSpecialCharacters)((0, ckl2poam_1.createCVD)(vulnerability)));
                                    }
                                    // Security Control Number
                                    sheet.cell(`D${currentRow}`).value((0, ckl2poam_1.cci2nist)(vulnerability.CCI_REF || ''));
                                    // Office/org
                                    sheet.cell(`E${currentRow}`).value(officeOrg);
                                    // Security Checks
                                    sheet.cell(`F${currentRow}`).value((_a = vulnerability.Rule_ID) === null || _a === void 0 ? void 0 : _a.split(',')[0]);
                                    // Resources Required
                                    sheet.cell(`G${currentRow}`).value('NA');
                                    // Scheduled Completion Date
                                    // Default is one year from today
                                    sheet.cell(`H${currentRow}`).value(aYearFromNow);
                                    // Source Identifying Vulnerability
                                    sheet.cell(`K${currentRow}`).value(infos.title || '');
                                    // Status
                                    sheet.cell(`L${currentRow}`).value((0, ckl2poam_1.cleanStatus)(vulnerability.STATUS || ''));
                                    // Comments
                                    if (vulnerability.STATUS === 'Open' || vulnerability.STATUS === 'Not_Applicable') {
                                        if (host.startsWith('Nessus')) {
                                            sheet.cell(`M${currentRow}`).value((0, ckl2poam_1.combineComments)(vulnerability, (0, ckl2poam_1.extractSTIGUrl)(vulnerability.FINDING_DETAILS || '')));
                                        }
                                        else {
                                            sheet.cell(`M${currentRow}`).value((0, ckl2poam_1.combineComments)(vulnerability, host));
                                        }
                                    }
                                    // Raw Severity
                                    sheet.cell(`N${currentRow}`).value((0, ckl2poam_1.convertToRawSeverity)(vulnerability.Severity || ''));
                                    // Severity
                                    sheet.cell(`P${currentRow}`).value((0, ckl2poam_1.cklSeverityToPOAMSeverity)(vulnerability.Severity || ''));
                                    // Relevance of Threat
                                    sheet.cell(`Q${currentRow}`).value((0, ckl2poam_1.cklSeverityToRelevanceOfThreat)(vulnerability.Severity || ''));
                                    // Likelihood
                                    sheet.cell(`R${currentRow}`).value((0, ckl2poam_1.cklSeverityToLikelihood)(vulnerability.Severity || ''));
                                    // Impact
                                    sheet.cell(`S${currentRow}`).value((0, ckl2poam_1.cklSeverityToImpact)(vulnerability.Severity || ''));
                                    // Residual Risk Level
                                    sheet.cell(`U${currentRow}`).value((0, ckl2poam_1.cklSeverityToResidualRiskLevel)(vulnerability.Severity || ''));
                                    // Impact Description
                                    sheet.cell(`T${currentRow}`).value((0, ckl2poam_1.replaceSpecialCharacters)(vulnerability.Vuln_Discuss || ''));
                                    // Recommendations
                                    sheet.cell(`V${currentRow}`).value((0, ckl2poam_1.replaceSpecialCharacters)(vulnerability.Fix_Text || (0, ckl2poam_1.extractSolution)(vulnerability.FINDING_DETAILS || '') || ''));
                                    // Go to the next row
                                    currentRow += flags.rowsToSkip + 1;
                                }
                            });
                            return workBook.toFileAsync(path_1.default.join(flags.output, `${(0, global_1.convertFullPathToFilename)(fileName)}-${(0, moment_1.default)(new Date()).format('YYYY-MM-DD-HHmm')}.xlsm`));
                        });
                    }
                });
            });
        });
    }
}
exports.default = CKL2POAM;
CKL2POAM.usage = 'convert ckl2POAM -i, --input=FILE -o, --output=FOLDER';
CKL2POAM.description = 'Translate DISA Checklist CKL file(s) to POA&M files';
CKL2POAM.aliases = ['convert ckl2poam'];
CKL2POAM.flags = {
    help: core_1.Flags.help({ char: 'h' }),
    input: core_1.Flags.string({ char: 'i', required: true, multiple: true, description: 'Path to the DISA Checklist File(s)' }),
    officeOrg: core_1.Flags.string({ char: 'O', required: false, default: '', description: 'Default value for Office/org (prompts for each file if not set)' }),
    deviceName: core_1.Flags.string({ char: 'd', required: false, default: '', description: 'Name of target device (prompts for each file if not set)' }),
    rowsToSkip: core_1.Flags.integer({ char: 's', required: false, default: 4, description: 'Rows to leave between POA&M Items for milestones' }),
    output: core_1.Flags.string({ char: 'o', required: true, description: 'Path to output PO&M File(s)' }),
};
