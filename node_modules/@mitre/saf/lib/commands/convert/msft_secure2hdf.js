"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const fs_1 = tslib_1.__importDefault(require("fs"));
const https_1 = tslib_1.__importDefault(require("https"));
const hdf_converters_1 = require("@mitre/hdf-converters");
const identity_1 = require("@azure/identity");
const microsoft_graph_client_1 = require("@microsoft/microsoft-graph-client");
const azureTokenCredentials_1 = require("@microsoft/microsoft-graph-client/authProviders/azureTokenCredentials");
const global_1 = require("../../utils/global");
const baseCommand_1 = require("../../utils/oclif/baseCommand");
function processInputs(scoreDoc, profiles, output, withRaw) {
    const converter = new hdf_converters_1.MsftSecureScoreResults(JSON.stringify({
        secureScore: scoreDoc,
        profiles,
    }), withRaw);
    for (const hdfReport of converter.toHdf()) {
        const auxData = (hdfReport
            .passthrough?.auxiliary_data).find(auxDat => auxDat?.name === 'Microsoft Secure Score')
            ?.data;
        const reportId = auxData?.reportId;
        fs_1.default.writeFileSync(`${output.replaceAll(/\.json/gi, '')}-${(0, global_1.basename)(reportId)}.json`, JSON.stringify(hdfReport));
    }
}
class MsftSecure2HDF extends baseCommand_1.BaseCommand {
    static usage = [
        '<%= command.id %> -p <secure-score-control-profiles> -r <secureScore-json> -o <hdf-scan-results-json> [-w] [--interactive] [-L info|warn|debug|verbose] [-h]',
        '<%= command.id %> -t <azure-tenant-id> -a <azure-app-id> -s <azure-app-secret> -o <hdf-scan-results-json> [-C <certificate> | -I] [-w] [--interactive] [-L info|warn|debug|verbose] [-h]',
        '<%= command.id %> -i <combined-inputs> -o <hdf-scan-results-json> [-w] [--interactive] [-L info|warn|debug|verbose] [-h]',
    ];
    static description = 'Translate a Microsoft Secure Score report and Secure Score Control to a Heimdall Data Format JSON file.';
    static examples = [
        {
            description: '\x1B[93mUsing input files\x1B[0m',
            command: '<%= config.bin %> <%= command.id %> -p secureScore.json -r secureScoreControlProfiles -o output-hdf-name.json [-w]',
        },
        {
            description: '\x1B[93mUsing Azure tenant ID\x1B[0m',
            command: '<%= config.bin %> <%= command.id %> -t "12345678-1234-1234-1234-1234567890abcd" -a "12345678-1234-1234-1234-1234567890abcd" -s "aaaaa~bbbbbbbbbbbbbbbbbbbbbbbbb-cccccccc" -o output-hdf-name.json [-I | -C <certificate>]',
        },
        {
            description: '\x1B[93mUsing combined inputs\x1B[0m',
            command: '<%= config.bin %> <%= command.id %> -i <(jq \'{"secureScore": .[0], "profiles": .[1]}\' secureScore.json secureScoreControlProfiles.json)> -o output-hdf-name.json [-w]',
        },
    ];
    static flags = {
        combinedInputs: core_1.Flags.string({
            char: 'i',
            required: false,
            description: '{secureScore: <CONTENTS_OF_INPUT_SCORE_DOC>}, profiles: <CONTENTS_OF_INPUT_PROFILES_DOC>',
            exclusive: ['inputProfiles'],
        }),
        inputProfiles: core_1.Flags.string({
            char: 'p',
            required: false,
            description: 'Input Microsoft Graph API "GET /security/secureScoreControlProfiles" output JSON File',
            dependsOn: ['inputScoreDoc', 'inputProfiles'],
            exclusive: ['tenantId', 'combinedInputs'],
        }),
        inputScoreDoc: core_1.Flags.string({
            char: 'r',
            required: false,
            description: 'Input Microsoft Graph API "GET /security/secureScores" output JSON File',
            dependsOn: ['inputScoreDoc', 'inputProfiles'],
            exclusive: ['tenantId', 'combinedInputs'],
        }),
        tenantId: core_1.Flags.string({
            char: 't',
            required: false,
            description: 'Azure tenant ID',
            dependsOn: ['tenantId', 'appId', 'appSecret'],
            exclusive: ['inputProfiles', 'combinedInputs'],
        }),
        appId: core_1.Flags.string({
            char: 'a',
            required: false,
            description: 'Azure application ID',
            dependsOn: ['tenantId', 'appId', 'appSecret'],
            exclusive: ['inputProfiles', 'combinedInputs'],
        }),
        appSecret: core_1.Flags.string({
            char: 's',
            required: false,
            description: 'Azure application secret',
            dependsOn: ['tenantId', 'appId', 'appSecret'],
            exclusive: ['inputProfiles', 'combinedInputs'],
        }),
        output: core_1.Flags.string({
            char: 'o',
            required: true,
            description: 'Output HDF JSON file',
        }),
        includeRaw: core_1.Flags.boolean({
            char: 'w',
            required: false,
            description: 'Include raw input file in HDF JSON file',
        }),
        certificate: core_1.Flags.string({
            char: 'C',
            required: false,
            description: 'Trusted signing certificate file',
            exclusive: ['input', 'insecure'],
        }),
        insecure: core_1.Flags.boolean({
            char: 'I',
            required: false,
            default: false,
            description: 'Disable SSL verification, this is insecure.',
            exclusive: ['input', 'certificate'],
        }),
    };
    async run() {
        const { flags } = await this.parse(MsftSecure2HDF);
        let scoreDoc;
        let profilesDoc;
        if (flags.inputProfiles !== undefined
            && flags.inputScoreDoc !== undefined) {
            // load from pre-downloaded files
            scoreDoc = JSON.parse(fs_1.default.readFileSync(flags.inputScoreDoc, 'utf8'));
            profilesDoc = JSON.parse(fs_1.default.readFileSync(flags.inputProfiles, 'utf8'));
            processInputs(scoreDoc, profilesDoc, flags.output, flags.includeRaw);
        }
        else if (flags.combinedInputs !== undefined) {
            const combined = JSON.parse(fs_1.default.readFileSync(flags.combinedInputs, 'utf8'));
            const scoreDoc = combined.secureScore;
            const profilesDoc = combined.profiles;
            processInputs(scoreDoc, profilesDoc, flags.output, flags.includeRaw);
        }
        else if (flags.tenantId !== undefined
            && flags.appId !== undefined
            && flags.appSecret !== undefined) {
            // attempt to use the Graph API to pull files
            const tenantId = flags.tenantId;
            const appId = flags.appId;
            const appSecret = flags.appSecret;
            const creds = new identity_1.ClientSecretCredential(tenantId, appId, appSecret);
            const graphClientOpts = {
                authProvider: new azureTokenCredentials_1.TokenCredentialAuthenticationProvider(creds, {
                    scopes: ['https://graph.microsoft.com/.default'],
                }),
                fetchOptions: {
                    agent: new https_1.default.Agent({
                        // Disable HTTPS verification if requested
                        rejectUnauthorized: !flags.insecure,
                        // Pass an SSL certificate to trust
                        ca: flags.certificate
                            ? fs_1.default.readFileSync(flags.certificate, 'utf8')
                            : undefined,
                    }),
                },
            };
            const graphClient = microsoft_graph_client_1.Client.initWithMiddleware(graphClientOpts);
            scoreDoc = await graphClient.api('/security/secureScores').get();
            profilesDoc = await graphClient
                .api('/security/secureScoreControlProfiles')
                .get();
            const allProfiles = [];
            const callback = (v) => {
                allProfiles.push(v);
                return true;
            };
            const pagingIterator = new microsoft_graph_client_1.PageIterator(graphClient, profilesDoc, callback);
            await pagingIterator.iterate();
            profilesDoc.value = allProfiles;
            processInputs(scoreDoc, profilesDoc, flags.output, flags.includeRaw);
        }
        else {
            throw new Error('Invalid arguments provided.  Valid options are: (-a, -s, -t) or (-r, -p) or (-i) or (-h)');
        }
    }
}
exports.default = MsftSecure2HDF;
//# sourceMappingURL=msft_secure2hdf.js.map