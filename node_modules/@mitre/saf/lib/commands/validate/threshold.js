"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const flat_1 = tslib_1.__importDefault(require("flat"));
const yaml_1 = tslib_1.__importDefault(require("yaml"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const inspecjs_1 = require("inspecjs");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const threshold_1 = require("../../utils/threshold");
const chai_1 = require("chai");
class Threshold extends core_1.Command {
    async run() {
        const { flags } = await this.parse(Threshold);
        let thresholds = {};
        if (flags.templateInline) {
            // Need to do some processing to convert this into valid JSON
            const flattenedObjects = flags.templateInline.split(',').map(value => value.trim().replace('{', '').replace('}', ''));
            const toUnpack = {};
            for (const flattenedObject of flattenedObjects) {
                const [key, value] = flattenedObject.split(':');
                toUnpack[key] = Number.parseInt(value, 10);
            }
            thresholds = flat_1.default.unflatten(toUnpack);
        }
        else if (flags.templateFile) {
            const parsed = yaml_1.default.parse(fs_1.default.readFileSync(flags.templateFile, 'utf8'));
            thresholds = Object.values(parsed).every(key => typeof key === 'number') ? flat_1.default.unflatten(parsed) : parsed;
        }
        else {
            console.log('Please provide an inline compliance template or a compliance file.');
            console.log('See https://github.com/mitre/saf#compliance for more information');
            return;
        }
        const parsedExecJSON = (0, inspecjs_1.convertFileContextual)(fs_1.default.readFileSync(flags.input, 'utf8'));
        const overallStatusCounts = (0, threshold_1.extractStatusCounts)(parsedExecJSON.contains[0]);
        if (thresholds.compliance) {
            const overallCompliance = (0, threshold_1.calculateCompliance)(overallStatusCounts);
            (0, threshold_1.exitNonZeroIfTrue)(Boolean(thresholds.compliance.min && overallCompliance < thresholds.compliance.min), 'Overall compliance minimum was not satisfied'); // Compliance Minimum
            (0, threshold_1.exitNonZeroIfTrue)(Boolean(thresholds.compliance.max && overallCompliance > thresholds.compliance.max), 'Overall compliance maximum was not satisfied'); // Compliance Maximum
        }
        // Total Pass/Fail/Skipped/No Impact/Error
        const targets = ['passed.total', 'passed.total', 'failed.total', 'failed.total', 'skipped.total', 'skipped.total', 'no_impact.total', 'no_impact.total', 'error.total', 'error.total'];
        for (const statusThreshold of targets) {
            const [statusName, _total] = statusThreshold.split('.');
            if (lodash_1.default.get(thresholds, statusThreshold) !== undefined) {
                (0, threshold_1.exitNonZeroIfTrue)(Boolean(lodash_1.default.get(overallStatusCounts, (0, threshold_1.renameStatusName)(statusName)) !==
                    lodash_1.default.get(thresholds, statusThreshold)), `${statusThreshold}: ${lodash_1.default.get(overallStatusCounts, (0, threshold_1.renameStatusName)(statusName))} < ${lodash_1.default.get(thresholds, statusThreshold)}`);
            }
        }
        // All Severities Pass/Fail/Skipped/No Impact/Error
        for (const [severity, targetPaths] of Object.entries(threshold_1.severityTargetsObject)) {
            const criticalStatusCounts = (0, threshold_1.extractStatusCounts)(parsedExecJSON.contains[0], severity);
            for (const statusCountThreshold of targetPaths) {
                const [statusName, _total, thresholdType] = statusCountThreshold.split('.');
                if (thresholdType === 'min' && lodash_1.default.get(thresholds, statusCountThreshold) !== undefined) {
                    (0, threshold_1.exitNonZeroIfTrue)(Boolean(lodash_1.default.get(criticalStatusCounts, (0, threshold_1.renameStatusName)(statusName)) < lodash_1.default.get(thresholds, statusCountThreshold)), `${statusCountThreshold}: ${lodash_1.default.get(criticalStatusCounts, (0, threshold_1.renameStatusName)(statusName))} < ${lodash_1.default.get(thresholds, statusCountThreshold)}`);
                }
                else if (thresholdType === 'max' && lodash_1.default.get(thresholds, statusCountThreshold) !== undefined) {
                    (0, threshold_1.exitNonZeroIfTrue)(Boolean(lodash_1.default.get(criticalStatusCounts, (0, threshold_1.renameStatusName)(statusName)) > lodash_1.default.get(thresholds, statusCountThreshold)), `${statusCountThreshold}: ${lodash_1.default.get(criticalStatusCounts, (0, threshold_1.renameStatusName)(statusName))} > ${lodash_1.default.get(thresholds, statusCountThreshold)}`);
                }
            }
        }
        // Expect Control IDs to match placed severities
        const controlIdMap = (0, threshold_1.getControlIdMap)(parsedExecJSON.contains[0]);
        for (const [severity, targetPaths] of Object.entries(threshold_1.statusSeverityPaths)) {
            for (const targetPath of targetPaths) {
                const expectedControlIds = lodash_1.default.get(thresholds, targetPath);
                const actualControlIds = lodash_1.default.get(controlIdMap, targetPath);
                if (expectedControlIds) {
                    for (const expectedControlId of expectedControlIds) {
                        try {
                            (0, chai_1.expect)(actualControlIds).to.contain(expectedControlId);
                        }
                        catch {
                            (0, threshold_1.exitNonZeroIfTrue)(true, `Expected ${targetPath} to contain ${expectedControlId} controls but it only contained [${actualControlIds === null || actualControlIds === void 0 ? void 0 : actualControlIds.join(', ')}]`); // Chai doesn't print the actual object diff anymore
                        }
                    }
                    try {
                        (0, chai_1.expect)(expectedControlIds.length).to.equal(actualControlIds === null || actualControlIds === void 0 ? void 0 : actualControlIds.length);
                    }
                    catch {
                        (0, threshold_1.exitNonZeroIfTrue)(true, `Expected ${targetPath} to contain ${expectedControlIds.length} controls but it contained ${actualControlIds === null || actualControlIds === void 0 ? void 0 : actualControlIds.length}`);
                    }
                }
            }
        }
    }
}
exports.default = Threshold;
Threshold.usage = 'validate threshold -i, --input=JSON -T, --templateInline="JSON Data" -F --templateFile=YAML File';
Threshold.description = 'Validate the compliance and status counts of an HDF file';
Threshold.flags = {
    help: core_1.Flags.help({ char: 'h' }),
    input: core_1.Flags.string({ char: 'i', required: true }),
    templateInline: core_1.Flags.string({ char: 'T', required: false }),
    templateFile: core_1.Flags.string({ char: 'F', required: false, description: 'Expected data template, generate one with "saf generate threshold"' }),
};
