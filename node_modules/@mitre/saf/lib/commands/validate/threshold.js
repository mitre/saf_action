"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable no-unused-vars */
/* eslint-disable @typescript-eslint/no-unused-vars */
const fs_1 = tslib_1.__importDefault(require("fs"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const yaml_1 = tslib_1.__importDefault(require("yaml"));
const chai_1 = require("chai");
const core_1 = require("@oclif/core");
const inspecjs_1 = require("inspecjs");
const threshold_1 = require("../../utils/threshold");
const baseCommand_1 = require("../../utils/oclif/baseCommand");
class Threshold extends baseCommand_1.BaseCommand {
    static usage = '<%= command.id %> -i <hdf-json> [-I <flattened-threshold-json> | -T <template-file>] [-h] [-L info|warn|debug|verbose]';
    static description = 'Validate the compliance and status counts of an HDF file';
    static examples = [
        {
            description: '\x1B[93mProviding a threshold template file\x1B[0m',
            command: '<%= config.bin %> <%= command.id %> -i rhel7-results.json -T threshold.yaml',
        },
        {
            description: '\x1B[93mSpecifying the threshold inline\x1B[0m',
            command: '<%= config.bin %> <%= command.id %> -i rhel7-results.json -I "{compliance.min: 80}, {passed.total.min: 18}, {failed.total.max: 2}"',
        },
    ];
    static flags = {
        input: core_1.Flags.string({
            char: 'i', required: true, description: 'The HDF JSON File to be validated by the threshold values'
        }),
        templateInline: core_1.Flags.string({
            char: 'I', required: false, exclusive: ['templateFile'],
            description: 'An inline (on the command line) flattened JSON containing the validation thresholds (Intended for backwards compatibility with InSpec Tools)',
        }),
        templateFile: core_1.Flags.string({
            char: 'T', required: false, exclusive: ['templateInline'],
            description: 'A threshold YAML file containing expected threshold values. Generate it using the "saf generate threshold" command',
        }),
    };
    // eslint-disable-next-line complexity
    async run() {
        const { flags } = await this.parse(Threshold);
        let thresholds = {};
        // inline does not seem to support the controls array option
        if (flags.templateInline) {
            // Need to do some processing to convert this into valid JSON
            const flattenedObjects = flags.templateInline.split(',').map((value) => value.trim().replace('{', '').replace('}', ''));
            const toUnpack = {};
            for (const flattenedObject of flattenedObjects) {
                const [key, value] = flattenedObject.split(':');
                toUnpack[key] = Number.parseInt(value, 10);
            }
            thresholds = (0, threshold_1.unflattenThreshold)(toUnpack);
        }
        else if (flags.templateFile) {
            const parsed = yaml_1.default.parse(fs_1.default.readFileSync(flags.templateFile, 'utf8'));
            thresholds = Object.values(parsed).every(key => typeof key === 'number') ? (0, threshold_1.unflattenThreshold)(parsed) : parsed;
        }
        else {
            console.log('Please provide an inline compliance template or a compliance file.');
            console.log('See https://github.com/mitre/saf/wiki/Validation-with-Thresholds for more information');
            return;
        }
        const parsedExecJSON = (0, inspecjs_1.convertFileContextual)(fs_1.default.readFileSync(flags.input, 'utf8'));
        const overallStatusCounts = (0, threshold_1.extractStatusCounts)(parsedExecJSON.contains[0]);
        if (thresholds.compliance) {
            const overallCompliance = (0, threshold_1.calculateCompliance)(overallStatusCounts);
            try {
                (0, threshold_1.exitNonZeroIfTrue)(Boolean(thresholds.compliance.min && overallCompliance < thresholds.compliance.min), 'Overall compliance minimum was not satisfied'); // Compliance Minimum
                (0, threshold_1.exitNonZeroIfTrue)(Boolean(thresholds.compliance.max && overallCompliance > thresholds.compliance.max), 'Overall compliance maximum was not satisfied'); // Compliance Maximum
            }
            catch {
                process.exitCode = 1;
                return;
            }
        }
        // Total Pass/Fail/Skipped/No Impact/Error
        const targets = ['passed.total', 'failed.total', 'skipped.total', 'no_impact.total', 'error.total'];
        for (const statusThreshold of targets) {
            const [statusName, _total] = statusThreshold.split('.');
            if (lodash_1.default.get(thresholds, statusThreshold) !== undefined && typeof lodash_1.default.get(thresholds, statusThreshold) !== 'object') {
                try {
                    (0, threshold_1.exitNonZeroIfTrue)(Boolean(lodash_1.default.get(overallStatusCounts, (0, threshold_1.renameStatusName)(statusName))
                        !== lodash_1.default.get(thresholds, statusThreshold)), `${statusThreshold}: Threshold not met. Number of received total ${statusThreshold.split('.')[0]} controls (${lodash_1.default.get(overallStatusCounts, (0, threshold_1.renameStatusName)(statusName))}) is not equal to your set threshold for the number of ${statusThreshold.split('.')[0]} controls (${lodash_1.default.get(thresholds, statusThreshold)})`);
                }
                catch {
                    process.exitCode = 1;
                    return;
                }
            }
        }
        for (const totalMinimum of threshold_1.totalMin) {
            const [statusName] = totalMinimum.split('.');
            if (lodash_1.default.get(thresholds, totalMinimum) !== undefined) {
                try {
                    (0, threshold_1.exitNonZeroIfTrue)(Boolean(lodash_1.default.get(overallStatusCounts, (0, threshold_1.renameStatusName)(statusName))
                        < lodash_1.default.get(thresholds, totalMinimum)), `${totalMinimum}: Threshold not met. Number of received total ${totalMinimum.split('.')[0]} controls (${lodash_1.default.get(overallStatusCounts, (0, threshold_1.renameStatusName)(statusName))}) is less than your set threshold for the number of ${totalMinimum.split('.')[0]} controls (${lodash_1.default.get(thresholds, totalMinimum)})`);
                }
                catch {
                    process.exitCode = 1;
                    return;
                }
            }
        }
        for (const totalMaximum of threshold_1.totalMax) {
            const [statusName] = totalMaximum.split('.');
            if (lodash_1.default.get(thresholds, totalMaximum) !== undefined) {
                try {
                    (0, threshold_1.exitNonZeroIfTrue)(Boolean(lodash_1.default.get(overallStatusCounts, (0, threshold_1.renameStatusName)(statusName))
                        > lodash_1.default.get(thresholds, totalMaximum)), `${totalMaximum}: Threshold not met. Number of received total ${totalMaximum.split('.')[0]} controls (${lodash_1.default.get(overallStatusCounts, (0, threshold_1.renameStatusName)(statusName))}) is greater than your set threshold for the number of ${totalMaximum.split('.')[0]} controls (${lodash_1.default.get(thresholds, totalMaximum)})`);
                }
                catch {
                    process.exitCode = 1;
                    return;
                }
            }
        }
        // All Severities Pass/Fail/Skipped/No Impact/Error
        for (const [severity, targetPaths] of Object.entries(threshold_1.severityTargetsObject)) {
            const criticalStatusCounts = (0, threshold_1.extractStatusCounts)(parsedExecJSON.contains[0], severity);
            for (const statusCountThreshold of targetPaths) {
                const [statusName, _total, thresholdType] = statusCountThreshold.split('.');
                if (thresholdType === 'min' && lodash_1.default.get(thresholds, statusCountThreshold) !== undefined) {
                    try {
                        (0, threshold_1.exitNonZeroIfTrue)(Boolean(lodash_1.default.get(criticalStatusCounts, (0, threshold_1.renameStatusName)(statusName)) < lodash_1.default.get(thresholds, statusCountThreshold)), `${statusCountThreshold}: Threshold not met. Number of received total ${statusCountThreshold.split('.')[0]} controls (${lodash_1.default.get(criticalStatusCounts, (0, threshold_1.renameStatusName)(statusName))}) is less than your set threshold for the number of ${statusCountThreshold.split('.')[0]} controls (${lodash_1.default.get(thresholds, statusCountThreshold)})`);
                    }
                    catch {
                        process.exitCode = 1;
                        return;
                    }
                }
                else if (thresholdType === 'max' && lodash_1.default.get(thresholds, statusCountThreshold) !== undefined) {
                    try {
                        (0, threshold_1.exitNonZeroIfTrue)(Boolean(lodash_1.default.get(criticalStatusCounts, (0, threshold_1.renameStatusName)(statusName)) > lodash_1.default.get(thresholds, statusCountThreshold)), `${statusCountThreshold}: Threshold not met. Number of received total ${statusCountThreshold.split('.')[0]} controls (${lodash_1.default.get(criticalStatusCounts, (0, threshold_1.renameStatusName)(statusName))}) is greater than your set threshold for the number of ${statusCountThreshold.split('.')[0]} controls (${lodash_1.default.get(thresholds, statusCountThreshold)})`);
                    }
                    catch {
                        process.exitCode = 1;
                        return;
                    }
                }
            }
        }
        // Expect Control IDs to match placed severities
        const controlIdMap = (0, threshold_1.getControlIdMap)(parsedExecJSON.contains[0]);
        for (const [_severity, targetPaths] of Object.entries(threshold_1.statusSeverityPaths)) {
            for (const targetPath of targetPaths) {
                const expectedControlIds = lodash_1.default.get(thresholds, targetPath);
                const actualControlIds = lodash_1.default.get(controlIdMap, targetPath);
                if (expectedControlIds) {
                    for (const expectedControlId of expectedControlIds) {
                        try {
                            (0, chai_1.expect)(actualControlIds).to.contain(expectedControlId);
                        }
                        catch {
                            try {
                                (0, threshold_1.exitNonZeroIfTrue)(true, `Expected ${targetPath} to contain ${expectedControlId} controls but it only contained [${actualControlIds?.join(', ')}]`); // Chai doesn't print the actual object diff anymore
                            }
                            catch {
                                process.exitCode = 1;
                                return;
                            }
                        }
                    }
                    try {
                        (0, chai_1.expect)(expectedControlIds.length).to.equal(actualControlIds?.length);
                    }
                    catch {
                        try {
                            (0, threshold_1.exitNonZeroIfTrue)(true, `Expected ${targetPath} to contain ${expectedControlIds.length} controls but it contained ${actualControlIds?.length}`);
                        }
                        catch {
                            process.exitCode = 1;
                            return;
                        }
                    }
                }
            }
        }
        console.log('All validation tests passed');
    }
}
exports.default = Threshold;
//# sourceMappingURL=threshold.js.map