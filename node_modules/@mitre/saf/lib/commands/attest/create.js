"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const fs_1 = tslib_1.__importDefault(require("fs"));
const accurate_search_1 = tslib_1.__importDefault(require("accurate-search"));
const xlsx_populate_1 = tslib_1.__importDefault(require("xlsx-populate"));
const prompt_sync_1 = tslib_1.__importDefault(require("prompt-sync"));
const files_json_1 = tslib_1.__importDefault(require("../../resources/files.json"));
const global_1 = require("../../utils/global");
const yaml_1 = tslib_1.__importDefault(require("yaml"));
const MAX_SEARCH_RESULTS = 5;
const prompt = (0, prompt_sync_1.default)();
class CreateAttestations extends core_1.Command {
    promptForever(promptValue) {
        while (true) {
            const ret = prompt(promptValue);
            if (ret.trim() !== '') {
                return ret;
            }
        }
    }
    getStatus() {
        const validPassResponses = new Set(['p', 'passed', 'pass']);
        const validFailResponses = new Set(['f', 'failed', 'fail', 'failure']);
        while (true) {
            const input = prompt('Enter status ((p)assed/(f)ailed): ') || '';
            if (validPassResponses.has(input.trim().toLowerCase())) {
                return 'passed';
            }
            if (validFailResponses.has(input.trim().toLowerCase())) {
                return 'failed';
            }
        }
    }
    promptForAttestation(id) {
        return {
            control_id: id,
            explanation: this.promptForever('Attestation explanation: '),
            frequency: this.promptForever('Frequency (1d/3d/1wk/2wk/1m/3m/6m/1y/1.5y/custom): '),
            status: this.getStatus(),
            updated: new Date().toISOString(),
            updated_by: this.promptForever('Updated By: '),
        };
    }
    async run() {
        var _a;
        const { flags } = await this.parse(CreateAttestations);
        const attestations = [];
        if (flags.input) {
            const evaluation = JSON.parse(fs_1.default.readFileSync(flags.input, 'utf8'));
            const search = new accurate_search_1.default();
            const controls = {};
            for (const profile of evaluation.profiles) {
                for (const control of profile.controls) {
                    controls[control.id] = control;
                    search.addText(control.id, `${control.id}: ${control.title || ''} ${control.desc || ''}`);
                }
            }
            while (true) {
                const input = prompt("Enter a control ID, search for a control, or enter 'q' to exit: ");
                if (input.trim().toLowerCase() === 'q') {
                    break;
                }
                else if (input in controls) {
                    attestations.push(this.promptForAttestation(controls[input].id));
                }
                else {
                    const ids = search.search(input).slice(0, MAX_SEARCH_RESULTS);
                    for (const id of ids) {
                        const control = controls[id];
                        console.log(`\t${control.id}: ${(_a = control.title) === null || _a === void 0 ? void 0 : _a.replace(/\n/g, '').replace(/\s\s+/g, ' ')}`);
                    }
                }
            }
        }
        else {
            while (true) {
                const input = prompt("Enter a control ID or enter 'q' to exit: ");
                if (input.trim().toLowerCase() === 'q') {
                    break;
                }
                else {
                    attestations.push(this.promptForAttestation(input));
                }
            }
        }
        switch (flags.format) {
            case 'json': {
                fs_1.default.writeFileSync(flags.output, JSON.stringify(attestations, null, 2));
                break;
            }
            case 'xlsx': {
                xlsx_populate_1.default.fromDataAsync((0, global_1.dataURLtoU8Array)(files_json_1.default.AttestationTemplate.data)).then((workBook) => {
                    const sheet = workBook.sheet(0); // Attestations worksheet
                    let currentRow = 2;
                    for (const attestation of attestations) {
                        sheet.cell(`A${currentRow}`).value(attestation.control_id);
                        sheet.cell(`B${currentRow}`).value(attestation.explanation);
                        sheet.cell(`C${currentRow}`).value(attestation.frequency);
                        sheet.cell(`D${currentRow}`).value(attestation.status);
                        sheet.cell(`E${currentRow}`).value(attestation.updated);
                        sheet.cell(`F${currentRow}`).value(attestation.updated_by);
                        currentRow++;
                    }
                    return workBook.toFileAsync(flags.output);
                });
                break;
            }
            case 'yaml':
            case 'yml': {
                fs_1.default.writeFileSync(flags.output, yaml_1.default.stringify(attestations));
                break;
            }
            default: {
                throw new Error('Invalid file output type');
            }
        }
    }
}
CreateAttestations.usage = 'attest create -o <attestation-file> [-i <hdf-json> -t <json | xlsx | yml | yaml>]';
CreateAttestations.description = 'Create attestation files for use with `saf attest apply`';
CreateAttestations.examples = [
    'saf attest create -o attestation.json -i hdf.json',
    'saf attest create -o attestation.xlsx -t xlsx',
];
CreateAttestations.flags = {
    help: core_1.Flags.help({ char: 'h' }),
    input: core_1.Flags.string({ char: 'i', description: '(optional) An input HDF file to search for controls' }),
    output: core_1.Flags.string({ char: 'o', required: true, description: 'The output filename' }),
    format: core_1.Flags.string({ char: 't', description: '(optional) The output file type', default: 'json', options: ['json', 'xlsx', 'yml', 'yaml'] }),
};
exports.default = CreateAttestations;
