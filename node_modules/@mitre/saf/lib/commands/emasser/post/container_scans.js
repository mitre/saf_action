"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable valid-jsdoc */
const json_colorizer_1 = require("json-colorizer");
const core_1 = require("@oclif/core");
const emass_client_1 = require("@mitre/emass_client");
const apiConnection_1 = require("../../../utils/emasser/apiConnection");
const outputFormatter_1 = require("../../../utils/emasser/outputFormatter");
const utilities_1 = require("../../../utils/emasser/utilities");
const outputError_1 = require("../../../utils/emasser/outputError");
const promises_1 = require("fs/promises");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const fs_1 = tslib_1.__importDefault(require("fs"));
/**
 * Combines JSON examples from 'container_scans-required' and
 * 'container_scans-optional' into a single JSON string.
 *
 * @returns {string} A JSON string that merges the required and
 *                   optional container scan examples.
 */
function getAllJsonExamples() {
    return JSON.stringify(lodash_1.default.merge({}, (0, utilities_1.getJsonExamples)('container_scans-required'), (0, utilities_1.getJsonExamples)('container_scans-optional')));
}
/**
 * Asserts that a parameter exists by checking if the value is not undefined.
 * If the value is undefined, it prints an error message and throws an error.
 *
 * @param object - The name of the parameter or field being checked.
 * @param value - The value of the parameter or field which can be of type string, boolean, number, undefined, or null.
 * @throws {Error} Throws an error if the value is undefined.
 */
function assertParamExists(object, value) {
    if (value === undefined) {
        (0, utilities_1.printRedMsg)(`Missing required parameter/field: ${object}`);
        throw new Error('Value not defined');
    }
}
/**
 * Adds required fields to the request body for a container resource.
 *
 * This function ensures that the required fields are present in the input data object
 * and constructs a new container resource object with the required fields populated.
 * If any required field is missing, an error is thrown and the required fields are logged.
 *
 * @param {ContainerResource} dataObj - The input container resource object.
 * @returns {ContainerResource} - The new container resource object with required fields populated.
 * @throws Will throw an error if any required field is missing in the input data object.
 */
function addRequiredFieldsToRequestBody(dataObj) {
    const bodyObj = {
        containerId: '',
        containerName: '',
        time: 0,
        benchmarks: [],
    };
    const benchmarksArray = [];
    const resultsArray = [];
    try {
        assertParamExists('containerId', dataObj.containerId);
        assertParamExists('containerName', dataObj.containerName);
        assertParamExists('time', dataObj.time);
        let i = 0;
        let j = 0;
        dataObj.benchmarks.forEach((entryObject) => {
            assertParamExists(`benchmarks[${i}].benchmark`, entryObject.benchmark);
            entryObject.results.forEach((resultObj) => {
                assertParamExists(`benchmarks.results[${j}].ruleId`, resultObj.ruleId);
                assertParamExists(`benchmarks.results[${j}].lastSeen`, resultObj.lastSeen);
                assertParamExists(`benchmarks.results[${j}].status`, resultObj.status);
                j++;
                const resultsObj = { ruleId: '', status: 'Pass', lastSeen: 0 };
                resultsObj.ruleId = resultObj.ruleId;
                resultsObj.lastSeen = resultObj.lastSeen;
                resultsObj.status = resultObj.status;
                resultsArray.push(resultsObj);
            });
            i++;
            const benchMarksObj = {
                benchmark: '',
                results: [],
            };
            benchMarksObj.benchmark = entryObject.benchmark;
            benchMarksObj.results = resultsArray;
            benchmarksArray.push(benchMarksObj);
        });
    }
    catch (error) {
        console.log('Required JSON fields are:');
        console.log((0, json_colorizer_1.colorize)(JSON.stringify((0, utilities_1.getJsonExamples)('container_scans-required'), null, 2)));
        throw error;
    }
    bodyObj.containerId = dataObj.containerId;
    bodyObj.containerName = dataObj.containerName;
    bodyObj.time = dataObj.time;
    bodyObj.benchmarks = benchmarksArray;
    return bodyObj;
}
/**
 * Adds optional fields from the `dataObj` to the `bodyObject`.
 *
 * @param bodyObject - The target object to which optional fields will be added.
 * @param dataObj - The source object containing optional fields.
 *
 * The function performs the following operations:
 * - Adds `namespace`, `podIp`, and `podName` fields if they exist in `dataObj`.
 * - Adds `tags` object if it exists in `dataObj`.
 * - Adds `benchmarks` array if it exists in `dataObj`, including optional fields within each benchmark and its results.
 *
 * The `benchmarks` array in `dataObj` is expected to contain objects with the following structure:
 * - `benchmark` (required)
 * - `isBaseline` (optional)
 * - `version` (optional)
 * - `release` (optional)
 * - `results` (required array) containing objects with the following structure:
 *   - `ruleId` (required)
 *   - `status` (required)
 *   - `lastSeen` (required)
 *   - `message` (optional)
 */
function addOptionalFields(bodyObject, dataObj) {
    // Add object optional entries
    if (Object.prototype.hasOwnProperty.call(dataObj, 'namespace')) {
        bodyObject.namespace = dataObj.namespace;
    }
    if (Object.prototype.hasOwnProperty.call(dataObj, 'podIp')) {
        bodyObject.podIp = dataObj.podIp;
    }
    if (Object.prototype.hasOwnProperty.call(dataObj, 'podName')) {
        bodyObject.podName = dataObj.podName;
    }
    // Add optional tags objects if available
    if (Object.prototype.hasOwnProperty.call(dataObj, 'tags')) {
        const tagsObj = {};
        Object.keys(dataObj.tags).forEach(key => {
            tagsObj[key.toString()] = dataObj.tags[key];
        });
        bodyObject.tags = tagsObj;
    }
    const benchmarksArray = [];
    const resultsArray = [];
    // Add the optional benchmark entries
    dataObj.benchmarks.forEach((entryObject) => {
        const benchmarksObj = { benchmark: '', results: [] };
        // These are required
        benchmarksObj.benchmark = entryObject.benchmark;
        // Check for the optional entry (isBaseline, version, and release)
        if (Object.prototype.hasOwnProperty.call(entryObject, 'isBaseline')) {
            benchmarksObj.isBaseline = entryObject.isBaseline;
        }
        if (Object.prototype.hasOwnProperty.call(entryObject, 'version')) {
            benchmarksObj.version = entryObject.version;
        }
        if (Object.prototype.hasOwnProperty.call(entryObject, 'release')) {
            benchmarksObj.release = entryObject.release;
        }
        // Add the optional Results entries
        entryObject.results.forEach((resultObj) => {
            const resultsObj = { ruleId: '', status: 'Pass', lastSeen: 0 };
            // These are required
            resultsObj.ruleId = resultObj.ruleId;
            resultsObj.status = resultObj.status;
            resultsObj.lastSeen = resultObj.lastSeen;
            // Check for the optional entry
            if (Object.prototype.hasOwnProperty.call(resultObj, 'message')) {
                resultsObj.message = resultObj.message;
            }
            resultsArray.push(resultsObj);
        });
        benchmarksObj.results = resultsArray;
        benchmarksArray.push(benchmarksObj);
    });
    bodyObject.benchmarks = benchmarksArray;
}
const CMD_HELP = 'saf emasser post container_scans -h or --help';
class EmasserContainerScans extends core_1.Command {
    static usage = '<%= command.id %> [FLAGS]\n\x1B[93m NOTE: see EXAMPLES for command usages\x1B[0m';
    static description = 'Upload containers and their scan results in the assets module for a system';
    static examples = [
        '<%= config.bin %> <%= command.id %> [-s,--systemId] [-f,--dataFile]',
        'The input file should be a well formed JSON containing the container scan results information.',
        'Required JSON parameter/fields are: ',
        (0, json_colorizer_1.colorize)(JSON.stringify((0, utilities_1.getJsonExamples)('container_scans-required'), null, 2)),
        'Optional JSON parameters/fields are:',
        (0, json_colorizer_1.colorize)(JSON.stringify((0, utilities_1.getJsonExamples)('container_scans-optional'), null, 2)),
        '\x1B[1m\x1B[32mAll accepted parameters/fields are:\x1B[0m',
        (0, json_colorizer_1.colorize)(getAllJsonExamples()),
    ];
    static flags = {
        help: core_1.Flags.help({ char: 'h', description: 'Show eMASSer CLI help for the POST Container Scan Results command' }),
        ...(0, utilities_1.getFlagsForEndpoint)(process.argv), // skipcq: JS-0349
    };
    async run() {
        const { flags } = await this.parse(EmasserContainerScans);
        const apiCxn = new apiConnection_1.ApiConnection();
        const addContainer = new emass_client_1.ContainerScanResultsApi(apiCxn.configuration, apiCxn.basePath, apiCxn.axiosInstances);
        const requestBodyArray = [];
        // Check if a Cloud Resource json file was provided
        if (fs_1.default.existsSync(flags.dataFile)) {
            let data;
            try {
                data = JSON.parse(await (0, promises_1.readFile)(flags.dataFile, 'utf8'));
            }
            catch (error) {
                console.error('\x1B[91m» Error reading Container Scan Results data file, possible malformed json. Please use the -h flag for help.\x1B[0m');
                console.error('\x1B[93m→ Error message was:', error.message, '\x1B[0m');
                process.exit(1);
            }
            // Create request body based on key/pair values provide in the input file
            if (Array.isArray(data)) {
                data.forEach((dataObject) => {
                    let bodyObj = { containerId: '', containerName: '', time: 0, benchmarks: [] };
                    // Add required fields to request array object based on business logic
                    try {
                        bodyObj = addRequiredFieldsToRequestBody(dataObject);
                        addOptionalFields(bodyObj, dataObject);
                        requestBodyArray.push(bodyObj);
                    }
                    catch {
                        process.exit(1);
                    }
                });
            }
            else if (typeof data === 'object') {
                const dataObject = data;
                let bodyObj = { containerId: '', containerName: '', time: 0, benchmarks: [] };
                // Add required fields to request array object based on business logic
                try {
                    bodyObj = addRequiredFieldsToRequestBody(dataObject);
                    addOptionalFields(bodyObj, dataObject);
                    requestBodyArray.push(bodyObj);
                }
                catch {
                    process.exit(1);
                }
            }
        }
        else {
            console.error('\x1B[91m» Container Scan Results data file (.json) not found or invalid:', flags.dataFile, '\x1B[0m');
            process.exit(1);
        }
        // Call the API endpoint
        addContainer.addContainerSansBySystemId(flags.systemId, requestBodyArray).then((response) => {
            console.log((0, json_colorizer_1.colorize)((0, outputFormatter_1.outputFormat)(response, false)));
        }).catch((error) => console.error((0, json_colorizer_1.colorize)((0, outputError_1.outputError)(error))));
    }
    async catch(err) {
        // If error message is for missing flags, display
        // what fields are required, otherwise show the error
        if (err.message.includes('See more help with --help')) {
            this.warn(err.message.replace('with --help', `with: \x1B[93m${CMD_HELP}\x1B[0m`));
        }
        else {
            this.warn(err);
        }
    }
}
exports.default = EmasserContainerScans;
//# sourceMappingURL=container_scans.js.map