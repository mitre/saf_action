"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.csvExportFields = void 0;
exports.convertRow = convertRow;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const global_1 = require("./global");
exports.csvExportFields = [
    'Results Set',
    'Status',
    'ID',
    'Title',
    'Description',
    'Descriptions',
    'Impact',
    'Severity',
    'Code',
    'Check',
    'Fix',
    '800-53 Controls',
    'CCI IDs',
    'Results',
    'Waived',
    'Waiver Data',
];
function descriptionsToString(descriptions) {
    let result = '';
    if (Array.isArray(descriptions)) {
        // Caveats are the first thing displayed if defined
        // There should only ever be one, but better safe than sorry
        const caveats = descriptions.filter(description => description.label === 'caveat');
        if (caveats.length) {
            descriptions = descriptions.filter(// skipcq: JS-0083
            // skipcq: JS-0083
            description => description.label !== 'caveat');
            caveats.forEach((caveat) => {
                result += `${caveat.label}: ${caveat.data}`;
            });
        }
        descriptions.forEach((description) => {
            result += `${description.label}: ${description.data}\r\n\r\n`;
        });
    }
    return result;
}
function segmentsToString(segments) {
    if (segments) {
        let result = '';
        segments.forEach((segment) => {
            result += segment.message
                ? `${segment.status.toUpperCase()} -- Test: ${segment.code_desc}\r\nMessage: ${segment.message}\r\n\r\n`
                : `${segment.status.toUpperCase()} -- Test: ${segment.code_desc}\r\n\r\n`;
        });
        return result;
    }
    return '';
}
// Convert HDF into Single key-field values
function convertRow(filename, control, fieldsToAdd) {
    let check = '';
    let fix = '';
    const result = {};
    if (control.data.tags.check) {
        check = control.data.tags.check;
    }
    else if (control.data.descriptions) {
        check = (0, global_1.getDescription)(control.data.descriptions, 'check') || '';
    }
    if (control.data.tags.fix) {
        fix = control.data.tags.fix;
    }
    else if (control.data.descriptions) {
        fix = (0, global_1.getDescription)(control.data.descriptions, 'fix') || '';
    }
    fieldsToAdd.forEach((field) => {
        switch (field) { // skipcq: JS-0047
            // Results Set
            case exports.csvExportFields[0]: {
                result[exports.csvExportFields[0]] = filename;
                break;
            }
            // Status
            case exports.csvExportFields[1]: {
                result[exports.csvExportFields[1]] = control.hdf.status;
                break;
            }
            // ID
            case exports.csvExportFields[2]: {
                result[exports.csvExportFields[2]] = control.data.id;
                break;
            }
            // Title
            case exports.csvExportFields[3]: {
                result[exports.csvExportFields[3]] = control.data.title?.toString() || '';
                break;
            }
            // Description
            case exports.csvExportFields[4]: {
                result[exports.csvExportFields[4]] = control.data.desc?.toString() || '';
                break;
            }
            // Descriptions
            case exports.csvExportFields[5]: {
                result[exports.csvExportFields[5]] = descriptionsToString(control.data.descriptions);
                break;
            }
            // Impact
            case exports.csvExportFields[6]: {
                result[exports.csvExportFields[6]] = control.data.impact.toString();
                break;
            }
            // Severity
            case exports.csvExportFields[7]: {
                result[exports.csvExportFields[7]] = control.hdf.severity;
                break;
            }
            // Code
            case exports.csvExportFields[8]: {
                result[exports.csvExportFields[8]] = control.full_code;
                break;
            }
            // Check
            case exports.csvExportFields[9]: {
                result[exports.csvExportFields[9]] = check;
                break;
            }
            // Fix
            case exports.csvExportFields[10]: {
                result[exports.csvExportFields[10]] = fix;
                break;
            }
            // NIST IDs
            case exports.csvExportFields[11]: {
                result[exports.csvExportFields[12]] = control.hdf.rawNistTags.join(', ');
                break;
            }
            // CCI IDs
            case exports.csvExportFields[12]: {
                result[exports.csvExportFields[12]] = (control.data.tags.cci || []).join(', ');
                break;
            }
            // Results
            case exports.csvExportFields[13]: {
                result[exports.csvExportFields[13]] = segmentsToString(control.hdf.segments);
                break;
            }
            // Is Waived
            case exports.csvExportFields[14]: {
                result[exports.csvExportFields[14]] = control.hdf.waived ? 'True' : 'False';
                break;
            }
            // Waiver Data (JSON)
            case exports.csvExportFields[15]: {
                result[exports.csvExportFields[15]] = JSON.stringify(lodash_1.default.get(control, 'hdf.wraps.waiver_data'));
                break;
            }
        }
    });
    return result;
}
//# sourceMappingURL=csv.js.map