"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cci2nist = exports.extractSolution = exports.combineComments = exports.replaceSpecialCharacters = exports.cleanStatus = exports.convertToRawSeverity = exports.createCVD = exports.cklSeverityToResidualRiskLevel = exports.cklSeverityToImpact = exports.cklSeverityToLikelihood = exports.cklSeverityToRelevanceOfThreat = exports.cklSeverityToPOAMSeverity = exports.extractSTIGUrl = void 0;
const tslib_1 = require("tslib");
const hdf_converters_1 = require("@mitre/hdf-converters");
const prompt_sync_1 = tslib_1.__importDefault(require("prompt-sync"));
const prompt = (0, prompt_sync_1.default)();
function extractSTIGUrl(findingDetails) {
    const matches = findingDetails.match(/((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=+$,\w]+@)?[A-Za-z0-9.-]+|(?:www\.|[-;:&=+$,\w]+@)[A-Za-z0-9.-]+)((?:\/[+~%/.\w\-_]*)?\??(?:[-+=&;%@.\w_]*)#?(?:[.!/\\\w]*))?)/gs); // skipcq: JS-0113
    if (matches) {
        let match = '';
        matches.forEach(link => {
            const url = new URL(link);
            if (url.host === 'dl.dod.cyber.mil') {
                match = url.pathname.split('/').pop()?.replace('.zip', '') || '';
            }
        });
        return match;
    }
    return '';
}
exports.extractSTIGUrl = extractSTIGUrl;
function cklSeverityToPOAMSeverity(severity) {
    switch (severity) {
        case 'none': {
            return '';
        }
        case 'low': {
            return 'Low';
        }
        case 'medium': {
            return 'Moderate';
        }
        case 'high':
        case 'critical': {
            return 'High';
        }
        default: {
            throw new Error(`Invalid severity passed: ${severity}`);
        }
    }
}
exports.cklSeverityToPOAMSeverity = cklSeverityToPOAMSeverity;
function cklSeverityToRelevanceOfThreat(severity) {
    let severityAsThreat = '';
    switch (severity) {
        default: {
            severityAsThreat = 'Moderate';
            break;
        }
    }
    return severityAsThreat;
}
exports.cklSeverityToRelevanceOfThreat = cklSeverityToRelevanceOfThreat;
function cklSeverityToLikelihood(severity) {
    switch (severity) { // skipcq: JS-0045, JS-0047
        case 'none': {
            return '';
        }
        case 'low': {
            return 'Low';
        }
        case 'medium': {
            return 'Moderate';
        }
        case 'high':
        case 'critical': {
            return 'Moderate';
        }
    }
}
exports.cklSeverityToLikelihood = cklSeverityToLikelihood;
function cklSeverityToImpact(severity) {
    switch (severity) { // skipcq: JS-0045, JS-0047
        case 'none': {
            return '';
        }
        case 'low': {
            return 'Low';
        }
        case 'medium': {
            return 'Moderate';
        }
        case 'high':
        case 'critical': {
            return 'High';
        }
    }
}
exports.cklSeverityToImpact = cklSeverityToImpact;
function cklSeverityToResidualRiskLevel(severity) {
    switch (severity) { // skipcq: JS-0045, JS-0047
        case 'none': {
            return '';
        }
        case 'low': {
            return 'Low';
        }
        case 'medium': {
            return 'Moderate';
        }
        case 'high':
        case 'critical': {
            return 'Moderate';
        }
    }
}
exports.cklSeverityToResidualRiskLevel = cklSeverityToResidualRiskLevel;
function createCVD(vulnerability) {
    if (vulnerability.FINDING_DETAILS?.includes('Solution :')) {
        return `Rule Title: ${vulnerability.Rule_Title}\r\n\r\n${vulnerability.FINDING_DETAILS?.split('Solution :')[0]}`;
    }
    return `Rule Title: ${vulnerability.Rule_Title}\r\n\r\n${vulnerability.FINDING_DETAILS}`;
}
exports.createCVD = createCVD;
function convertToRawSeverity(severity) {
    switch (severity) { // skipcq: JS-0047
        case 'none': {
            return 'Unknown';
        }
        case 'low': {
            return 'III';
        }
        case 'medium': {
            return 'II';
        }
        case 'high':
        case 'critical': {
            return 'I';
        }
    }
}
exports.convertToRawSeverity = convertToRawSeverity;
function cleanStatus(status) {
    switch (status) {
        case 'Not_Applicable': {
            return 'Not Applicable';
        }
        case 'Open': {
            return 'Ongoing';
        }
        default: {
            return status;
        }
    }
}
exports.cleanStatus = cleanStatus;
function replaceSpecialCharacters(text) {
    return text.replaceAll("'", '`').replaceAll('"', '`').replaceAll('<', '(').replaceAll('>', ')').replaceAll('\\', '\\\\');
}
exports.replaceSpecialCharacters = replaceSpecialCharacters;
function cleanComments(comments) {
    return comments.replace(/Automated(.*?)project\.\n/, '').replaceAll(/Profile shasum.*/s, '').trim(); // skipcq: JS-0113
}
function combineComments(vulnerability, host) {
    if (vulnerability.STATUS === 'Open') {
        return `${vulnerability.Rule_ID} failed on ${host}\r\n${cleanComments(vulnerability.COMMENTS || '')}`;
    }
    return `${vulnerability.Rule_ID} not applicable on ${host}\r\n${cleanComments(vulnerability.COMMENTS || '')}\r\n\r\n${vulnerability.FINDING_DETAILS}`;
}
exports.combineComments = combineComments;
function extractSolution(findingDetails) {
    if (findingDetails.includes('Solution')) {
        const matches = findingDetails.match(/Solution(.*)Message/gs); // skipcq: JS-0113
        if (matches && matches.length !== 0) {
            const text = matches.join('').split('Solution : ')[1].trim();
            if (text.includes('Message:')) {
                return text.split('Message:')[0].trim();
            }
            return text;
        }
        return '';
    }
    return '';
}
exports.extractSolution = extractSolution;
function cci2nist(cci) {
    if (typeof cci === 'string') {
        if (cci in hdf_converters_1.CciNistMappingData.data) {
            return hdf_converters_1.CciNistMappingData.data[cci].replace(' ', '');
        }
        return prompt(`What is the NIST ID for CCI ${cci}? `);
    }
    return 'UM-1';
}
exports.cci2nist = cci2nist;
