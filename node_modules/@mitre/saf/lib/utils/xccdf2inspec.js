"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.inspecControlToRubyCode = exports.impactNumberToSeverityString = exports.severityStringToImpact = exports.convertEncodedHTMLIntoJson = exports.convertEncodedXmlIntoJson = exports.wrap = void 0;
const tslib_1 = require("tslib");
const fast_xml_parser_1 = (0, tslib_1.__importDefault)(require("fast-xml-parser"));
const htmlparser = (0, tslib_1.__importStar)(require("htmlparser2"));
const lodash_1 = (0, tslib_1.__importDefault)(require("lodash"));
// Breaks lines down to lineLength number of characters
function wrap(s, lineLength = 80) {
    return s.replace(new RegExp(`(?![^\n]{1,${lineLength}}$)([^\n]{1,${lineLength}})`, 'g'), '$1\n');
}
exports.wrap = wrap;
const escapeQuotes = (s) => s.replace(/\\/g, '\\\\').replace(/'/g, "\\'"); // Escape backslashes and quotes
const escapeDoubleQuotes = (s) => s.replace(/\\/g, '\\\\').replace(/"/g, '\\"'); // Escape backslashes and double quotes
const wrapAndEscapeQuotes = (s, lineLength) => escapeDoubleQuotes(wrap(s, lineLength)); // Escape backslashes and quotes, and wrap long lines
function convertEncodedXmlIntoJson(encodedXml) {
    return fast_xml_parser_1.default.parse(encodedXml, {
        ignoreAttributes: false,
        attributeNamePrefix: '@_',
    });
}
exports.convertEncodedXmlIntoJson = convertEncodedXmlIntoJson;
function convertEncodedHTMLIntoJson(encodedHTML) {
    if (encodedHTML) {
        // Some STIGs regarding XSS put the < character inside of the description which breaks parsing
        const patchedHTML = encodedHTML.replace(/"&lt;"/g, '[[[REPLACE_LESS_THAN]]]');
        const xmlChunks = [];
        const htmlParser = new htmlparser.Parser({
            ontext(text) {
                xmlChunks.push(text);
            },
        });
        htmlParser.write(patchedHTML);
        htmlParser.end();
        const converted = convertEncodedXmlIntoJson(xmlChunks.join(''));
        let cleaned = {};
        if (typeof converted.VulnDiscussion === 'object') { // Some STIGs have xml tags inside of the actual text which breaks processing, e.g U_ASD_STIG_V5R1_Manual-xccdf.xml and all Oracle Database STIGs
            let extractedVulnDescription = '';
            const remainingFields = lodash_1.default.omit(converted.VulnDiscussion, ['FalsePositives', 'FalseNegatives', 'Documentable', 'Mitigations', 'SeverityOverrideGuidance', 'PotentialImpacts', 'ThirdPartyTools', 'MitigationControl', 'Responsibility', 'IAControls']);
            Object.entries(remainingFields).forEach(([field, value]) => {
                extractedVulnDescription += `<${field}> ${value}`;
            });
            cleaned = {
                VulnDiscussion: extractedVulnDescription.replace(/\[\[\[REPLACE_LESS_THAN]]]/, '"<"'),
            };
            Object.entries(converted.VulnDiscussion).forEach(([key, value]) => {
                if (typeof value === 'string') {
                    cleaned[key] = value.replace(/\[\[\[REPLACE_LESS_THAN]]]/, '"<"');
                }
                else {
                    cleaned[key] = value;
                }
            });
        }
        else {
            Object.entries(converted).forEach(([key, value]) => {
                if (typeof value === 'string') {
                    cleaned[key] = value.replace(/\[\[\[REPLACE_LESS_THAN]]]/, '"<"');
                }
                else {
                    cleaned[key] = value;
                }
            });
        }
        return cleaned;
    }
    return {};
}
exports.convertEncodedHTMLIntoJson = convertEncodedHTMLIntoJson;
function severityStringToImpact(string) {
    var _a, _b, _c, _d, _e;
    if ((_a = string.match(/none|na|n\/a|not[\s()*_|]?applicable/i)) === null || _a === void 0 ? void 0 : _a.length) {
        return 0.0;
    }
    if ((_b = string.match(/low|cat(egory)?\s*(iii|3)/i)) === null || _b === void 0 ? void 0 : _b.length) {
        return 0.3;
    }
    if ((_c = string.match(/med(ium)?|cat(egory)?\s*(ii|2)/)) === null || _c === void 0 ? void 0 : _c.length) {
        return 0.5;
    }
    if ((_d = string.match(/high|cat(egory)?\s*(i|1)/)) === null || _d === void 0 ? void 0 : _d.length) {
        return 0.7;
    }
    if ((_e = string.match(/crit(ical)?|severe/)) === null || _e === void 0 ? void 0 : _e.length) {
        return 1.0;
    }
    throw new Error(`${string}' is not a valid severity value. It should be one of the approved keywords`);
}
exports.severityStringToImpact = severityStringToImpact;
function impactNumberToSeverityString(impact) {
    // Impact must be 0.0 - 1.0
    if (impact < 0.0 || impact > 1.0) {
        throw new Error('Impact cannot be less than 0.0 or greater than 1.0');
    }
    else {
        if (impact >= 0.9) {
            return 'critical';
        }
        if (impact >= 0.7) {
            return 'high';
        }
        if (impact >= 0.4) {
            return 'medium';
        }
        if (impact >= 0.1) {
            return 'low';
        }
        return 'none';
    }
}
exports.impactNumberToSeverityString = impactNumberToSeverityString;
function inspecControlToRubyCode(control, lineLength) {
    let result = '# encoding: UTF-8\n\n';
    result += `control "${control.id}" do\n`;
    if (control.title) {
        result += `  title "${wrapAndEscapeQuotes(control.title, lineLength)}"\n`;
    }
    else {
        console.error(`${control.id} does not have a title`);
    }
    if (control.desc) {
        result += `  desc "${wrapAndEscapeQuotes(control.desc, lineLength)}"\n`;
    }
    else {
        console.error(`${control.id} does not have a desc`);
    }
    if (control.descs) {
        Object.entries(control.descs).forEach(([key, desc]) => {
            if (desc) {
                result += `  desc "${key}", "${wrapAndEscapeQuotes(desc, lineLength)}"\n`;
            }
            else {
                console.error(`${control.id} does not have a desc for the value ${key}`);
            }
        });
    }
    if (control.impact) {
        result += `  impact ${control.impact}\n`;
    }
    else {
        console.error(`${control.id} does not have an impact, please define impact within your mapping file or set tags.severity to set automatically`);
    }
    if (control.refs) {
        control.refs.forEach(ref => {
            result += `  ref '${escapeQuotes(ref)}'\n`;
        });
    }
    Object.entries(control.tags).forEach(([tag, value]) => {
        if (value) {
            if (typeof value === 'object') {
                if (Array.isArray(value) && typeof value[0] === 'string') {
                    result += `  tag ${tag}: ${JSON.stringify(value)}\n`;
                }
                else {
                    // Convert JSON Object to Ruby Hash
                    const stringifiedObject = JSON.stringify(value, null, 2)
                        .replace(/\n/g, '\n  ')
                        .replace(/\{\n {6}/g, '{')
                        .replace(/\[\n {8}/g, '[')
                        .replace(/\n {6}\]/g, ']')
                        .replace(/\n {4}\}/g, '}')
                        .replace(/": \[/g, '" => [');
                    result += `  tag ${tag}: ${stringifiedObject}\n`;
                }
            }
            else if (typeof value === 'string') {
                result += `  tag ${tag}: "${wrapAndEscapeQuotes(value, lineLength)}"\n`;
            }
        }
    });
    result += 'end';
    return result;
}
exports.inspecControlToRubyCode = inspecControlToRubyCode;
