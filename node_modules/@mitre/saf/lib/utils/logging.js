"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWinstonLogger = createWinstonLogger;
exports.getHDFSummary = getHDFSummary;
const tslib_1 = require("tslib");
const winston_1 = require("winston");
const inspecjs_1 = require("inspecjs");
const colors_1 = tslib_1.__importDefault(require("colors"));
// Use user defined colors. Used by the console log transporter
const syslogColors = {
    debug: 'blue',
    info: 'cyan',
    notice: 'white',
    warn: 'magenta',
    warning: 'bold magenta',
    error: 'bold red',
    verbose: 'blue',
    crit: 'inverse yellow',
    alert: 'bold inverse red',
    emerg: 'bold inverse magenta',
};
/**
 * createWinstonLogger function creates a Winston logger.
 * @param {string} mapperName     - The name of the mapper.
 * @param {string} [level='info'] - The log level. Default is 'info'.
 * @returns {Logger}              - A Winston logger.
 */
function createWinstonLogger(mapperName, level = 'info') {
    const transportList = [new winston_1.transports.File({ filename: 'saf-cli.log' })];
    if ((process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') || level === 'verbose') {
        transportList.push(new winston_1.transports.Console({
            format: winston_1.format.combine(winston_1.format.colorize({
                all: true,
                colors: syslogColors,
            }), winston_1.format.simple(), winston_1.format.timestamp({
                format: 'MMM-DD-YYYY HH:mm:ss Z',
            }), winston_1.format.errors({ stack: true }), winston_1.format.printf(info => colors_1.default.yellow(`[${[info.timestamp]} -> ${mapperName}]:`) + ` ${info.message}`)),
        }));
    }
    return (0, winston_1.createLogger)({
        transports: transportList,
        level,
    });
}
/**
 * The function `getHDFSummary` takes an execution object and returns a summary string containing
 * information about the profiles, passed/failed/not applicable/not reviewed counts.
 * @param {ExecJSON.Execution} hdf - The `hdf` parameter is of type `ExecJSON.Execution` which represents the execution of a set of controls against a target.
 * @returns {string} A string that represents a summary of the execution.
 */
function getHDFSummary(hdf) {
    let summary = 'Execution<';
    const summaryObject = {
        profileNames: [],
        controlCount: 0,
        passedCount: 0,
        failedCount: 0,
        notApplicableCount: 0,
        notReviewedCount: 0,
        errorCount: 0,
    };
    const contextualizedEvaluation = (0, inspecjs_1.contextualizeEvaluation)(hdf);
    contextualizedEvaluation.contains.forEach((profile) => {
        summaryObject.profileNames.push(profile.data.name);
    });
    const controls = contextualizedEvaluation.contains.flatMap(profile => profile.contains);
    controls.forEach((control) => {
        switch (control.hdf.status) {
            case 'Passed': {
                summaryObject.passedCount += 1;
                break;
            }
            case 'Failed': {
                summaryObject.failedCount += 1;
                break;
            }
            case 'Not Applicable': {
                summaryObject.notApplicableCount += 1;
                break;
            }
            case 'Not Reviewed': {
                summaryObject.notReviewedCount += 1;
                break;
            }
            case 'Profile Error': {
                summaryObject.errorCount += 1;
                break;
            }
            default:
        }
    });
    summary += `Profiles: [Profile<${summaryObject.profileNames.join('> Profile<')}>], Passed=${summaryObject.passedCount}, Failed=${summaryObject.failedCount}, Not Applicable=${summaryObject.notApplicableCount}, Not Reviewed=${summaryObject.notReviewedCount}>`;
    return summary;
}
//# sourceMappingURL=logging.js.map