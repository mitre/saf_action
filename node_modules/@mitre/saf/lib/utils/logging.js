"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHDFSummary = exports.createWinstonLogger = void 0;
const winston_1 = require("winston");
const inspecjs_1 = require("inspecjs");
/**
 * createWinstonLogger function creates a Winston logger.
 * @param {string} mapperName - The name of the mapper.
 * @param {string} [level='info'] - The log level. Default is 'info'.
 * @returns {Logger} A Winston logger.
 */
function createWinstonLogger(mapperName, level = 'info') {
    const transportList = [
        new winston_1.transports.File({ filename: 'saf-cli.log' }),
    ];
    if ((process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') || level === 'verbose') {
        transportList.push(new winston_1.transports.Console());
    }
    return (0, winston_1.createLogger)({
        transports: transportList,
        level,
        format: winston_1.format.combine(winston_1.format.timestamp({
            format: 'MMM-DD-YYYY HH:mm:ss Z',
        }), winston_1.format.printf(info => `[${[info.timestamp]}] ${mapperName} ${info.message}`)),
    });
}
exports.createWinstonLogger = createWinstonLogger;
/**
 * The function `getHDFSummary` takes an execution object and returns a summary string containing
 * information about the profiles, passed/failed/not applicable/not reviewed counts.
 * @param {ExecJSON.Execution} hdf - The `hdf` parameter is of type `ExecJSON.Execution` which represents the execution of a set of controls against a target.
 * @returns {string} A string that represents a summary of the execution.
 */
function getHDFSummary(hdf) {
    let summary = 'Execution<';
    const summaryObject = {
        profileNames: [],
        controlCount: 0,
        passedCount: 0,
        failedCount: 0,
        notApplicableCount: 0,
        notReviewedCount: 0,
        errorCount: 0,
    };
    const contextualizedEvaluation = (0, inspecjs_1.contextualizeEvaluation)(hdf);
    contextualizedEvaluation.contains.forEach(profile => {
        summaryObject.profileNames.push(profile.data.name);
    });
    const controls = contextualizedEvaluation.contains.flatMap(profile => profile.contains);
    controls.forEach(control => {
        switch (control.hdf.status) {
            case 'Passed': {
                summaryObject.passedCount += 1;
                break;
            }
            case 'Failed': {
                summaryObject.failedCount += 1;
                break;
            }
            case 'Not Applicable': {
                summaryObject.notApplicableCount += 1;
                break;
            }
            case 'Not Reviewed': {
                summaryObject.notReviewedCount += 1;
                break;
            }
            case 'Profile Error': {
                summaryObject.errorCount += 1;
                break;
            }
            default:
        }
    });
    summary += `Profiles: [Profile<${summaryObject.profileNames.join('> Profile<')}>], Passed=${summaryObject.passedCount}, Failed=${summaryObject.failedCount}, Not Applicable=${summaryObject.notApplicableCount}, Not Reviewed=${summaryObject.notReviewedCount}>`;
    return summary;
}
exports.getHDFSummary = getHDFSummary;
//# sourceMappingURL=logging.js.map