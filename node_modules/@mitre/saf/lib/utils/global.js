"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkInput = exports.getDescription = exports.getProfileInfo = exports.extractValueViaPathOrNumber = exports.arrayNeededPaths = exports.arrayedPaths = exports.getInstalledPath = exports.dataURLtoU8Array = exports.convertFullPathToFilename = exports.checkSuffix = exports.knownInspecMetadataKeys = void 0;
const tslib_1 = require("tslib");
const hdf_converters_1 = require("@mitre/hdf-converters");
const get_installed_path_1 = require("get-installed-path");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const path_1 = tslib_1.__importDefault(require("path"));
exports.knownInspecMetadataKeys = ['control', 'title', 'desc', 'description', 'rationale', 'impact', 'references', 'tag'];
function checkSuffix(input) {
    if (input.endsWith('.json')) {
        return input;
    }
    return `${input}.json`;
}
exports.checkSuffix = checkSuffix;
// replacement for path.basename since it doesn't "just work" as one would expect with handling paths from other filesystem types
function convertFullPathToFilename(inputPath) {
    let filePath = inputPath.split('/');
    let basename = filePath.at(-1);
    if (!basename) {
        throw new Error('Could not derive basename from file path');
    }
    filePath = basename.split('\\');
    basename = filePath.at(-1);
    if (!basename) {
        throw new Error('Could not derive basename from file path');
    }
    return basename;
}
exports.convertFullPathToFilename = convertFullPathToFilename;
function dataURLtoU8Array(dataURL) {
    const arr = dataURL.split(',');
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    while (n--) {
        // eslint-disable-next-line unicorn/prefer-code-point
        u8arr[n] = bstr.charCodeAt(n);
    }
    return u8arr;
}
exports.dataURLtoU8Array = dataURLtoU8Array;
function getInstalledPath() {
    let installedPath = '';
    try {
        installedPath = (0, get_installed_path_1.getInstalledPathSync)('@mitre/saf');
    }
    catch {
        // eslint-disable-next-line unicorn/prefer-module
        installedPath = path_1.default.join(require.main?.path.replace('/bin', '').replace('\\bin', '') || '.');
    }
    return installedPath;
}
exports.getInstalledPath = getInstalledPath;
exports.arrayedPaths = ['tags.cci', 'tags.nist'];
function arrayNeededPaths(typeOfPath, values) {
    // Converts CCI and NIST values to Arrays
    if (exports.arrayedPaths.includes(typeOfPath.toLowerCase())) {
        return [values];
    }
    return values;
}
exports.arrayNeededPaths = arrayNeededPaths;
function extractValueViaPathOrNumber(typeOfPathOrNumber, pathOrNumber, data) {
    // Maps paths from mapping file to target value
    if (typeof pathOrNumber === 'string') {
        return arrayNeededPaths(typeOfPathOrNumber, lodash_1.default.get(data, pathOrNumber));
    }
    if (Array.isArray(pathOrNumber)) {
        const foundPath = pathOrNumber.find(item => lodash_1.default.get(data, item)) || 'Field Not Defined';
        return arrayNeededPaths(typeOfPathOrNumber, lodash_1.default.get(data, foundPath));
    }
    if (typeof pathOrNumber === 'number') {
        return pathOrNumber;
    }
}
exports.extractValueViaPathOrNumber = extractValueViaPathOrNumber;
function getProfileInfo(evaluation, fileName) {
    let result = '';
    const profile = lodash_1.default.get(evaluation, 'data.profiles[0]');
    result += `File Name: ${fileName}\n`;
    if (profile.version) {
        result += `Version: ${profile.version}\n`;
    }
    if (profile.sha256) {
        result += `SHA256 Hash: ${profile.sha256}\n`;
    }
    if (profile.maintainer) {
        result += `Maintainer: ${profile.maintainer}\n`;
    }
    if (profile.copyright) {
        result += `Copyright: ${profile.copyright}\n`;
    }
    if (profile.copyright_email) {
        result += `Copyright Email: ${profile.copyright_email}\n`;
    }
    if (profile.controls.length) {
        result += `Control Count: ${profile.controls.length}\n`;
    }
    return result.trim();
}
exports.getProfileInfo = getProfileInfo;
// Get description from Array of descriptions or Key/String pair
function getDescription(descriptions, key) {
    return Array.isArray(descriptions) ? descriptions.find((description) => description.label.toLowerCase() === key)?.data : lodash_1.default.get(descriptions, key);
}
exports.getDescription = getDescription;
// Check if file input is of given type - throw error if not
function checkInput(guessOptions, desiredType, desiredFormat) {
    const detectedType = (0, hdf_converters_1.fingerprint)({ data: guessOptions.data, filename: convertFullPathToFilename(guessOptions.filename) });
    if (!(detectedType === desiredType))
        throw new Error(`Unable to process input file\
      \nDetected input type: ${detectedType === '' ? 'unknown or none' : `${detectedType} - did you mean to run the ${detectedType} to HDF converter instead?`}\
      \nPlease ensure the input is a valid ${desiredFormat}`);
}
exports.checkInput = checkInput;
