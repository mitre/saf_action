"use strict";
// utils/calculations.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateTotalCounts = exports.calculateSeverityCounts = exports.calculateTotalCountsForSummaries = exports.calculateComplianceScoresForExecJSONs = exports.calculateSummariesForExecJSONs = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const flat_1 = tslib_1.__importDefault(require("flat"));
const threshold_1 = require("../threshold");
const logging_1 = require("../logging");
/**
* The logger for this command.
 * It uses a Winston logger with the label 'view summary:'.
 * @property {ReturnType<typeof createWinstonLogger>} logger - The logger for this command. It uses a Winston logger with the label 'view summary:'.
 */
const logger = (0, logging_1.createWinstonLogger)('View Summary:');
/**
 * Calculates the summaries for the provided execution JSONs.
 * @param execJSONs - An object mapping file paths to their corresponding execution JSONs.
 * @returns An object containing the calculated summaries.
 */
function calculateSummariesForExecJSONs(execJSONs) {
    logger.verbose('In calculateSummariesForExecJSONs');
    const summaries = {};
    Object.values(execJSONs).forEach(parsedExecJSON => {
        const summary = {};
        const parsedProfile = parsedExecJSON.contains[0];
        const profileName = parsedProfile.data.name;
        calculateSeverityCounts(summary, parsedProfile);
        calculateTotalCounts(summary);
        summaries[profileName] = (lodash_1.default.get(summaries, profileName) || []);
        summaries[profileName].push(summary);
    });
    return summaries;
}
exports.calculateSummariesForExecJSONs = calculateSummariesForExecJSONs;
/**
 * Calculates the compliance scores for the provided execution JSONs.
 * @param execJSONs - An object mapping file paths to their corresponding execution JSONs.
 * @returns An object containing the calculated compliance scores.
 */
function calculateComplianceScoresForExecJSONs(execJSONs) {
    logger.verbose('In calculateComplianceScoresForExecJSONs');
    const complianceScores = {};
    Object.values(execJSONs).forEach(parsedExecJSON => {
        const parsedProfile = parsedExecJSON.contains[0];
        const profileName = parsedProfile.data.name;
        const overallStatusCounts = (0, threshold_1.extractStatusCounts)(parsedProfile);
        const overallCompliance = (0, threshold_1.calculateCompliance)(overallStatusCounts);
        const existingCompliance = lodash_1.default.get(complianceScores, profileName) || [];
        existingCompliance.push(overallCompliance);
        lodash_1.default.set(complianceScores, `["${profileName.replaceAll('"', '\\"')}"]`, existingCompliance);
    });
    return complianceScores;
}
exports.calculateComplianceScoresForExecJSONs = calculateComplianceScoresForExecJSONs;
/**
 * Calculates the totals for the provided summaries.
 * @param summaries - The summaries to calculate the totals for.
 * @returns An object containing the calculated totals.
 */
function calculateTotalCountsForSummaries(summaries) {
    logger.verbose('In calculateTotalCountsForSummaries');
    const totals = {};
    Object.entries(summaries).forEach(([profileName, profileSummaries]) => {
        profileSummaries.forEach(profileSummary => {
            const flattened = flat_1.default.flatten(profileSummary);
            Object.entries(flattened).forEach(([key, value]) => {
                const existingValue = lodash_1.default.get(totals, `${profileName}.${key}`, 0);
                if (typeof existingValue === 'number') {
                    lodash_1.default.set(totals, `["${profileName.replaceAll('"', '\\"')}"].${key}`, existingValue + value);
                }
                else {
                    lodash_1.default.set(totals, `["${profileName.replaceAll('"', '\\"')}"].${key}`, value);
                }
            });
        });
    });
    return totals;
}
exports.calculateTotalCountsForSummaries = calculateTotalCountsForSummaries;
/**
 * Calculates the severity counts for the provided summary and profile.
 * @param summary - The summary to calculate the severity counts for.
 * @param parsedProfile - The profile to use for the calculation.
 * @returns void - This method does not return anything, it modifies the 'summary' object passed as a parameter.
 */
function calculateSeverityCounts(summary, parsedProfile) {
    logger.verbose('In calculateComplianceScoresForExecJSONs');
    for (const [severity, severityTargets] of Object.entries(threshold_1.severityTargetsObject)) {
        const severityStatusCounts = (0, threshold_1.extractStatusCounts)(parsedProfile, severity);
        for (const severityTarget of severityTargets) {
            const [statusName, _severity, thresholdType] = severityTarget.split('.');
            lodash_1.default.set(summary, severityTarget.replace(`.${thresholdType}`, ''), lodash_1.default.get(severityStatusCounts, (0, threshold_1.renameStatusName)(statusName)));
        }
    }
}
exports.calculateSeverityCounts = calculateSeverityCounts;
/**
 * Calculates the total counts for the provided summary.
 * @param summary - The summary to calculate the total counts for.
 * @returns void - This method does not return anything, it modifies the 'summary' object passed as a parameter.
 */
function calculateTotalCounts(summary) {
    logger.verbose('In calculateTotalCounts');
    for (const [type, counts] of Object.entries(summary)) {
        const total = Object.values(counts).reduce((a, b) => a + b, 0);
        lodash_1.default.set(summary, `${type}.total`, total);
    }
}
exports.calculateTotalCounts = calculateTotalCounts;
//# sourceMappingURL=calculations.js.map