"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stderr = exports.stdout = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
/* eslint-disable unicorn/import-style */
const util = tslib_1.__importStar(require("util")); // skipcq: JS-C1003 - util does not expose itself as an ES Module.
/* eslint-enable unicorn/import-style */
const core_1 = require("@oclif/core");
/*
  Override the showCommandHelp (called directly for single-command CLIs) method defined in the oclif Help class.
  This is done to modify how the arguments are displayed (uppercase), which obscures how to use
  the arguments, as some are named in lowercase or camelCase format. The override method implemented here only affects help
  calls for commands that provide arguments.

  To prevent this override from being used, remove the filepath of this help class in oclif's config in package.json.
  The help is defined in the package.json "oclif" section:
    "oclif": {
      "helpClass": "./lib/help/help"
      ...
    }

  How does it work:
    1 - When the showCommandHelp is called, we store the arguments (if provided) into a Map object with key
        of the argument name in uppercase and the value as the argument name in its natural format.
    2 - Next, we call a modified log method with the generated Map object
    3 - The modified log method replaces the formatted ARGUMENTS list with its natural format.

  For additional information, reference the oclif Help Classes (https://oclif.io/docs/help_classes)
*/
class MyHelpClass extends core_1.Help {
    async showCommandHelp(command) {
        const name = command.id;
        const depth = name.split(':').length;
        const subTopics = this.sortedTopics.filter(t => t.name.startsWith(name + ':') && t.name.split(':').length === depth + 1);
        const subCommands = this.sortedCommands.filter(c => c.id.startsWith(name + ':') && c.id.split(':').length === depth + 1);
        const summary = this.summary(command);
        if (summary) {
            this.log(summary + '\n');
        }
        const hasArgs = lodash_1.default.has(command.args, 'name');
        if (hasArgs) {
            const argNamesMap = new Map();
            lodash_1.default.forOwn(command.args, function (value, key) {
                if (key !== 'name') {
                    const argName = lodash_1.default.get(command.args[key], 'name');
                    argNamesMap.set(argName.toUpperCase(), argName);
                }
            });
            this.logModify(argNamesMap, this.formatCommand(command));
        }
        else {
            this.log(this.formatCommand(command));
        }
        this.log('');
        if (subTopics.length > 0) {
            this.log(this.formatTopics(subTopics));
            this.log('');
        }
        if (subCommands.length > 0) {
            const aliases = [];
            const uniqueSubCommands = subCommands.filter(p => {
                aliases.push(...p.aliases);
                return !aliases.includes(p.id);
            });
            this.log(this.formatCommands(uniqueSubCommands));
            this.log('');
        }
    }
    logModify(argNamesMap, ...args) {
        // Iterate over the argNamesMap using object destructuring
        // Replace the uppercase values with its natural format value
        for (const [key, value] of argNamesMap) {
            args[0] = args[0].replace(key, value);
        }
        exports.stdout.write(util.format.apply(this, args) + '\n'); // skipcq: JS-0357
    }
    log(...args) {
        exports.stdout.write(util.format.apply(this, args) + '\n'); // skipcq: JS-0357
    }
}
exports.default = MyHelpClass;
/**
 * A wrapper around process.stdout and process.stderr that allows us to mock out the streams for testing.
 */
class Stream {
    channel;
    constructor(channel) {
        this.channel = channel;
    }
    write(data) {
        return process[this.channel].write(data);
    }
}
exports.stdout = new Stream('stdout');
exports.stderr = new Stream('stderr');
