"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SonarQubeMapper = exports.SonarQubeResults = void 0;
const axios_1 = __importDefault(require("axios"));
const inspecjs_1 = require("inspecjs");
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const CweNistMapping_1 = require("./mappings/CweNistMapping");
const OwaspNistMapping_1 = require("./mappings/OwaspNistMapping");
const IMPACT_MAPPING = new Map([
    ['blocker', 1.0],
    ['critical', 0.7],
    ['major', 0.5],
    ['minor', 0.3],
    ['info', 0.0]
]);
const CWE_NIST_MAPPING = new CweNistMapping_1.CweNistMapping();
const OWASP_NIST_MAPPING = new OwaspNistMapping_1.OwaspNistMapping();
function formatCodeDesc(vulnerability) {
    const typedVulnerability = vulnerability;
    if (typedVulnerability.textRange) {
        const snipHtml = `StartLine: ${typedVulnerability.textRange.startLine}, EndLine: ${typedVulnerability.textRange.endLine}<br>Code:<pre>${typedVulnerability.snip}</pre>`;
        return `Path:${typedVulnerability.component}:${typedVulnerability.textRange.startLine}:${typedVulnerability.textRange.endLine} ${snipHtml}`;
    }
    else {
        return '';
    }
}
function parseNistTags(issue) {
    var _a, _b;
    const tags = [];
    (_a = issue.sysTags) === null || _a === void 0 ? void 0 : _a.forEach((sysTag) => {
        if (sysTag.toLowerCase().startsWith('owasp-')) {
            const identifier = [
                sysTag.toLowerCase().replace('owasp-', '').toUpperCase()
            ];
            tags.push(...OWASP_NIST_MAPPING.nistFilterNoDefault(identifier));
        }
    });
    (_b = issue.summary.match(/CWE-\d\d\d?\d?\d?\d?\d/gi)) === null || _b === void 0 ? void 0 : _b.forEach((match) => {
        tags.push(...CWE_NIST_MAPPING.nistFilter(match.split('-')[1]));
    });
    return tags;
}
class SonarQubeResults {
    constructor(sonarQubeHost, projectId, userToken) {
        this.data = {
            issues: []
        };
        this.sonarQubeHost = '';
        this.projectId = '';
        this.userToken = '';
        this.sonarQubeHost = sonarQubeHost;
        this.projectId = projectId;
        this.userToken = userToken;
    }
    async toHdf() {
        return this.getProjectData();
    }
    async getProjectData() {
        var _a, _b;
        let paging = true;
        let page = 1;
        while (paging) {
            await axios_1.default
                .get(`${this.sonarQubeHost}/api/issues/search`, {
                auth: { username: this.userToken, password: '' },
                params: {
                    componentKeys: this.projectId,
                    types: 'VULNERABILITY',
                    p: page
                }
            })
                .then(({ data }) => {
                var _a;
                if (data.issues) {
                    this.data.issues.push(...data.issues);
                }
                paging = ((_a = data.paging) === null || _a === void 0 ? void 0 : _a.total) === 100;
                page += 1;
            });
        }
        let requests = [];
        (_a = this.data.issues) === null || _a === void 0 ? void 0 : _a.forEach((issue) => {
            requests.push(axios_1.default.get(`${this.sonarQubeHost}/api/sources/raw`, {
                auth: { username: this.userToken, password: '' },
                params: {
                    key: issue.component
                }
            }));
        });
        await axios_1.default.all(requests).then(axios_1.default.spread((...responses) => {
            responses.forEach((response, index) => {
                var _a, _b;
                this.data.issues[index].snip = response.data
                    .split('\n')
                    .slice(((_a = this.data.issues[index].textRange) === null || _a === void 0 ? void 0 : _a.startLine) - 3, ((_b = this.data.issues[index].textRange) === null || _b === void 0 ? void 0 : _b.endLine) + 3)
                    .join('\n');
            });
        }));
        requests = [];
        (_b = this.data.issues) === null || _b === void 0 ? void 0 : _b.forEach((issue) => {
            requests.push(axios_1.default.get(`${this.sonarQubeHost}/api/rules/show`, {
                auth: { username: this.userToken, password: '' },
                params: {
                    key: issue.rule
                }
            }));
        });
        await axios_1.default.all(requests).then(axios_1.default.spread((...responses) => {
            responses.forEach((response, index) => {
                this.data.issues[index].sysTags = response.data.rule.sysTags;
                this.data.issues[index].name = response.data.rule.name;
                this.data.issues[index].summary = response.data.rule.htmlDesc;
            });
        }));
        const result = new SonarQubeMapper(this.data, this.projectId);
        return result.toHdf();
    }
    setMappings(customMapping) {
        this.customMapping = customMapping;
    }
}
exports.SonarQubeResults = SonarQubeResults;
function createSonarqubeMappings(projectName) {
    return {
        platform: {
            name: 'Heimdall Tools',
            release: package_json_1.version,
            target_id: projectName
        },
        version: package_json_1.version,
        statistics: {
            duration: null
        },
        profiles: [
            {
                name: 'Sonarqube Scan',
                version: null,
                title: `SonarQube Scan of Project ${projectName}`,
                maintainer: null,
                summary: `SonarQube Scan of Project ${projectName}`,
                license: null,
                copyright: null,
                copyright_email: null,
                supports: [],
                attributes: [],
                depends: [],
                groups: [],
                status: 'loaded',
                controls: [
                    {
                        path: 'issues',
                        key: 'id',
                        desc: { path: 'summary' },
                        descriptions: [],
                        refs: [],
                        source_location: {},
                        id: { path: 'rule' },
                        title: { path: 'name' },
                        impact: {
                            path: 'severity',
                            transformer: (0, base_converter_1.impactMapping)(IMPACT_MAPPING)
                        },
                        code: null,
                        tags: {
                            nist: { transformer: parseNistTags }
                        },
                        results: [
                            {
                                status: inspecjs_1.ExecJSON.ControlResultStatus.Failed,
                                code_desc: { transformer: formatCodeDesc },
                                run_time: 0,
                                start_time: ''
                            }
                        ]
                    }
                ],
                sha256: ''
            }
        ]
    };
}
class SonarQubeMapper extends base_converter_1.BaseConverter {
    constructor(issuesJSON, projectName) {
        super(issuesJSON);
        this.projectName = '';
        this.setMappings(createSonarqubeMappings(projectName));
    }
    setMappings(customMappings) {
        super.setMappings(customMappings);
    }
}
exports.SonarQubeMapper = SonarQubeMapper;
//# sourceMappingURL=sonarqube-mapper.js.map