"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SonarQubeMapper = exports.SonarQubeResults = void 0;
const axios_1 = __importDefault(require("axios"));
const inspecjs_1 = require("inspecjs");
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const CweNistMapping_1 = require("./mappings/CweNistMapping");
const OwaspNistMapping_1 = require("./mappings/OwaspNistMapping");
const global_1 = require("./utils/global");
const IMPACT_MAPPING = new Map([
    ['blocker', 1.0],
    ['critical', 0.7],
    ['major', 0.5],
    ['minor', 0.3],
    ['info', 0.0]
]);
const CWE_NIST_MAPPING = new CweNistMapping_1.CweNistMapping();
const OWASP_NIST_MAPPING = new OwaspNistMapping_1.OwaspNistMapping();
function formatCodeDesc(vulnerability) {
    const typedVulnerability = vulnerability;
    if (typedVulnerability.textRange) {
        const snipHtml = `StartLine: ${typedVulnerability.textRange.startLine}, EndLine: ${typedVulnerability.textRange.endLine}<br>Code:<pre>${typedVulnerability.snip}</pre>`;
        return `Path:${typedVulnerability.component}:${typedVulnerability.textRange.startLine}:${typedVulnerability.textRange.endLine} ${snipHtml}`;
    }
    else {
        return '';
    }
}
function parseNistTags(issue) {
    var _a, _b;
    const tags = [];
    (_a = issue.sysTags) === null || _a === void 0 ? void 0 : _a.forEach((sysTag) => {
        if (sysTag.toLowerCase().startsWith('owasp-')) {
            const identifier = [
                sysTag.toLowerCase().replace('owasp-', '').toUpperCase()
            ];
            tags.push(...OWASP_NIST_MAPPING.nistFilterNoDefault(identifier));
        }
    });
    (_b = issue.summary.match(/CWE-\d\d\d?\d?\d?\d?\d/gi)) === null || _b === void 0 ? void 0 : _b.forEach((match) => {
        tags.push(...CWE_NIST_MAPPING.nistFilter(match.split('-')[1]));
    });
    return tags;
}
class SonarQubeResults {
    constructor(sonarQubeHost, projectId, userToken, branchName, pullRequestID) {
        this.data = {
            issues: []
        };
        this.sonarQubeHost = '';
        this.projectId = '';
        this.userToken = '';
        this.branchName = '';
        this.pullRequestID = '';
        this.sonarQubeHost = sonarQubeHost;
        this.projectId = projectId;
        this.userToken = userToken;
        this.branchName = branchName;
        this.pullRequestID = pullRequestID;
    }
    async toHdf() {
        return this.getProjectData();
    }
    async getProjectData() {
        var _a, _b;
        let paging = true;
        let page = 1;
        while (paging) {
            await axios_1.default
                .get(`${this.sonarQubeHost}/api/issues/search`, {
                auth: { username: this.userToken, password: '' },
                params: {
                    componentKeys: this.projectId,
                    types: 'VULNERABILITY',
                    statuses: 'OPEN,REOPENED,CONFIRMED,RESOLVED',
                    p: page,
                    ...(this.branchName && { branch: this.branchName }),
                    ...(this.pullRequestID && { pullRequest: this.pullRequestID })
                }
            })
                .then(({ data }) => {
                var _a;
                if (data.issues) {
                    this.data.issues.push(...data.issues);
                }
                paging = ((_a = data.paging) === null || _a === void 0 ? void 0 : _a.total) === 100;
                page += 1;
            });
        }
        await Promise.all((_a = this.data.issues) === null || _a === void 0 ? void 0 : _a.map((issue) => axios_1.default
            .get(`${this.sonarQubeHost}/api/sources/raw`, {
            auth: { username: this.userToken, password: '' },
            params: {
                key: issue.component,
                ...(this.branchName && { branch: this.branchName })
            }
        })
            .then((response) => {
            var _a, _b;
            return (issue.snip = response.data
                .split('\n')
                .slice(Math.max(((_a = issue.textRange) === null || _a === void 0 ? void 0 : _a.startLine) - 3, 0), ((_b = issue.textRange) === null || _b === void 0 ? void 0 : _b.endLine) + 3)
                .join('\n')
                .trim());
        })));
        await Promise.all((_b = this.data.issues) === null || _b === void 0 ? void 0 : _b.map((issue) => axios_1.default
            .get(`${this.sonarQubeHost}/api/rules/show`, {
            auth: { username: this.userToken, password: '' },
            params: {
                key: issue.rule
            }
        })
            .then((response) => {
            issue.sysTags = response.data.rule.sysTags;
            issue.name = response.data.rule.name;
            issue.summary = response.data.rule.htmlDesc;
        })));
        const result = new SonarQubeMapper(this.data, this.projectId, this.branchName, this.pullRequestID);
        return result.toHdf();
    }
}
exports.SonarQubeResults = SonarQubeResults;
function createSonarqubeMappings(projectName, branchName, pullRequestID) {
    const scanDescriptionModifier = (branchName ? ` Branch ${branchName}` : '') +
        (pullRequestID ? ` Pull Request ${pullRequestID}` : '');
    return {
        platform: {
            name: 'Heimdall Tools',
            release: package_json_1.version,
            target_id: projectName
        },
        version: package_json_1.version,
        statistics: {
            duration: null
        },
        profiles: [
            {
                name: 'Sonarqube Scan',
                version: null,
                title: `SonarQube Scan of Project ${projectName}${scanDescriptionModifier}`,
                maintainer: null,
                summary: `SonarQube Scan of Project ${projectName}${scanDescriptionModifier}`,
                license: null,
                copyright: null,
                copyright_email: null,
                supports: [],
                attributes: [],
                depends: [],
                groups: [],
                status: 'loaded',
                controls: [
                    {
                        path: 'issues',
                        key: 'id',
                        desc: { path: 'summary' },
                        descriptions: [],
                        refs: [],
                        source_location: {},
                        id: { path: 'rule' },
                        title: { path: 'name' },
                        impact: {
                            path: 'severity',
                            transformer: (0, base_converter_1.impactMapping)(IMPACT_MAPPING)
                        },
                        code: null,
                        tags: {
                            cci: {
                                transformer: (issue) => (0, global_1.getCCIsForNISTTags)(parseNistTags(issue))
                            },
                            nist: { transformer: parseNistTags }
                        },
                        results: [
                            {
                                status: inspecjs_1.ExecJSON.ControlResultStatus.Failed,
                                code_desc: { transformer: formatCodeDesc },
                                run_time: 0,
                                start_time: ''
                            }
                        ]
                    }
                ],
                sha256: ''
            }
        ]
    };
}
class SonarQubeMapper extends base_converter_1.BaseConverter {
    constructor(issuesJSON, projectName, branchName, pullRequestID) {
        super(issuesJSON);
        this.projectName = '';
        this.branchName = '';
        this.pullRequestID = '';
        super.setMappings(createSonarqubeMappings(projectName, branchName, pullRequestID));
    }
}
exports.SonarQubeMapper = SonarQubeMapper;
//# sourceMappingURL=sonarqube-mapper.js.map