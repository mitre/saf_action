"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SonarqubeResults = exports.SonarqubeMapper = void 0;
const axios_1 = __importDefault(require("axios"));
const _ = __importStar(require("lodash"));
const semver_1 = require("semver");
const inspecjs_1 = require("inspecjs");
const util_1 = require("util");
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const CweNistMapping_1 = require("./mappings/CweNistMapping");
const OwaspNistMapping_1 = require("./mappings/OwaspNistMapping");
const global_1 = require("./utils/global");
const logger = (0, global_1.createWinstonLogger)('SonarQube2HDF');
var SonarqubeVersion;
(function (SonarqubeVersion) {
    SonarqubeVersion["Eight"] = "8.0.0";
    SonarqubeVersion["Nine"] = "9.0.0";
    SonarqubeVersion["Ten"] = "10.0.0";
    SonarqubeVersion["Twenty_five"] = "2025.0.0";
})(SonarqubeVersion || (SonarqubeVersion = {}));
function isSonarqubeVersionEight(version) {
    const nextHigherVersion = SonarqubeVersion.Nine;
    const v = (0, semver_1.coerce)(version);
    if (v === null) {
        throw new Error(`Was not able to coerce ${version} into a semver compatible version string`);
    }
    return (0, semver_1.lt)(v, nextHigherVersion);
}
function isSonarqubeVersionNine(version) {
    const nextHigherVersion = SonarqubeVersion.Ten;
    const v = (0, semver_1.coerce)(version);
    if (v === null) {
        throw new Error(`Was not able to coerce ${version} into a semver compatible version string`);
    }
    return (0, semver_1.lt)(v, nextHigherVersion);
}
function isSonarqubeVersionTen(version) {
    const nextHigherVersion = SonarqubeVersion.Twenty_five;
    const v = (0, semver_1.coerce)(version);
    if (v === null) {
        throw new Error(`Was not able to coerce ${version} into a semver compatible version string`);
    }
    return (0, semver_1.lt)(v, nextHigherVersion);
}
function isSonarqubeVersionTwenty_five(version) {
    const nextHigherVersion = '2026.0.0';
    const v = (0, semver_1.coerce)(version);
    if (v === null) {
        throw new Error(`Was not able to coerce ${version} into a semver compatible version string`);
    }
    return (0, semver_1.lt)(v, nextHigherVersion);
}
const IMPACT_MAPPING = new Map([
    ['blocker', 1.0],
    ['critical', 0.7],
    ['major', 0.5],
    ['minor', 0.3],
    ['info', 0.0]
]);
const CWE_NIST_MAPPING = new CweNistMapping_1.CweNistMapping();
const OWASP_NIST_MAPPING = new OwaspNistMapping_1.OwaspNistMapping();
function parseOwaspInSysTags(issue) {
    return issue.ruleInformation.rule.sysTags
        .filter((s) => s.toLowerCase().startsWith('owasp-'))
        .map((t) => t.substring('owasp-'.length).toUpperCase());
}
function parseOwaspTags(issue) {
    let searchSpace = '';
    const rule = issue.ruleInformation.rule;
    if ('htmlDesc' in rule) {
        searchSpace += rule.htmlDesc;
    }
    if (rule.descriptionSections) {
        searchSpace += rule.descriptionSections.map((s) => s.content).join('');
    }
    const searchSpaceMatches = [
        ...searchSpace.matchAll(/> ?OWASP.*?(Top .*?A\d\d?)/gu)
    ].map((m) => m[1]);
    const sysTagMatches = parseOwaspInSysTags(issue);
    const totalMatches = searchSpaceMatches.concat(sysTagMatches);
    if (totalMatches.length) {
        return totalMatches;
    }
    return undefined;
}
function parseCweTags(issue) {
    let searchSpace = '';
    const rule = issue.ruleInformation.rule;
    if ('htmlDesc' in rule) {
        searchSpace += rule.htmlDesc;
    }
    if (rule.descriptionSections) {
        searchSpace += rule.descriptionSections.map((s) => s.content).join('');
    }
    const uniqueCwes = _.uniq(searchSpace.match(/CWE-\d\d\d?\d?\d?\d?\d/gi));
    if (uniqueCwes.length) {
        return uniqueCwes;
    }
    return undefined;
}
function parseNistTags(issue) {
    const uniqueNist = _.uniq((parseCweTags(issue) ?? [])
        .flatMap((t) => CWE_NIST_MAPPING.nistFilter(t.split('-')[1]))
        .concat((parseOwaspInSysTags(issue) ?? []).flatMap((t) => OWASP_NIST_MAPPING.nistFilterNoDefault(t))));
    if (uniqueNist.length) {
        return uniqueNist;
    }
    return ['SA-11'];
}
class SonarqubeMapper extends base_converter_1.BaseConverter {
    constructor(data, withRaw = false) {
        super(data);
        this.data = data;
        this.mappings = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version
            },
            version: package_json_1.version,
            statistics: {},
            profiles: [
                {
                    name: 'SonarQube Scan',
                    version: {
                        transformer: (data) => `SonarQube v${data.sonarqubeVersion}`
                    },
                    title: {
                        transformer: (data) => {
                            const branch = data.branchName ? ` branch ${data.branchName}` : '';
                            const pullrequest = data.pullRequestID
                                ? ` pull request ${data.pullRequestID}`
                                : '';
                            const org = data.organization
                                ? ` organization ${data.organization}`
                                : '';
                            return `SonarQube Scan of project ${data.projectKey} on ${data.sonarqubeHost} at ${new Date().toISOString()}${data.branchName || data.pullRequestID || data.organization ? ' using' : ''}${[branch, pullrequest, org].filter((s) => s).join(',')}`;
                        }
                    },
                    supports: [],
                    attributes: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: 'search.issues',
                            key: 'id',
                            desc: {
                                transformer: (issue) => {
                                    const rule = issue.ruleInformation.rule;
                                    if ('htmlDesc' in rule) {
                                        return rule.htmlDesc;
                                    }
                                    if (!rule.descriptionSections) {
                                        return '';
                                    }
                                    const def = rule.descriptionSections.find((d) => d.key === 'default');
                                    if (def) {
                                        return def.content;
                                    }
                                    const introduction = rule.descriptionSections.find((d) => d.key === 'introduction');
                                    const rootcause = rule.descriptionSections.find((d) => d.key === 'root_cause');
                                    return [introduction, rootcause]
                                        .filter((s) => s !== undefined)
                                        .map((s) => s.content)
                                        .join('\n');
                                }
                            },
                            refs: [],
                            source_location: {},
                            id: { path: 'rule' },
                            title: { path: 'ruleInformation.rule.name' },
                            impact: {
                                path: 'severity',
                                transformer: (0, base_converter_1.impactMapping)(IMPACT_MAPPING)
                            },
                            tags: {
                                cci: {
                                    transformer: (issue) => (0, global_1.getCCIsForNISTTags)(parseNistTags(issue) ?? [])
                                },
                                nist: { transformer: parseNistTags },
                                cweid: { transformer: parseCweTags },
                                owasp: { transformer: parseOwaspTags },
                                createdAt: { path: 'ruleInformation.rule.createdAt' },
                                debtRemFnType: { path: 'ruleInformation.rule.debtRemFnType' },
                                defaultDebtRemFnType: {
                                    path: 'ruleInformation.rule.defaultDebtRemFnType'
                                },
                                isExternal: { path: 'ruleInformation.rule.isExternal' },
                                isTemplate: { path: 'ruleInformation.rule.isTemplate' },
                                langName: { path: 'ruleInformation.rule.langName' },
                                remFnBaseEffort: { path: 'ruleInformation.rule.remFnBaseEffort' },
                                remFnOverloaded: { path: 'ruleInformation.rule.remFnOverloaded' },
                                remFnType: { path: 'ruleInformation.rule.remFnType' },
                                repo: { path: 'ruleInformation.rule.repo' },
                                scope: { path: 'ruleInformation.rule.scope' },
                                ruleSeverity: { path: 'ruleInformation.rule.severity' },
                                status: { path: 'ruleInformation.rule.status' },
                                transformer: (issue) => ({
                                    ...(0, global_1.conditionallyProvideAttribute)('Actives', issue.ruleInformation.actives, issue.ruleInformation.actives.length !== 0),
                                    ...(0, global_1.conditionallyProvideAttribute)('Clean Code Attribute', issue.ruleInformation.rule.cleanCodeAttribute, issue.ruleInformation.rule.cleanCodeAttribute?.length !== 0),
                                    ...(0, global_1.conditionallyProvideAttribute)('Clean Code Attribute Category', issue.ruleInformation.rule.cleanCodeAttributeCategory, issue.ruleInformation.rule.cleanCodeAttributeCategory
                                        ?.length !== 0),
                                    ...(0, global_1.conditionallyProvideAttribute)('Debt Overloaded', 'debtOverloaded' in issue.ruleInformation.rule &&
                                        issue.ruleInformation.rule.debtOverloaded, 'debtOverloaded' in issue.ruleInformation.rule &&
                                        issue.ruleInformation.rule.debtOverloaded !== undefined),
                                    ...(0, global_1.conditionallyProvideAttribute)('Debt Rem Fn Coeff', 'debtRemFnCoeff' in issue.ruleInformation.rule &&
                                        issue.ruleInformation.rule.debtRemFnCoeff, 'debtRemFnCoeff' in issue.ruleInformation.rule &&
                                        issue.ruleInformation.rule.debtRemFnCoeff !== undefined),
                                    ...(0, global_1.conditionallyProvideAttribute)('Debt Rem Fn Offset', 'debtRemFnOffset' in issue.ruleInformation.rule &&
                                        issue.ruleInformation.rule.debtRemFnOffset, 'debtRemFnOffset' in issue.ruleInformation.rule),
                                    ...(0, global_1.conditionallyProvideAttribute)('Default Debt Rem Fn Coeff', 'defaultDebtRemFnCoeff' in issue.ruleInformation.rule &&
                                        issue.ruleInformation.rule.defaultDebtRemFnCoeff, 'defaultDebtRemFnCoeff' in issue.ruleInformation.rule &&
                                        issue.ruleInformation.rule.defaultDebtRemFnCoeff !==
                                            undefined),
                                    ...(0, global_1.conditionallyProvideAttribute)('Default Debt Rem Fn Offset', 'defaultDebtRemFnOffset' in issue.ruleInformation.rule &&
                                        issue.ruleInformation.rule.defaultDebtRemFnOffset, 'defaultDebtRemFnOffset' in issue.ruleInformation.rule),
                                    ...(0, global_1.conditionallyProvideAttribute)('Education Principles', 'educationPrinciples' in issue.ruleInformation.rule &&
                                        issue.ruleInformation.rule.educationPrinciples, 'educationPrinciples' in issue.ruleInformation.rule &&
                                        issue.ruleInformation.rule.educationPrinciples?.length !== 0),
                                    ...(0, global_1.conditionallyProvideAttribute)('Effort To Fix Description', 'effortToFixDescription' in issue.ruleInformation.rule &&
                                        issue.ruleInformation.rule.effortToFixDescription, 'effortToFixDescription' in issue.ruleInformation.rule &&
                                        issue.ruleInformation.rule.effortToFixDescription !==
                                            undefined),
                                    ...(0, global_1.conditionallyProvideAttribute)('Impacts', issue.ruleInformation.rule.impacts, issue.ruleInformation.rule.impacts?.length !== 0),
                                    ...(0, global_1.conditionallyProvideAttribute)('Issue Type Vulnerability', true, issue.type === 'VULNERABILITY'),
                                    ...(0, global_1.conditionallyProvideAttribute)('Issue Type Bug', true, issue.type === 'BUG'),
                                    ...(0, global_1.conditionallyProvideAttribute)('Issue Type Code Smell', true, issue.type === 'CODE_SMELL'),
                                    ...(0, global_1.conditionallyProvideAttribute)('Params', issue.ruleInformation.rule.params, issue.ruleInformation.rule.params?.length !== 0),
                                    ...(0, global_1.conditionallyProvideAttribute)('Security Standards', issue.ruleInformation.rule.securityStandards, issue.ruleInformation.rule.securityStandards?.length !== 0),
                                    ...(0, global_1.conditionallyProvideAttribute)('Sys Tags', issue.ruleInformation.rule.sysTags, issue.ruleInformation.rule.sysTags?.length !== 0),
                                    ...(0, global_1.conditionallyProvideAttribute)('Tags', issue.ruleInformation.rule.tags, issue.ruleInformation.rule.tags?.length !== 0),
                                    ...(0, global_1.conditionallyProvideAttribute)('Updated At', 'updatedAt' in issue.ruleInformation.rule &&
                                        issue.ruleInformation.rule.updatedAt, 'updatedAt' in issue.ruleInformation.rule)
                                })
                            },
                            results: [
                                {
                                    status: inspecjs_1.ExecJSON.ControlResultStatus.Failed,
                                    code_desc: { path: 'codeSnippet' },
                                    start_time: { path: 'creationDate' },
                                    message: {
                                        transformer: (issue) => JSON.stringify({
                                            Message: issue.message,
                                            Author: issue.author,
                                            'Creation Date': issue.creationDate,
                                            Debt: issue.debt,
                                            Effort: issue.effort,
                                            ...(0, global_1.conditionallyProvideAttribute)('Issue Status', issue.issueStatus, issue.issueStatus?.length !== 0),
                                            ...(0, global_1.conditionallyProvideAttribute)('Resolution', issue.resolution, issue.resolution?.length !== 0),
                                            Status: issue.status,
                                            'Update Date': issue.updateDate,
                                            ...(0, global_1.conditionallyProvideAttribute)('Actions', issue.actions, issue.actions?.length !== 0),
                                            ...(0, global_1.conditionallyProvideAttribute)('Attr', issue.attr, issue.attr !== undefined),
                                            ...(0, global_1.conditionallyProvideAttribute)('Code Variants', 'codeVariants' in issue && issue.codeVariants, 'codeVariants' in issue &&
                                                issue.codeVariants?.length !== 0),
                                            ...(0, global_1.conditionallyProvideAttribute)('Comments', issue.comments, issue.comments?.length !== 0),
                                            ...(0, global_1.conditionallyProvideAttribute)('Flows', issue.flows, issue.flows?.length !== 0),
                                            ...(0, global_1.conditionallyProvideAttribute)('From Hotspot', 'fromHotspot' in issue && issue.fromHotspot, 'fromHotspot' in issue &&
                                                issue.fromHotspot !== undefined &&
                                                issue.fromHotspot !== null),
                                            Hash: issue.hash,
                                            Key: issue.key,
                                            ...(0, global_1.conditionallyProvideAttribute)('Message Formattings', issue.messageFormattings, issue.messageFormattings?.length !== 0),
                                            ...(0, global_1.conditionallyProvideAttribute)('Prioritized Rule', 'prioritizedRule' in issue && issue.prioritizedRule, 'prioritizedRule' in issue),
                                            ...(0, global_1.conditionallyProvideAttribute)('Project Name', issue.projectName, issue.projectName?.length !== 0),
                                            ...(0, global_1.conditionallyProvideAttribute)('Quick Fix Available', 'quickFixAvailable' in issue &&
                                                issue.quickFixAvailable, 'quickFixAvailable' in issue &&
                                                issue.quickFixAvailable !== undefined),
                                            ...(0, global_1.conditionallyProvideAttribute)('Rule Description Context Key', 'ruleDescriptionContextKey' in issue &&
                                                issue.ruleDescriptionContextKey, 'ruleDescriptionContextKey' in issue &&
                                                issue.ruleDescriptionContextKey?.length !== 0),
                                            ...(0, global_1.conditionallyProvideAttribute)('Tags', issue.tags, issue.tags?.length !== 0),
                                            ...(0, global_1.conditionallyProvideAttribute)('Transitions', issue.transitions, issue.transitions?.length !== 0)
                                        }, null, 2)
                                    }
                                }
                            ],
                            transformer: () => ({
                                descriptions: {
                                    transformer: (issue) => {
                                        const rule = issue.ruleInformation.rule;
                                        if (rule.descriptionSections &&
                                            rule.descriptionSections.length > 0) {
                                            const def = rule.descriptionSections.find((d) => d.key === 'default');
                                            const introduction = rule.descriptionSections.find((d) => d.key === 'introduction');
                                            const rootcause = rule.descriptionSections.find((d) => d.key === 'root_cause');
                                            const check = rule.descriptionSections.find((d) => d.key === 'assess_the_problem');
                                            const fix = rule.descriptionSections.find((d) => d.key === 'how_to_fix');
                                            const remainder = rule.descriptionSections.filter((d) => ![
                                                'default',
                                                'introduction',
                                                'root_cause',
                                                'assess_the_problem',
                                                'how_to_fix'
                                            ].includes(d.key));
                                            const sections = [
                                                def,
                                                def ? introduction : undefined,
                                                def ? rootcause : undefined,
                                                check,
                                                fix,
                                                ...remainder
                                            ]
                                                .filter((s) => s !== undefined)
                                                .map((s) => ({
                                                data: s.content,
                                                label: s.key === 'assess_the_problem'
                                                    ? 'check'
                                                    : s.key === 'how_to_fix'
                                                        ? 'fix'
                                                        : s.key
                                            }));
                                            if (sections) {
                                                return sections;
                                            }
                                        }
                                        return null;
                                    }
                                }
                            })
                        }
                    ],
                    sha256: ''
                }
            ],
            passthrough: {
                transformer: (data) => {
                    return {
                        auxiliary_data: [
                            {
                                name: 'SonarQube',
                                data: {
                                    ..._.omit(data, 'search.issues')
                                }
                            }
                        ],
                        ...(0, global_1.conditionallyProvideAttribute)('raw', data, this.withRaw)
                    };
                }
            }
        };
        this.withRaw = withRaw;
    }
}
exports.SonarqubeMapper = SonarqubeMapper;
var AuthenticationMethod;
(function (AuthenticationMethod) {
    AuthenticationMethod[AuthenticationMethod["TokenAsUsername"] = 0] = "TokenAsUsername";
    AuthenticationMethod[AuthenticationMethod["BearerToken"] = 1] = "BearerToken";
})(AuthenticationMethod || (AuthenticationMethod = {}));
class SonarqubeResults {
    constructor(sonarqubeHost, projectKey, userToken, branchName, pullRequestID, organization, withRaw = false) {
        this.sonarqubeHost = sonarqubeHost;
        this.projectKey = projectKey;
        this.userToken = userToken;
        this.branchName = branchName;
        this.pullRequestID = pullRequestID;
        this.organization = organization;
        this.withRaw = withRaw;
    }
    logAxiosError(e) {
        if (e.response) {
            logger.debug('response');
            logger.debug(e.response.status);
            logger.debug(e.response.data);
        }
        if (e.request) {
            logger.debug('request');
            logger.debug((0, util_1.inspect)(e.request, { depth: 3 }));
        }
        if (e.message) {
            logger.debug('message');
            logger.debug('Error', e.message);
        }
    }
    async getSearchResults() {
        let paging = true;
        let page = 1;
        const results = {
            components: [],
            effortTotal: 0,
            facets: [],
            issues: [],
            paging: { pageIndex: 0, pageSize: 0, total: 0 }
        };
        while (paging) {
            await axios_1.default
                .get(`${this.sonarqubeHost}/api/issues/search`, {
                ...(this.authMethod === AuthenticationMethod.TokenAsUsername && {
                    auth: { username: this.userToken, password: '' }
                }),
                ...(this.authMethod === AuthenticationMethod.BearerToken && {
                    headers: { Authorization: `Bearer ${this.userToken}` }
                }),
                params: {
                    componentKeys: this.projectKey,
                    statuses: 'OPEN,REOPENED,CONFIRMED,RESOLVED',
                    p: page,
                    ...(this.branchName && { branch: this.branchName }),
                    ...(this.pullRequestID && { pullRequest: this.pullRequestID })
                }
            })
                .then(({ data }) => {
                _.mergeWith(results, data, (objValue, srcValue) => _.isArray(objValue) ? objValue.concat(srcValue) : undefined);
                paging =
                    data.paging.pageIndex * data.paging.pageSize <= data.paging.total;
                page += 1;
            })
                .catch((e) => {
                this.logAxiosError(e);
                return Promise.reject(new Error('Failed at getting Sonarqube issue'));
            });
        }
        return results;
    }
    async getCodeSnippets(issues) {
        const getFullFile = async (component) => {
            return axios_1.default
                .get(`${this.sonarqubeHost}/api/sources/raw`, {
                ...(this.authMethod === AuthenticationMethod.TokenAsUsername && {
                    auth: { username: this.userToken, password: '' }
                }),
                ...(this.authMethod === AuthenticationMethod.BearerToken && {
                    headers: { Authorization: `Bearer ${this.userToken}` }
                }),
                params: {
                    key: component,
                    ...(this.branchName && { branch: this.branchName }),
                    ...(this.pullRequestID && { pullRequest: this.pullRequestID })
                },
                responseType: 'text'
            })
                .then(({ data }) => data)
                .catch((e) => {
                this.logAxiosError(e);
                return Promise.reject(new Error(`Failed at getting Sonarqube code snippet for ${component}`));
            });
        };
        const applyLineNumber = (snippet) => snippet
            .split('\n')
            .map((l, i) => `${i + 1} ${l}`)
            .join('\n');
        const getContextualizedSnippet = (fullFiles, component, startLine, endLine, msg) => {
            const linenumberedFile = applyLineNumber(fullFiles[component]);
            const snippet = linenumberedFile
                .split('\n')
                .slice(Math.max(startLine - 3, 0), endLine + 3)
                .join('\n')
                .trim();
            const location = `${component}:${startLine}-${endLine}\n`;
            const message = msg ? `${msg}\n` : '';
            return `${location}${message}<pre>\n${snippet}\n</pre>`;
        };
        const components = _.uniq(issues.flatMap((issue) => issue.flows.length
            ? issue.flows.flatMap((flow) => flow.locations.map((location) => location.component))
            : [issue.component]));
        const fullFilePromises = await Promise.all(components.map((component) => getFullFile(component)));
        const fullFiles = Object.fromEntries(_.zip(components, fullFilePromises));
        const snippets = issues.map((issue) => issue.flows.length
            ? issue.flows
                .flatMap((flow) => flow.locations.map((location) => getContextualizedSnippet(fullFiles, location.component, location.textRange.startLine, location.textRange.endLine, location.msg)))
                .join('\n')
            : getContextualizedSnippet(fullFiles, issue.component, issue.textRange.startLine, issue.textRange.endLine));
        return snippets;
    }
    async getRules(issues) {
        const getRule = async (rule, organization) => axios_1.default
            .get(`${this.sonarqubeHost}/api/rules/show`, {
            ...(this.authMethod === AuthenticationMethod.TokenAsUsername && {
                auth: { username: this.userToken, password: '' }
            }),
            ...(this.authMethod === AuthenticationMethod.BearerToken && {
                headers: { Authorization: `Bearer ${this.userToken}` }
            }),
            params: {
                key: rule,
                ...((organization || this.organization) && {
                    organization: organization || this.organization
                })
            }
        })
            .then(({ data }) => data)
            .catch((e) => {
            this.logAxiosError(e);
            return Promise.reject(new Error(`Failed at getting Sonarqube rule: ${rule}`));
        });
        const rulesAndOrgs = _.uniqWith(issues.map((issue) => [issue.rule, issue.organization]), _.isEqual);
        const fullRulePromises = await Promise.all(rulesAndOrgs.map((ruleAndOrg) => getRule(...ruleAndOrg)));
        const fullRules = Object.fromEntries(_.zip(rulesAndOrgs.map((ruleAndOrg) => ruleAndOrg.join('\n')), fullRulePromises));
        const rules = issues.map((issue) => fullRules[[issue.rule, issue.organization].join('\n')]);
        return rules;
    }
    async generateHdf(sonarqubeVersion) {
        const searchResults = await this.getSearchResults();
        logger.debug(`Got ${searchResults.issues.length} issues`);
        const codeSnippets = await this.getCodeSnippets(searchResults.issues);
        logger.debug(`Got ${codeSnippets.length} code snippets`);
        const rules = await this.getRules(searchResults.issues);
        logger.debug(`Got ${rules.length} rules`);
        const data = {
            sonarqubeVersion,
            sonarqubeHost: this.sonarqubeHost,
            projectKey: this.projectKey,
            branchName: this.branchName,
            pullRequestID: this.pullRequestID,
            organization: this.organization,
            search: {
                ...searchResults,
                issues: searchResults.issues.map((issue, index) => ({
                    ...issue,
                    codeSnippet: codeSnippets[index],
                    ruleInformation: rules[index]
                }))
            }
        };
        return new SonarqubeMapper(data, this.withRaw).toHdf();
    }
    async toHdf() {
        const sonarqubeVersion = await axios_1.default
            .get(`${this.sonarqubeHost}/api/server/version`)
            .then(({ data }) => data);
        logger.debug(`Generating HDF for ${this.sonarqubeHost} version: ${sonarqubeVersion}`);
        this.authMethod = isSonarqubeVersionNine(sonarqubeVersion)
            ? AuthenticationMethod.TokenAsUsername
            : AuthenticationMethod.BearerToken;
        if (isSonarqubeVersionEight(sonarqubeVersion)) {
            return this.generateHdf(sonarqubeVersion);
        }
        else if (isSonarqubeVersionNine(sonarqubeVersion)) {
            return this.generateHdf(sonarqubeVersion);
        }
        else if (isSonarqubeVersionTen(sonarqubeVersion)) {
            return this.generateHdf(sonarqubeVersion);
        }
        else if (isSonarqubeVersionTwenty_five(sonarqubeVersion)) {
            return this.generateHdf(sonarqubeVersion);
        }
        else {
            logger.debug(`Sonarqube version ${sonarqubeVersion} is not formally supported.  Please create an issue at https://github.com/mitre/heimdall2/issues if something is broken.`);
            return this.generateHdf(sonarqubeVersion);
        }
    }
}
exports.SonarqubeResults = SonarqubeResults;
//# sourceMappingURL=sonarqube-mapper.js.map