"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NessusMapper = exports.NessusResults = void 0;
const inspecjs_1 = require("inspecjs");
const _ = __importStar(require("lodash"));
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const CciNistMapping_1 = require("./mappings/CciNistMapping");
const NessusPluginsNistMapping_1 = require("./mappings/NessusPluginsNistMapping");
const IMPACT_MAPPING = new Map([
    ['4', 0.9],
    ['3', 0.7],
    ['i', 0.7],
    ['2', 0.5],
    ['ii', 0.5],
    ['1', 0.3],
    ['iii', 0.3],
    ['0', 0.0]
]);
const COMPLIANCE_PATH = 'compliance-reference';
const COMPLIANCE_CHECK_NAME = 'compliance-check-name';
const COMPLIANCE_INFO = 'compliance-info';
const COMPLIANCE_SOLUTION = 'compliance-solution';
const COMPLIANCE_RESULT = 'compliance-result';
const COMPLIANCE_ACTUAL_VALUE = 'compliance-actual-value';
const NA_PLUGIN_OUTPUT = 'This Nessus Plugin does not provide output message.';
const NESSUS_PLUGINS_NIST_MAPPING = new NessusPluginsNistMapping_1.NessusPluginsNistMapping();
const CCI_NIST_MAPPING = new CciNistMapping_1.CciNistMapping();
const DEFAULT_NIST_TAG = [];
let policyName;
let version;
function getPolicyName() {
    return 'Nessus ' + policyName;
}
function getVersion() {
    return version;
}
function getId(item) {
    if (_.has(item, COMPLIANCE_PATH)) {
        return parseRef(_.get(item, COMPLIANCE_PATH), 'Vuln-ID')[0];
    }
    else {
        return _.get(item, 'pluginID');
    }
}
function getTitle(item) {
    if (_.has(item, COMPLIANCE_CHECK_NAME)) {
        return _.get(item, COMPLIANCE_CHECK_NAME);
    }
    else {
        return _.get(item, 'pluginName');
    }
}
function getDesc(item) {
    if (_.has(item, COMPLIANCE_INFO)) {
        return (0, base_converter_1.parseHtml)(_.get(item, COMPLIANCE_INFO));
    }
    else {
        return (0, base_converter_1.parseHtml)(formatDesc(item));
    }
}
function formatDesc(issue) {
    const desc = [];
    desc.push(`Plugin Family: ${_.get(issue, 'pluginFamily')}`);
    desc.push(`Port: ${_.get(issue, 'port')}`);
    desc.push(`Protocol: ${_.get(issue, 'protocol')}`);
    return desc.join('; ') + ';';
}
function pluginNistTag(item) {
    const family = _.get(item, 'pluginFamily');
    const id = _.get(item, 'pluginID');
    return NESSUS_PLUGINS_NIST_MAPPING.nistFilter(family, id, DEFAULT_NIST_TAG);
}
function cciNistTag(input) {
    const identifiers = parseRef(input, 'CCI');
    return CCI_NIST_MAPPING.nistFilter(identifiers, DEFAULT_NIST_TAG, false);
}
function parseRef(input, key) {
    const matches = input.split(',').filter((element) => element.startsWith(key));
    return matches.map((element) => element.split('|')[1]);
}
function getImpact(item) {
    if (_.has(item, COMPLIANCE_PATH)) {
        return (0, base_converter_1.impactMapping)(IMPACT_MAPPING)(parseRef(_.get(item, COMPLIANCE_PATH), 'CAT').join(''));
    }
    else {
        return (0, base_converter_1.impactMapping)(IMPACT_MAPPING)(_.get(item, 'severity'));
    }
}
function getCheck(item) {
    if (_.has(item, COMPLIANCE_SOLUTION)) {
        return (0, base_converter_1.parseHtml)(_.get(item, COMPLIANCE_SOLUTION));
    }
    else {
        return '';
    }
}
function getFix(item) {
    const fix = _.get(item, 'solution');
    if (fix && fix !== 'n/a') {
        return fix;
    }
    return '';
}
function getNist(item) {
    if (_.has(item, COMPLIANCE_PATH)) {
        return cciNistTag(_.get(item, COMPLIANCE_PATH));
    }
    else {
        return pluginNistTag(item);
    }
}
function getCci(item) {
    if (_.has(item, COMPLIANCE_PATH)) {
        return parseRef(_.get(item, COMPLIANCE_PATH), 'CCI');
    }
    else {
        return [];
    }
}
function getRid(item) {
    if (_.has(item, COMPLIANCE_PATH)) {
        return parseRef(_.get(item, COMPLIANCE_PATH), 'Rule-ID').join(',');
    }
    else {
        return _.get(item, 'pluginID');
    }
}
function getStig(item) {
    if (_.has(item, COMPLIANCE_PATH)) {
        return parseRef(_.get(item, COMPLIANCE_PATH), 'STIG-ID').join(',');
    }
    else {
        return '';
    }
}
function getStatus(item) {
    const result = _.get(item, COMPLIANCE_RESULT, '');
    switch (result) {
        case 'PASSED':
            return inspecjs_1.ExecJSON.ControlResultStatus.Passed;
        case 'WARNING':
            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
        case 'ERROR':
            return inspecjs_1.ExecJSON.ControlResultStatus.Error;
        default:
            return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
    }
}
function formatCodeDesc(item) {
    if (_.has(item, 'description')) {
        return (0, base_converter_1.parseHtml)(_.get(item, 'description') || NA_PLUGIN_OUTPUT);
    }
    else {
        return (0, base_converter_1.parseHtml)(_.get(item, 'plugin_output') || NA_PLUGIN_OUTPUT);
    }
}
function getStartTime(tag) {
    if (Array.isArray(tag)) {
        return _.get(tag.find((element) => {
            return _.get(element, 'name') === 'HOST_START';
        }), 'text');
    }
    else {
        return _.get(tag, 'text');
    }
}
function cleanData(control) {
    const filteredControl = control;
    filteredControl.forEach((element) => {
        if (element instanceof Object) {
            if (_.get(element.tags, 'cci').length === 0) {
                element.tags = _.omit(element.tags, 'cci');
            }
            if (_.get(element.tags, 'rid') === '') {
                element.tags = _.omit(element.tags, 'rid');
            }
            if (_.get(element.tags, 'stig_id') === '') {
                element.tags = _.omit(element.tags, 'stig_id');
            }
            element.refs = element.refs.filter((ref) => ref.url);
            if (element.descriptions !== undefined && element.descriptions !== null) {
                element.descriptions = element.descriptions.filter((description) => description && description.data);
            }
        }
    });
    return filteredControl;
}
class NessusResults {
    constructor(nessusXml, withRaw = false) {
        this.data = (0, base_converter_1.parseXml)(nessusXml);
        this.withRaw = withRaw;
    }
    toHdf() {
        const results = [];
        policyName = _.get(this.data, 'NessusClientData_v2.Policy.policyName');
        const preference = _.get(this.data, 'NessusClientData_v2.Policy.Preferences.ServerPreferences.preference');
        if (Array.isArray(preference)) {
            version =
                _.get(preference.find((element) => {
                    return _.get(element, 'name') === 'sc_version';
                }), 'value') || '';
        }
        const reportHost = _.get(this.data, 'NessusClientData_v2.Report.ReportHost');
        if (Array.isArray(reportHost)) {
            reportHost.forEach((element) => {
                const entry = new NessusMapper(element, this.withRaw);
                if (this.customMapping !== undefined) {
                    entry.setMappings(this.customMapping);
                }
                results.push(entry.toHdf());
            });
            return results;
        }
        else {
            const result = new NessusMapper(reportHost, this.withRaw);
            if (this.customMapping !== undefined) {
                result.setMappings(this.customMapping);
            }
            return result.toHdf();
        }
    }
}
exports.NessusResults = NessusResults;
class NessusMapper extends base_converter_1.BaseConverter {
    constructor(nessusJson, withRaw = false) {
        super(nessusJson);
        this.mappings = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version,
                target_id: { path: 'name' }
            },
            version: package_json_1.version,
            statistics: {},
            profiles: [
                {
                    name: { transformer: getPolicyName },
                    version: { transformer: getVersion },
                    title: { transformer: getPolicyName },
                    summary: { transformer: getPolicyName },
                    supports: [],
                    attributes: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            arrayTransformer: cleanData,
                            path: 'ReportItem',
                            key: 'id',
                            tags: {
                                nist: { transformer: getNist },
                                cci: { transformer: getCci },
                                rid: { transformer: getRid },
                                stig_id: { transformer: getStig },
                                risk_factor: { path: 'risk_factor' },
                                plugin_type: { path: 'plugin_type' },
                                plugin_publication_date: { path: 'plugin_publication_date' },
                                fname: { path: 'fname' },
                                cvss3_base_score: { path: 'cvss3_base_score' },
                                cvss_base_score: { path: 'cvss_base_score' }
                            },
                            refs: [
                                {
                                    url: {
                                        path: 'see_also'
                                    }
                                }
                            ],
                            source_location: {},
                            title: { transformer: getTitle },
                            id: { transformer: getId },
                            desc: { transformer: getDesc },
                            descriptions: [
                                {
                                    data: { transformer: getCheck },
                                    label: 'check'
                                },
                                {
                                    data: { transformer: getFix },
                                    label: 'fix'
                                }
                            ],
                            impact: { transformer: getImpact },
                            code: {
                                transformer: (reportItem) => JSON.stringify(reportItem, null, 2)
                            },
                            results: [
                                {
                                    status: { transformer: getStatus },
                                    code_desc: { transformer: formatCodeDesc },
                                    message: {
                                        path: ['plugin_output', COMPLIANCE_ACTUAL_VALUE],
                                        transformer: (value) => {
                                            if (value === null || value === undefined) {
                                                return value;
                                            }
                                            return String(value);
                                        }
                                    },
                                    start_time: {
                                        path: '$.HostProperties.tag',
                                        transformer: getStartTime
                                    }
                                }
                            ]
                        }
                    ],
                    sha256: ''
                }
            ],
            passthrough: {
                transformer: (data) => {
                    return {
                        auxiliary_data: [
                            {
                                name: 'Nessus',
                                data: _.omit(data, ['name', 'ReportItem'])
                            }
                        ],
                        ...(this.withRaw && { raw: data })
                    };
                }
            }
        };
        this.withRaw = withRaw;
    }
}
exports.NessusMapper = NessusMapper;
//# sourceMappingURL=nessus-mapper.js.map