"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XCCDFResultsMapper = void 0;
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const CciNistMapping_1 = require("./mappings/CciNistMapping");
const global_1 = require("./utils/global");
const IMPACT_MAPPING = new Map([
    ['critical', 0.9],
    ['high', 0.7],
    ['medium', 0.5],
    ['low', 0.3]
]);
const CCI_NIST_MAPPING = new CciNistMapping_1.CciNistMapping();
function asArray(arg) {
    if (Array.isArray(arg)) {
        return arg;
    }
    else if (arg === undefined || arg === null) {
        return [];
    }
    else {
        return [arg];
    }
}
function getRuleResult(ruleId, benchmark) {
    const ruleResults = asArray(lodash_1.default.get(benchmark, 'TestResult.rule-result'));
    return ruleResults.find((element) => lodash_1.default.get(element, 'idref') === ruleId);
}
function getStatus(testResultStatus) {
    switch (testResultStatus) {
        case 'pass':
            return inspecjs_1.ExecJSON.ControlResultStatus.Passed;
        case 'fail':
            return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
        case 'error':
            return inspecjs_1.ExecJSON.ControlResultStatus.Error;
        case 'unknown':
            return inspecjs_1.ExecJSON.ControlResultStatus.Error;
        case 'notapplicable':
            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
        case 'notchecked':
            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
        case 'notselected':
            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
        case 'informational':
            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
        case 'fixed':
            return inspecjs_1.ExecJSON.ControlResultStatus.Passed;
        default:
            return inspecjs_1.ExecJSON.ControlResultStatus.Error;
    }
}
function getValues(rule, group, benchmark) {
    const checks = asArray(lodash_1.default.get(rule, 'check'));
    if (!checks) {
        return [];
    }
    const ruleValueIds = [];
    for (const check of checks) {
        const valueId = lodash_1.default.get(check, 'check-export.value-id');
        if (valueId) {
            ruleValueIds.push(valueId);
        }
    }
    const matchingValues = [];
    for (const values of [lodash_1.default.get(group, 'Value'), lodash_1.default.get(benchmark, 'Value')]) {
        if (!values) {
            continue;
        }
        matchingValues.push(...asArray(values).filter((value) => ruleValueIds.includes(lodash_1.default.get(value, 'id'))));
    }
    return matchingValues;
}
function getProfiles(ids, benchmark) {
    const matchingProfiles = [];
    const profiles = asArray(lodash_1.default.get(benchmark, 'Profile'));
    for (const profile of profiles) {
        const selects = asArray(lodash_1.default.get(profile, 'select'));
        if (selects.find((select) => ids.includes(lodash_1.default.get(select, 'idref')) &&
            lodash_1.default.get(select, 'selected') === 'true')) {
            matchingProfiles.push(profile);
        }
    }
    return matchingProfiles;
}
function extractCci(input) {
    const inputArray = asArray(input);
    const CCI_REGEX = /CCI-(\d*)/;
    const output = [];
    for (const element of inputArray) {
        const text = lodash_1.default.get(element, 'text');
        if (!!text && CCI_REGEX.exec(text)) {
            output.push(text);
        }
    }
    return output;
}
function nistTag(input) {
    return lodash_1.default.uniq(CCI_NIST_MAPPING.nistFilter(extractCci(input), global_1.DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS, false).concat(asArray(input)
        .filter((x) => !!x)
        .map((x) => x.text)
        .map(inspecjs_1.parse_nist)
        .filter((x) => !!x)
        .filter(inspecjs_1.is_control)
        .map((x) => x.canonize())));
}
function getRulesInGroup(allRules, benchmark, group) {
    const subGroups = asArray(lodash_1.default.get(group, 'Group'));
    if (subGroups) {
        for (const subGroup of subGroups) {
            getRulesInGroup(allRules, benchmark, subGroup);
        }
    }
    const rules = asArray(lodash_1.default.get(group, 'Rule'));
    if (rules) {
        for (const rule of rules) {
            allRules.push(lodash_1.default.merge({}, rule, {
                group: lodash_1.default.omit(group, ['Rule', 'Group']),
                ruleResult: getRuleResult(lodash_1.default.get(rule, 'id'), benchmark),
                profiles: getProfiles([lodash_1.default.get(rule, 'id'), lodash_1.default.get(group, 'id')], benchmark),
                values: getValues(rule, group, benchmark)
            }));
        }
    }
}
function getRulesInBenchmark(input) {
    const benchmark = input;
    const groups = asArray(lodash_1.default.get(benchmark, 'Group'));
    const allRules = [];
    for (const group of groups) {
        getRulesInGroup(allRules, benchmark, group);
    }
    return allRules;
}
class XCCDFResultsMapper extends base_converter_1.BaseConverter {
    constructor(scapXml, withRaw = false) {
        super((0, base_converter_1.parseXml)(scapXml));
        this.mappings = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version,
                target_id: {
                    path: 'Benchmark.platform.idref'
                }
            },
            version: package_json_1.version,
            statistics: {},
            profiles: [
                {
                    name: { path: 'Benchmark.id' },
                    version: { path: 'Benchmark.style' },
                    title: { path: ['Benchmark.title.text', 'Benchmark.title'] },
                    maintainer: {
                        path: 'Benchmark.reference.publisher'
                    },
                    summary: {
                        path: ['Benchmark.description.text', 'Benchmark.description']
                    },
                    description: {
                        path: 'Benchmark',
                        transformer: (input) => {
                            const descriptionPaths = [
                                ['description.text'],
                                ['front-matter'],
                                ['metadata'],
                                ['model'],
                                ['plain-text'],
                                ['rear-matter'],
                                ['reference'],
                                ['status'],
                                ['version'],
                                ['xml:lang'],
                                ['xmlns:cdf', 'xmlns'],
                                ['xmlns:dc'],
                                ['xmlns:dsi'],
                                ['xsi:schemaLocation'],
                                ['TestResult.benchmark'],
                                ['TestResult.start-time'],
                                ['TestResult.end-time'],
                                ['TestResult.id'],
                                ['TestResult.identity'],
                                ['TestResult.organization'],
                                ['TestResult.platform.idref'],
                                ['TestResult.profile.idref'],
                                ['TestResult.score'],
                                ['TestResult.set-value'],
                                ['TestResult.target'],
                                ['TestResult.target-address'],
                                ['TestResult.target-facts'],
                                ['TestResult.target-id-ref'],
                                ['TestResult.test-system'],
                                ['TestResult.title'],
                                ['TestResult.version']
                            ];
                            const fullDescription = {};
                            for (const paths of descriptionPaths) {
                                for (const path of paths) {
                                    const item = lodash_1.default.get(input, path);
                                    if (item !== undefined) {
                                        fullDescription[path] = item;
                                    }
                                }
                            }
                            return JSON.stringify(fullDescription, null, 2);
                        }
                    },
                    license: { path: 'Benchmark.notice.id' },
                    copyright: {
                        path: 'Benchmark.metadata.creator'
                    },
                    copyright_email: 'disa.stig_spt@mail.mil',
                    supports: [],
                    attributes: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: 'Benchmark',
                            pathTransform: getRulesInBenchmark,
                            key: 'id',
                            tags: {
                                cci: {
                                    path: ['ident', 'reference'],
                                    transformer: extractCci
                                },
                                nist: {
                                    path: ['ident', 'reference'],
                                    transformer: nistTag
                                },
                                severity: { path: 'severity' },
                                description: {
                                    path: ['description.text', 'description'],
                                    transformer: (description) => lodash_1.default.get((0, base_converter_1.parseXml)(description), 'VulnDiscussion', description)
                                },
                                group_id: { path: 'group.id' },
                                group_title: { path: ['group.title.text', 'group.title'] },
                                group_description: {
                                    path: ['group.description.text', 'group.description'],
                                    transformer: (description) => lodash_1.default.get((0, base_converter_1.parseXml)(description), 'GroupDescription', description)
                                },
                                rule_id: { path: 'id' },
                                check: {
                                    path: 'check',
                                    transformer: (data) => JSON.stringify(data, null, 2)
                                },
                                fix_id: { path: 'fix.id' },
                                fixtext_fixref: {
                                    path: ['fixtext.fixref.text', 'fixtext.fixref'],
                                    transformer: (text) => text || undefined
                                },
                                ident: {
                                    path: 'ident',
                                    transformer: (text) => text || undefined
                                },
                                reference: {
                                    path: 'reference',
                                    transformer: (data) => ({
                                        references: data
                                    })
                                },
                                selected: { path: 'selected' },
                                weight: { path: 'weight' },
                                profiles: [
                                    {
                                        path: ['profiles'],
                                        id: { path: ['id'] },
                                        description: {
                                            path: ['description.text', 'description'],
                                            transformer: (description) => lodash_1.default.get((0, base_converter_1.parseXml)(description), 'ProfileDescription', description)
                                        },
                                        title: { path: ['title.text', 'title'] }
                                    }
                                ],
                                rule_result: {
                                    path: ['ruleResult']
                                },
                                value: {
                                    path: ['values'],
                                    transformer: (values) => asArray(values).map((value) => ({
                                        title: lodash_1.default.get(value, 'title'),
                                        description: lodash_1.default.get(value, 'description.text') ||
                                            lodash_1.default.get(value, 'description'),
                                        warning: lodash_1.default.get(value, 'warning.text') || lodash_1.default.get(value, 'warning'),
                                        value: lodash_1.default.get(value, 'value'),
                                        Id: lodash_1.default.get(value, 'Id'),
                                        id: lodash_1.default.get(value, 'id'),
                                        type: lodash_1.default.get(value, 'type'),
                                        interactive: lodash_1.default.get(value, 'interactive')
                                    }))
                                },
                                transformer: (data) => ({
                                    ...(0, global_1.conditionallyProvideAttribute)('version', lodash_1.default.get(data, 'version.text'), lodash_1.default.has(data, 'version.text'))
                                })
                            },
                            refs: [
                                {
                                    path: 'reference',
                                    transformer: (data) => ({
                                        ...(0, global_1.conditionallyProvideAttribute)('url', lodash_1.default.get(data, 'href'), lodash_1.default.has(data, 'href')),
                                        ref: [
                                            {
                                                ...(0, global_1.conditionallyProvideAttribute)('text', lodash_1.default.get(data, 'text'), lodash_1.default.has(data, 'text')),
                                                ...(0, global_1.conditionallyProvideAttribute)('publisher', lodash_1.default.get(data, 'publisher'), lodash_1.default.has(data, 'publisher')),
                                                ...(0, global_1.conditionallyProvideAttribute)('identifier', lodash_1.default.get(data, 'identifier'), lodash_1.default.has(data, 'identifier')),
                                                ...(0, global_1.conditionallyProvideAttribute)('type', lodash_1.default.get(data, 'type'), lodash_1.default.has(data, 'type'))
                                            }
                                        ]
                                    }),
                                    ref: {
                                        path: 'text',
                                        transformer: (text) => text || undefined
                                    },
                                    url: {
                                        path: 'href',
                                        transformer: (text) => text || undefined
                                    }
                                }
                            ],
                            source_location: {},
                            title: { path: ['title.text', 'title'] },
                            id: { path: ['id'] },
                            desc: {
                                path: ['description.text', 'description'],
                                transformer: (description) => lodash_1.default.get((0, base_converter_1.parseXml)(description), 'ProfileDescription', description)
                            },
                            descriptions: [
                                {
                                    path: ['check.check-content-ref.name'],
                                    transformer: (data) => ({
                                        data: asArray(data).join('\n'),
                                        label: 'check'
                                    })
                                },
                                {
                                    path: ['fixtext.text', 'fix.text'],
                                    transformer: (data) => ({
                                        data: asArray(data).map(base_converter_1.parseHtml).join('\n'),
                                        label: 'fix'
                                    })
                                },
                                {
                                    path: ['rationale.text'],
                                    transformer: (data) => ({
                                        data: asArray(data).map(base_converter_1.parseHtml).join('\n'),
                                        label: 'rationale'
                                    })
                                },
                                {
                                    path: ['warning.text'],
                                    transformer: (data) => ({
                                        data: asArray(data).map(base_converter_1.parseHtml).join('\n'),
                                        label: 'warning'
                                    })
                                }
                            ],
                            impact: {
                                transformer: (vulnerability) => {
                                    const ruleResult = lodash_1.default.get(vulnerability, 'ruleResult');
                                    if (ruleResult) {
                                        const result = lodash_1.default.get(ruleResult, 'result');
                                        if (result === 'notapplicable' ||
                                            result === 'informational') {
                                            return 0;
                                        }
                                    }
                                    return (0, base_converter_1.impactMapping)(IMPACT_MAPPING)(lodash_1.default.get(vulnerability, 'severity'));
                                }
                            },
                            code: {
                                transformer: (vulnerability) => JSON.stringify(lodash_1.default.omit(vulnerability, [
                                    'group',
                                    'ruleResult',
                                    'profiles',
                                    'values'
                                ]), null, 2)
                            },
                            results: [
                                {
                                    status: {
                                        path: ['ruleResult.result'],
                                        transformer: getStatus
                                    },
                                    code_desc: {
                                        path: ['description.text', 'description'],
                                        transformer: (description) => lodash_1.default.get((0, base_converter_1.parseXml)(description), 'VulnDiscussion', description)
                                    },
                                    start_time: {
                                        path: ['ruleResult.time']
                                    }
                                }
                            ]
                        }
                    ],
                    sha256: ''
                }
            ],
            passthrough: {
                transformer: (data) => {
                    let auxData = lodash_1.default.get(data, 'Benchmark');
                    if (auxData) {
                        auxData = lodash_1.default.omit(auxData, [
                            'id',
                            'xml:lang',
                            'style',
                            'title',
                            'description',
                            'notice',
                            'front-matter',
                            'reference',
                            'platform',
                            'version',
                            'model',
                            'Group',
                            'TestResult'
                        ]);
                    }
                    auxData = { Benchmark: auxData };
                    return {
                        auxiliary_data: [
                            {
                                name: 'XCCDF',
                                data: auxData
                            }
                        ],
                        ...(this.withRaw && { raw: data })
                    };
                }
            }
        };
        this.withRaw = withRaw;
    }
}
exports.XCCDFResultsMapper = XCCDFResultsMapper;
//# sourceMappingURL=xccdf-results-mapper.js.map