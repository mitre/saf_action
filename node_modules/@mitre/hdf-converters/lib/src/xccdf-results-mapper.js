"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XCCDFResultsMapper = void 0;
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const CciNistMapping_1 = require("./mappings/CciNistMapping");
const global_1 = require("./utils/global");
const IMPACT_MAPPING = new Map([
    ['critical', 0.9],
    ['high', 0.7],
    ['medium', 0.5],
    ['low', 0.3]
]);
const CCI_NIST_MAPPING = new CciNistMapping_1.CciNistMapping();
const RULE_RESULT_PATHS = ['rule-result'];
let idTracker = '';
let valueIdTracker = undefined;
function getRuleResultItem(testResult, pathRuleResultPossibilities, pathIdRefPossibilities = ['idref'], pathItemPossibilities = undefined) {
    for (const pathRuleResult of pathRuleResultPossibilities) {
        const ruleResult = lodash_1.default.get(testResult, pathRuleResult);
        if (ruleResult === undefined) {
            continue;
        }
        const match = ruleResult.find((element) => lodash_1.default.some(pathIdRefPossibilities.map((pathIDRef) => lodash_1.default.get(element, pathIDRef) === idTracker), Boolean));
        if (pathItemPossibilities === undefined) {
            return match;
        }
        for (const pathItem of pathItemPossibilities) {
            const item = lodash_1.default.get(match, pathItem);
            if (item !== undefined) {
                return item;
            }
        }
    }
    return undefined;
}
function getStatus(testResult) {
    const status = getRuleResultItem(testResult, RULE_RESULT_PATHS, ['idref'], ['result']);
    if (typeof status === 'string' && status === 'pass') {
        return inspecjs_1.ExecJSON.ControlResultStatus.Passed;
    }
    else {
        return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
    }
}
function getStartTime(testResult) {
    const time = getRuleResultItem(testResult, RULE_RESULT_PATHS, ['idref'], ['time']);
    if (typeof time === 'string') {
        return time;
    }
    else {
        return '';
    }
}
function convertEncodedXmlIntoJson(encodedXml) {
    return (0, base_converter_1.parseXml)(encodedXml);
}
function extractProfile(profile, pathProfileItemPossibilities) {
    const profileInfo = {
        id: '',
        description: '',
        title: ''
    };
    for (const profileKey of Object.keys(pathProfileItemPossibilities)) {
        for (const pathProfileItem of pathProfileItemPossibilities[profileKey]) {
            const item = lodash_1.default.get(profile, pathProfileItem);
            if (item) {
                if (profileKey === 'description') {
                    profileInfo[profileKey] =
                        convertEncodedXmlIntoJson(item);
                }
                else {
                    profileInfo[profileKey] = item;
                }
                break;
            }
        }
    }
    return profileInfo;
}
function getProfiles(profiles, pathSelectPossibilities, pathProfileItemPossibilities) {
    const profileInfos = [];
    for (const profile of profiles) {
        for (const pathSelect of pathSelectPossibilities) {
            const select = lodash_1.default.get(profile, pathSelect);
            if (select === undefined) {
                continue;
            }
            const selected = lodash_1.default.some(select, (element) => idTracker.replace('rule_SV', 'group_V').replace(/r\d+_rule/, '') ===
                lodash_1.default.get(element, 'idref') && lodash_1.default.get(element, 'selected') === 'true');
            if (selected) {
                profileInfos.push(extractProfile(profile, pathProfileItemPossibilities));
            }
        }
    }
    return profileInfos;
}
function extractCci(input) {
    let inputArray;
    if (Array.isArray(input)) {
        inputArray = input;
    }
    else {
        inputArray = [input];
    }
    const CCI_REGEX = /CCI-(\d*)/;
    const output = [];
    inputArray.forEach((element) => {
        const text = lodash_1.default.get(element, 'text');
        if (text.match(CCI_REGEX)) {
            output.push(text);
        }
    });
    return output;
}
function nistTag(input) {
    const identifiers = extractCci(input);
    return CCI_NIST_MAPPING.nistFilter(identifiers, global_1.DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS, false);
}
class XCCDFResultsMapper extends base_converter_1.BaseConverter {
    constructor(scapXml, withRaw = false) {
        super((0, base_converter_1.parseXml)(scapXml));
        this.mappings = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version,
                target_id: {
                    path: 'Benchmark.platform.idref'
                }
            },
            version: package_json_1.version,
            statistics: {},
            profiles: [
                {
                    name: { path: 'Benchmark.id' },
                    version: { path: 'Benchmark.style' },
                    title: { path: ['Benchmark.title.text', 'Benchmark.title'] },
                    maintainer: {
                        path: 'Benchmark.reference.publisher'
                    },
                    summary: {
                        path: ['Benchmark.description.text', 'Benchmark.description']
                    },
                    description: {
                        path: 'Benchmark',
                        transformer: (input) => {
                            const descriptionPaths = [
                                ['description.text', 'description'],
                                ['front-matter'],
                                ['metadata'],
                                ['model'],
                                ['plain-text'],
                                ['rear-matter'],
                                ['reference'],
                                ['status'],
                                ['version'],
                                ['xml:lang'],
                                ['xmlns:cdf', 'xmlns'],
                                ['xmlns:dc'],
                                ['xmlns:dsi'],
                                ['xsi:schemaLocation'],
                                ['TestResult.benchmark'],
                                ['TestResult.start-time'],
                                ['TestResult.end-time'],
                                ['TestResult.id'],
                                ['TestResult.identity'],
                                ['TestResult.organization'],
                                ['TestResult.platform.idref'],
                                ['TestResult.profile.idref'],
                                ['TestResult.score'],
                                ['TestResult.set-value'],
                                ['TestResult.target'],
                                ['TestResult.target-address'],
                                ['TestResult.target-facts'],
                                ['TestResult.target-id-ref'],
                                ['TestResult.test-system'],
                                ['TestResult.title'],
                                ['TestResult.version']
                            ];
                            const fullDescription = {};
                            for (const paths of descriptionPaths) {
                                for (const path of paths) {
                                    const item = lodash_1.default.get(input, path);
                                    if (item !== undefined) {
                                        fullDescription[path] = item;
                                    }
                                }
                            }
                            return JSON.stringify(fullDescription, null, 2);
                        }
                    },
                    license: { path: 'Benchmark.notice.id' },
                    copyright: {
                        path: 'Benchmark.metadata.creator'
                    },
                    copyright_email: 'disa.stig_spt@mail.mil',
                    supports: [],
                    attributes: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: 'Benchmark.Group',
                            key: 'id',
                            tags: {
                                cci: {
                                    path: 'Rule.ident',
                                    transformer: extractCci
                                },
                                nist: {
                                    path: 'Rule.ident',
                                    transformer: nistTag
                                },
                                severity: { path: 'Rule.severity' },
                                description: {
                                    path: ['Rule.description.text', 'Rule.description'],
                                    transformer: (description) => JSON.stringify(lodash_1.default.pickBy(convertEncodedXmlIntoJson(description), lodash_1.default.identity))
                                },
                                group_id: { path: 'id' },
                                group_title: { path: ['title.text', 'title'] },
                                group_description: {
                                    path: ['description.text', 'description'],
                                    transformer: (description) => JSON.stringify(lodash_1.default.pickBy(convertEncodedXmlIntoJson(description), lodash_1.default.identity))
                                },
                                rule_id: { path: 'Rule.id' },
                                check: { path: 'Rule.check' },
                                fix_id: { path: 'Rule.fix.id' },
                                fixtext_fixref: {
                                    path: 'Rule.fixtext.fixref'
                                },
                                ident: { path: 'Rule.ident' },
                                reference: { path: 'Rule.reference' },
                                selected: { path: 'Rule.selected' },
                                version: { path: 'Rule.version.text' },
                                weight: { path: 'Rule.weight' },
                                profiles: {
                                    path: '$.Benchmark.Profile',
                                    transformer: (profiles) => {
                                        const pathsSelect = ['select'];
                                        const paths = {
                                            id: ['id'],
                                            description: ['description.text', 'description'],
                                            title: ['title.text', 'title']
                                        };
                                        return getProfiles(profiles, pathsSelect, paths);
                                    }
                                },
                                rule_result: {
                                    path: '$.Benchmark.TestResult',
                                    transformer: (testResult) => getRuleResultItem(testResult, RULE_RESULT_PATHS)
                                },
                                value: {
                                    path: '$.Benchmark.Value',
                                    transformer: (values) => {
                                        return lodash_1.default.find(values, (value) => {
                                            const id = lodash_1.default.get(value, 'id');
                                            return id && id === valueIdTracker;
                                        });
                                    }
                                }
                            },
                            refs: [],
                            source_location: {},
                            title: { path: ['Rule.title.text', 'Rule.title'] },
                            id: {
                                path: 'Rule',
                                transformer: (input) => {
                                    const valueIdPaths = ['check.check-export.value-id'];
                                    let setValueIdTracker = false;
                                    for (const path of valueIdPaths) {
                                        const valueId = lodash_1.default.get(input, path);
                                        if (valueId !== undefined) {
                                            valueIdTracker = valueId;
                                            setValueIdTracker = true;
                                        }
                                    }
                                    if (!setValueIdTracker) {
                                        valueIdTracker = undefined;
                                    }
                                    const id = lodash_1.default.get(input, 'id');
                                    if (typeof id === 'string') {
                                        idTracker = id;
                                        return id.split('_S')[1].split('r')[0];
                                    }
                                    else {
                                        return '';
                                    }
                                }
                            },
                            desc: {
                                path: ['Rule.description.text', 'Rule.description'],
                                transformer: (description) => {
                                    const descTextJson = convertEncodedXmlIntoJson(description);
                                    return lodash_1.default.get(descTextJson, 'VulnDiscussion', '');
                                }
                            },
                            descriptions: [
                                {
                                    data: {
                                        path: 'Rule.check.check-content-ref.name',
                                        transformer: base_converter_1.parseHtml
                                    },
                                    label: 'check'
                                },
                                {
                                    data: {
                                        path: 'Rule.fixtext.text',
                                        transformer: base_converter_1.parseHtml
                                    },
                                    label: 'fix'
                                }
                            ],
                            impact: {
                                path: 'Rule.severity',
                                transformer: (0, base_converter_1.impactMapping)(IMPACT_MAPPING)
                            },
                            code: {
                                transformer: (vulnerability) => JSON.stringify(vulnerability, null, 2)
                            },
                            results: [
                                {
                                    status: {
                                        path: '$.Benchmark.TestResult',
                                        transformer: getStatus
                                    },
                                    code_desc: '',
                                    start_time: {
                                        path: '$.Benchmark.TestResult',
                                        transformer: getStartTime
                                    }
                                }
                            ]
                        }
                    ],
                    sha256: ''
                }
            ],
            passthrough: {
                transformer: (data) => {
                    let auxData = lodash_1.default.get(data, 'Benchmark');
                    if (auxData) {
                        auxData = lodash_1.default.omit(auxData, [
                            'id',
                            'xml:lang',
                            'style',
                            'title',
                            'description',
                            'notice',
                            'front-matter',
                            'reference',
                            'platform',
                            'version',
                            'model',
                            'Group',
                            'TestResult'
                        ]);
                    }
                    auxData = { Benchmark: auxData };
                    return {
                        auxiliary_data: [
                            {
                                name: 'XCCDF',
                                data: auxData
                            }
                        ],
                        ...(this.withRaw && { raw: data })
                    };
                }
            }
        };
        this.withRaw = withRaw;
    }
}
exports.XCCDFResultsMapper = XCCDFResultsMapper;
//# sourceMappingURL=xccdf-results-mapper.js.map