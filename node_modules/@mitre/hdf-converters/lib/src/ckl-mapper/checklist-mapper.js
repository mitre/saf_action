"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChecklistMapper = exports.ChecklistResults = exports.getChecklistObjectFromHdf = void 0;
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const xml_formatter_1 = __importDefault(require("xml-formatter"));
const package_json_1 = require("../../package.json");
const base_converter_1 = require("../base-converter");
const CciNistMapping_1 = require("../mappings/CciNistMapping");
const global_1 = require("../utils/global");
const checklist_jsonix_converter_1 = require("./checklist-jsonix-converter");
const jsonixMapping_1 = require("./jsonixMapping");
const checklist_metadata_utils_1 = require("./checklist-metadata-utils");
const parseJson_1 = require("../utils/parseJson");
var ImpactMapping;
(function (ImpactMapping) {
    ImpactMapping[ImpactMapping["high"] = 0.7] = "high";
    ImpactMapping[ImpactMapping["medium"] = 0.5] = "medium";
    ImpactMapping[ImpactMapping["low"] = 0.3] = "low";
})(ImpactMapping || (ImpactMapping = {}));
const CCI_NIST_TWO_WAY_MAPPER = new CciNistMapping_1.CciNistTwoWayMapper();
function cciRef(input) {
    return input.split('; ');
}
function nistTag(input) {
    const identifiers = cciRef(input);
    return CCI_NIST_TWO_WAY_MAPPER.nistFilter(identifiers, global_1.DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS);
}
function findSeverity(vuln) {
    let severity = vuln.severity;
    const hdfExistingData = (0, parseJson_1.parseJson)(vuln.thirdPartyTools);
    if (hdfExistingData.ok) {
        severity = lodash_1.default.get(hdfExistingData.value, 'hdfSpecificData.severity', severity);
    }
    return severity;
}
function findSeverityOverride(vuln) {
    let severityOverride = vuln.severityoverride;
    const hdfExistingData = (0, parseJson_1.parseJson)(vuln.thirdPartyTools);
    if (hdfExistingData.ok) {
        severityOverride = lodash_1.default.get(hdfExistingData.value, 'hdfSpecificData.severityoverride', severityOverride);
    }
    return severityOverride;
}
function computeSeverity(vuln) {
    const severity = findSeverity(vuln);
    const severityOverride = findSeverityOverride(vuln);
    let computed = severity;
    if (severityOverride)
        computed = severityOverride;
    if (!inspecjs_1.severities.find((severity) => severity === computed))
        throw new Error(`Severity "${computed}" does not match none, low, medium, high, or critical, please check severity for ${vuln.vulnNum}`);
    return computed;
}
function transformImpact(vuln) {
    if (vuln.status === 'Not Applicable')
        return 0.0;
    const severity = computeSeverity(vuln);
    let impact = ImpactMapping[severity];
    const hdfExistingData = (0, parseJson_1.parseJson)(vuln.thirdPartyTools);
    if (hdfExistingData.ok) {
        const maybeImpact = lodash_1.default.get(hdfExistingData.value, 'hdfSpecificData.impact', impact);
        if (typeof maybeImpact === 'number')
            impact = maybeImpact;
    }
    if (!impact)
        throw new Error(`Severity "${severity}" does not match low, medium, or high, please check severity for ${vuln.vulnNum}`);
    return impact;
}
function getStatus(input) {
    const status = input.toLowerCase();
    switch (status) {
        case 'notafinding':
        case 'passed':
            return inspecjs_1.ExecJSON.ControlResultStatus.Passed;
        case 'open':
        case 'failed':
            return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
        case 'error':
            return inspecjs_1.ExecJSON.ControlResultStatus.Error;
        default:
            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
    }
}
function checkMessage(typeCheck, messageType, message) {
    if (typeCheck === messageType) {
        return message;
    }
    else {
        return null;
    }
}
function parseFindingDetails(input) {
    const findings = input;
    const results = [];
    const findingDetails = findings[0].code_desc;
    const regex = /^(failed|passed|skipped|error) :: TEST (.*?)(?: :: (MESSAGE|SKIP_MESSAGE) (.*?))?$/s;
    if (!RegExp(regex).exec(findingDetails)) {
        return [
            {
                status: findings[0].status,
                code_desc: findings[0].code_desc,
                start_time: ''
            }
        ];
    }
    else {
        for (const details of findingDetails.split('\n--------------------------------\n')) {
            const match = regex.exec(details.trim());
            if (match) {
                const [, mStatus, mCode_dec, messageType, mMessage] = match;
                results.push({
                    status: getStatus(mStatus),
                    code_desc: mCode_dec,
                    message: checkMessage('MESSAGE', messageType, mMessage),
                    start_time: '',
                    skip_message: checkMessage('SKIP_MESSAGE', messageType, mMessage)
                });
            }
        }
    }
    return results;
}
function parseComments(input) {
    const descriptions = input;
    const results = [];
    const commentString = descriptions[0].data;
    if (!commentString) {
        return results;
    }
    else if (!commentString.includes(' :: ')) {
        return [
            {
                label: descriptions[0].label,
                data: descriptions[0].data
            }
        ];
    }
    else {
        for (const section of commentString.split(/\n(?=[A-Z]+ ::)/)) {
            const matches = RegExp(/([A-Z]+) :: (.+)/s).exec(section);
            if (matches) {
                const [, label, data] = matches;
                if (data) {
                    results.push({ data, label: label.toLowerCase() });
                }
            }
        }
    }
    return results;
}
function containsChecklist(object) {
    return lodash_1.default.has(object, 'passthrough.checklist');
}
function getChecklistObjectFromHdf(hdf) {
    if (lodash_1.default.get(hdf, 'passthrough.metadata')) {
        return (0, checklist_jsonix_converter_1.updateChecklistWithMetadata)(hdf);
    }
    return lodash_1.default.get(hdf, 'passthrough.checklist', checklist_jsonix_converter_1.EmptyChecklistObject);
}
exports.getChecklistObjectFromHdf = getChecklistObjectFromHdf;
function getAttributes(input) {
    var _a;
    const passthrough = input;
    const data = passthrough[0].data;
    if (!data) {
        return [];
    }
    else {
        return ((_a = JSON.parse(data).hdfSpecificData) === null || _a === void 0 ? void 0 : _a.attributes) || [];
    }
}
function getHdfSpecificDataAttribute(attribute, input) {
    const data = (0, parseJson_1.parseJson)(input);
    if (!data.ok)
        return undefined;
    const hdfSpecificData = lodash_1.default.get(data.value, 'hdfSpecificData');
    if (!lodash_1.default.isObject(hdfSpecificData))
        return undefined;
    return lodash_1.default.get(hdfSpecificData, attribute);
}
class ChecklistResults extends checklist_jsonix_converter_1.ChecklistJsonixConverter {
    constructor(data, withRaw = false) {
        super(jsonixMapping_1.jsonixMapping);
        this.data = data;
        if (typeof data === 'string') {
            this.jsonixData = super.toJsonix(data);
            this.checklistObject = super.toIntermediateObject(this.jsonixData);
            (0, checklist_metadata_utils_1.throwIfInvalidAssetMetadata)(this.checklistObject.asset);
        }
        else if (containsChecklist(data)) {
            this.checklistObject = getChecklistObjectFromHdf(data);
            (0, checklist_metadata_utils_1.throwIfInvalidAssetMetadata)(this.checklistObject.asset);
            this.jsonixData = super.fromIntermediateObject(this.checklistObject);
        }
        else {
            this.checklistObject = super.hdfToIntermediateObject(data);
            (0, checklist_metadata_utils_1.throwIfInvalidAssetMetadata)(this.checklistObject.asset);
            this.jsonixData = super.fromIntermediateObject(this.checklistObject);
        }
        this.withRaw = withRaw;
    }
    getJsonix() {
        return this.jsonixData;
    }
    toCkl() {
        return (0, xml_formatter_1.default)(`<?xml version="1.0" encoding="UTF-8"?><!--Heimdall Version :: ${package_json_1.version}-->${super.fromJsonix(this.jsonixData)}`, { lineSeparator: '\n', collapseContent: true, indentation: '\t' });
    }
    toHdf() {
        var _a;
        const numberOfStigs = this.checklistObject.stigs.length;
        if (numberOfStigs === 1) {
            const defaultChecklist = new ChecklistMapper(this.checklistObject);
            return defaultChecklist.toHdf();
        }
        else {
            const checklist = new ChecklistMapper(this.checklistObject);
            const original = checklist.toHdf();
            const parentProfileName = 'Parent Profile';
            const parent_profile = {
                name: parentProfileName,
                version: package_json_1.version,
                supports: [],
                attributes: [],
                groups: [],
                depends: [],
                controls: [],
                sha256: ''
            };
            for (const profile of original.profiles) {
                (_a = parent_profile.depends) === null || _a === void 0 ? void 0 : _a.push({ name: profile.name });
                parent_profile.controls.push(...profile.controls);
                profile.parent_profile = parentProfileName;
                profile.sha256 = (0, base_converter_1.generateHash)(JSON.stringify(profile));
            }
            parent_profile.sha256 = (0, base_converter_1.generateHash)(JSON.stringify(parent_profile));
            original.profiles.unshift(parent_profile);
            return original;
        }
    }
}
exports.ChecklistResults = ChecklistResults;
class ChecklistMapper extends base_converter_1.BaseConverter {
    constructor(checklistObject, withRaw = false) {
        super(checklistObject);
        this.mappings = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version
            },
            version: package_json_1.version,
            statistics: {},
            profiles: [
                {
                    path: 'stigs',
                    name: { path: 'header.stigid' },
                    version: {
                        path: 'header',
                        transformer: (input) => {
                            const ret = getHdfSpecificDataAttribute('version', input.customname) ||
                                input.version;
                            return ret;
                        }
                    },
                    title: { path: 'header.title' },
                    maintainer: {
                        path: 'header.customname',
                        transformer: lodash_1.default.partial(getHdfSpecificDataAttribute, 'maintainer')
                    },
                    summary: { path: 'header.description' },
                    license: { path: 'header.notice' },
                    copyright: {
                        path: 'header.customname',
                        transformer: lodash_1.default.partial(getHdfSpecificDataAttribute, 'copyright')
                    },
                    copyright_email: {
                        path: 'header.customname',
                        transformer: lodash_1.default.partial(getHdfSpecificDataAttribute, 'copyright_email')
                    },
                    supports: [],
                    attributes: [
                        {
                            arrayTransformer: getAttributes,
                            data: { path: 'header.customname' }
                        }
                    ],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: 'vulns',
                            key: 'id',
                            tags: {
                                gtitle: { path: 'groupTitle' },
                                rid: { path: 'ruleId' },
                                gid: { path: 'vulnNum' },
                                stig_id: { path: 'ruleVer' },
                                cci: {
                                    path: 'cciRef',
                                    transformer: cciRef
                                },
                                nist: {
                                    path: 'cciRef',
                                    transformer: nistTag
                                },
                                severity: {
                                    transformer: findSeverity
                                },
                                weight: { path: 'weight' },
                                transformer: (input) => {
                                    const tags = [
                                        ['IA_Controls', 'iaControls'],
                                        ['Legacy_ID', 'legacyId'],
                                        ['False_Positives', 'falsePositives'],
                                        ['False_Negatives', 'falseNegatives'],
                                        ['Mitigations', 'mitigations'],
                                        ['Mitigation_Controls', 'mitigationControl'],
                                        ['Potential_Impact', 'potentialImpact'],
                                        ['Responsibility', 'responsibility'],
                                        ['STIGRef', 'stigRef'],
                                        ['Security_Override_Guidance', 'securityOverrideGuidance'],
                                        ['severityjustification', 'severityjustification']
                                    ];
                                    const fullTags = {};
                                    for (const [key, path] of tags) {
                                        const tagValue = lodash_1.default.get(input, path);
                                        if (tagValue && tagValue !== '; ') {
                                            fullTags[key] = tagValue;
                                        }
                                    }
                                    const severityOverride = findSeverityOverride(input);
                                    if (severityOverride) {
                                        fullTags['severityoverride'] = severityOverride;
                                    }
                                    return fullTags;
                                }
                            },
                            refs: [],
                            source_location: {},
                            title: { path: 'ruleTitle' },
                            id: { path: 'vulnNum' },
                            desc: { path: 'vulnDiscuss' },
                            descriptions: [
                                {
                                    data: { path: 'checkContent' },
                                    label: 'check'
                                },
                                {
                                    data: { path: 'fixText' },
                                    label: 'fix'
                                },
                                {
                                    arrayTransformer: parseComments,
                                    data: { path: 'comments' },
                                    label: 'comments'
                                }
                            ],
                            impact: {
                                transformer: transformImpact
                            },
                            code: {
                                transformer: (vulnerability) => {
                                    const data = (0, parseJson_1.parseJson)(vulnerability.thirdPartyTools);
                                    if (data.ok) {
                                        const code = lodash_1.default.get(data.value, 'hdfSpecificData.code');
                                        if (code)
                                            return code;
                                    }
                                    return JSON.stringify(vulnerability, null, 2);
                                }
                            },
                            results: [
                                {
                                    arrayTransformer: parseFindingDetails,
                                    status: {
                                        path: 'status',
                                        transformer: getStatus
                                    },
                                    code_desc: { path: 'findingdetails' },
                                    start_time: ''
                                }
                            ]
                        }
                    ],
                    sha256: ''
                }
            ],
            passthrough: {
                transformer: (data) => {
                    return {
                        ...{
                            checklist: {
                                asset: data.asset,
                                stigs: data.stigs
                            }
                        },
                        ...(this.withRaw && { raw: data.jsonixData })
                    };
                }
            }
        };
        this.withRaw = withRaw;
    }
}
exports.ChecklistMapper = ChecklistMapper;
//# sourceMappingURL=checklist-mapper.js.map