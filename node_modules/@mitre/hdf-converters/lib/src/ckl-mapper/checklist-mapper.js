"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChecklistMapper = exports.ChecklistResults = void 0;
const inspecjs_1 = require("inspecjs");
const _ = __importStar(require("lodash"));
const package_json_1 = require("../../package.json");
const base_converter_1 = require("../base-converter");
const CciNistMapping_1 = require("../mappings/CciNistMapping");
const global_1 = require("../utils/global");
const checklist_jsonix_converter_1 = require("./checklist-jsonix-converter");
const checklistMapping = __importStar(require("./jsonixMapping"));
var ImpactMapping;
(function (ImpactMapping) {
    ImpactMapping[ImpactMapping["high"] = 0.7] = "high";
    ImpactMapping[ImpactMapping["medium"] = 0.5] = "medium";
    ImpactMapping[ImpactMapping["low"] = 0.3] = "low";
})(ImpactMapping || (ImpactMapping = {}));
const CCI_NIST_MAPPING = new CciNistMapping_1.CciNistMapping();
function cciRef(input) {
    return input.split('; ');
}
function nistTag(input) {
    const identifiers = cciRef(input);
    return CCI_NIST_MAPPING.nistFilter(identifiers, global_1.DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS);
}
function findSeverity(vuln) {
    if (vuln.severityoverride) {
        return vuln.severityoverride;
    }
    return vuln.severity;
}
function transformImpact(vuln) {
    if (vuln.status === 'Not Applicable')
        return 0.0;
    const severity = findSeverity(vuln);
    const impact = ImpactMapping[severity.toLowerCase()];
    if (!impact)
        throw new Error(`Severity "${severity}" does not match low, medium, or high, please check severity for ${vuln.vulnNum}`);
    return impact;
}
function getStatus(input) {
    const status = input.toLowerCase();
    switch (status) {
        case 'notafinding':
        case 'passed':
            return inspecjs_1.ExecJSON.ControlResultStatus.Passed;
        case 'open':
        case 'failed':
            return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
        case 'error':
            return inspecjs_1.ExecJSON.ControlResultStatus.Error;
        default:
            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
    }
}
function parseFindingDetails(input) {
    const findings = input;
    const results = [];
    const statusSet = ['passed', 'failed', 'skipped', 'error'];
    for (const finding of findings) {
        if (!finding.code_desc) {
            results.push({
                status: finding.status,
                code_desc: finding.code_desc,
                start_time: finding.start_time
            });
        }
        else {
            for (const details of finding.code_desc.split('--------------------------------\n')) {
                let code_desc;
                let status;
                let message = '';
                const [findingStatus, descAndMessage] = details.split(/\n(.*)/s, 2);
                if (statusSet.includes(findingStatus)) {
                    const indexOfExpected = descAndMessage.indexOf('\nexpected');
                    if (indexOfExpected > 0) {
                        code_desc = descAndMessage.slice(0, indexOfExpected - 1);
                        message = descAndMessage.slice(indexOfExpected);
                        status = getStatus(findingStatus);
                    }
                    else {
                        code_desc = descAndMessage;
                        status = getStatus(findingStatus);
                    }
                }
                else {
                    code_desc = details;
                    status = finding.status;
                }
                results.push({
                    code_desc,
                    status,
                    message: message ? message : null,
                    start_time: ''
                });
            }
        }
    }
    return results;
}
class ChecklistResults extends checklist_jsonix_converter_1.ChecklistJsonixConverter {
    constructor(checklistXml, withRaw = false) {
        super(checklistXml);
        this.checklistXml = checklistXml;
        this.withRaw = withRaw;
        this.jsonixData = super.toJsonix(checklistMapping.jsonixMapping);
        this.checklistObject = super.toIntermediateObject(this.jsonixData);
    }
    toHdf() {
        var _a;
        const numberOfStigs = this.checklistObject.stigs.length;
        if (numberOfStigs === 1) {
            const defaultChecklist = new ChecklistMapper(this.checklistObject);
            return defaultChecklist.toHdf();
        }
        else {
            const checklist = new ChecklistMapper(this.checklistObject);
            const original = checklist.toHdf();
            const parentProfileName = 'Parent Profile';
            const parent_profile = {
                name: parentProfileName,
                version: package_json_1.version,
                supports: [],
                attributes: [],
                groups: [],
                depends: [],
                controls: [],
                sha256: ''
            };
            for (const profile of original.profiles) {
                (_a = parent_profile.depends) === null || _a === void 0 ? void 0 : _a.push({ name: profile.name });
                parent_profile.controls.push(...profile.controls);
                profile.parent_profile = parentProfileName;
                profile.sha256 = (0, base_converter_1.generateHash)(JSON.stringify(profile));
            }
            parent_profile.sha256 = (0, base_converter_1.generateHash)(JSON.stringify(parent_profile));
            original.profiles.unshift(parent_profile);
            return original;
        }
    }
}
exports.ChecklistResults = ChecklistResults;
class ChecklistMapper extends base_converter_1.BaseConverter {
    constructor(checklistObject, withRaw = false) {
        super(checklistObject);
        this.mappings = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version
            },
            version: package_json_1.version,
            statistics: {},
            profiles: [
                {
                    path: 'stigs',
                    name: { path: 'header.title' },
                    version: { path: 'header.version' },
                    title: { path: 'header.title' },
                    summary: { path: 'header.description' },
                    license: { path: 'header.notice' },
                    supports: [],
                    attributes: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: 'vulns',
                            key: 'id',
                            tags: {
                                gtitle: { path: 'groupTitle' },
                                rid: { path: 'ruleId' },
                                gid: { path: 'vulnNum' },
                                stig_id: { path: 'ruleVersion' },
                                cci: {
                                    path: 'cciRef',
                                    transformer: cciRef
                                },
                                nist: {
                                    path: 'cciRef',
                                    transformer: nistTag
                                },
                                weight: { path: 'weight' },
                                transformer: (input) => {
                                    const tags = [
                                        ['IA Controls', 'iaControls'],
                                        ['Legacy ID', 'legacyId'],
                                        ['False Positives', 'falsePositives'],
                                        ['False Negatives', 'falseNegatives'],
                                        ['Mitigations', 'mitigations'],
                                        ['Mitigation Controls', 'mitigationControl'],
                                        ['Potential Impact', 'potentialImpact'],
                                        ['Responsibility', 'responsibility'],
                                        ['STIGRef', 'stigRef'],
                                        ['Security Override Guidance', 'securityOverrideGuidance'],
                                        ['Severity Justification', 'severityJustification']
                                    ];
                                    const fullTags = {};
                                    for (const [key, path] of tags) {
                                        const tagValue = _.get(input, path);
                                        if (tagValue && tagValue !== '; ') {
                                            fullTags[key] = tagValue;
                                        }
                                    }
                                    return fullTags;
                                }
                            },
                            refs: [],
                            source_location: {},
                            title: { path: 'ruleTitle' },
                            id: { path: 'vulnNum' },
                            desc: { path: 'vulnDiscuss' },
                            descriptions: [
                                {
                                    data: { path: 'checkContent' },
                                    label: 'check'
                                },
                                {
                                    data: { path: 'fixText' },
                                    label: 'fix'
                                },
                                {
                                    data: { path: 'comments' },
                                    label: 'comments'
                                }
                            ],
                            impact: {
                                transformer: (vulnerability) => transformImpact(vulnerability)
                            },
                            code: {
                                transformer: (vulnerability) => JSON.stringify(vulnerability, null, 2)
                            },
                            results: [
                                {
                                    arrayTransformer: parseFindingDetails,
                                    status: {
                                        path: 'status',
                                        transformer: getStatus
                                    },
                                    code_desc: { path: 'findingdetails' },
                                    start_time: ''
                                }
                            ]
                        }
                    ],
                    sha256: ''
                }
            ],
            passthrough: {
                transformer: (data) => {
                    return {
                        ...{
                            checklist: {
                                asset: data.asset,
                                stigs: data.stigs
                            }
                        },
                        ...(this.withRaw && { raw: data.jsonixData })
                    };
                }
            }
        };
        this.withRaw = withRaw;
    }
}
exports.ChecklistMapper = ChecklistMapper;
//# sourceMappingURL=checklist-mapper.js.map