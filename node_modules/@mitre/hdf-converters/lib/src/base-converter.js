"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseConverter = exports.impactMapping = exports.parseCsv = exports.parseXml = exports.parseHtml = exports.generateHash = void 0;
const crypto_1 = require("crypto");
const fast_xml_parser_1 = __importDefault(require("fast-xml-parser"));
const htmlparser = __importStar(require("htmlparser2"));
const lodash_1 = __importDefault(require("lodash"));
const papaparse_1 = __importDefault(require("papaparse"));
function generateHash(data, algorithm = 'sha256') {
    const hash = (0, crypto_1.createHash)(algorithm);
    return hash.update(data).digest('hex');
}
exports.generateHash = generateHash;
function parseHtml(input) {
    const textData = [];
    const myParser = new htmlparser.Parser({
        ontext(text) {
            textData.push(text);
        }
    });
    if (typeof input === 'string') {
        myParser.write(input);
        myParser.end();
    }
    return textData.join('');
}
exports.parseHtml = parseHtml;
function parseXml(xml) {
    const options = {
        attributeNamePrefix: '',
        textNodeName: 'text',
        ignoreAttributes: false
    };
    return fast_xml_parser_1.default.parse(xml, options);
}
exports.parseXml = parseXml;
function parseCsv(csv) {
    const result = papaparse_1.default.parse(csv.trim(), { header: true });
    if (result.errors.length) {
        throw result.errors;
    }
    return result.data;
}
exports.parseCsv = parseCsv;
function impactMapping(mapping) {
    return (severity) => {
        if (typeof severity === 'string' || typeof severity === 'number') {
            return mapping.get(severity.toString().toLowerCase()) || 0;
        }
        else {
            return 0;
        }
    };
}
exports.impactMapping = impactMapping;
function collapseDuplicates(array, key, collapseResults) {
    const seen = new Map();
    const newArray = [];
    let counter = 0;
    array.forEach((item) => {
        const propertyValue = lodash_1.default.get(item, key);
        if (typeof propertyValue === 'string') {
            const index = seen.get(propertyValue) || 0;
            if (!seen.has(propertyValue)) {
                newArray.push(item);
                seen.set(propertyValue, counter);
                counter++;
            }
            else {
                const oldResult = lodash_1.default.get(newArray[index], 'results');
                const descriptions = oldResult.map((element) => lodash_1.default.get(element, 'code_desc'));
                if (collapseResults) {
                    if (descriptions.indexOf(lodash_1.default.get(item, 'results[0].code_desc')) === -1) {
                        lodash_1.default.set(newArray[index], 'results', oldResult.concat(lodash_1.default.get(item, 'results')));
                    }
                }
                else {
                    lodash_1.default.set(newArray[index], 'results', oldResult.concat(lodash_1.default.get(item, 'results')));
                }
            }
        }
    });
    return newArray;
}
class BaseConverter {
    constructor(data, collapseResults = false) {
        this.data = data;
        this.collapseResults = collapseResults;
    }
    setMappings(mappings) {
        this.mappings = mappings;
    }
    toHdf() {
        if (this.mappings === undefined) {
            throw new Error('Mappings must be provided');
        }
        else {
            const v = this.convertInternal(this.data, this.mappings);
            v.profiles.forEach((element) => {
                element.sha256 = generateHash(JSON.stringify(element));
            });
            return v;
        }
    }
    objectMap(obj, fn) {
        return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, fn(v)]));
    }
    convertInternal(file, fields) {
        const isShortcircuiting = lodash_1.default.isObject(fields) &&
            lodash_1.default.has(fields, 'shortcircuit') &&
            lodash_1.default.isBoolean(lodash_1.default.get(fields, 'shortcircuit')) &&
            lodash_1.default.get(fields, 'shortcircuit');
        if (isShortcircuiting) {
            return lodash_1.default.omit(fields, 'shortcircuit');
        }
        const result = this.objectMap(fields, (v) => this.evaluate(file, v));
        return result;
    }
    evaluate(file, v) {
        const hasTransformer = lodash_1.default.isObject(v) &&
            lodash_1.default.has(v, 'transformer') &&
            lodash_1.default.isFunction(lodash_1.default.get(v, 'transformer'));
        let transformer = (val) => val;
        if (hasTransformer) {
            transformer = lodash_1.default.get(v, 'transformer');
            v = lodash_1.default.omit(v, 'transformer');
        }
        const hasPath = lodash_1.default.isObject(v) && lodash_1.default.has(v, 'path');
        let pathV = v;
        if (hasPath) {
            pathV = this.handlePath(file, lodash_1.default.get(v, 'path'));
            v = lodash_1.default.omit(v, 'path');
        }
        if (lodash_1.default.isString(pathV) ||
            lodash_1.default.isNumber(pathV) ||
            lodash_1.default.isBoolean(pathV) ||
            lodash_1.default.isNull(pathV)) {
            return transformer(pathV);
        }
        if (Array.isArray(pathV)) {
            return hasTransformer
                ? transformer(pathV)
                : this.handleArray(file, pathV);
        }
        if (lodash_1.default.keys(v).length > 0 && hasTransformer) {
            return {
                ...this.convertInternal(file, v),
                ...transformer(hasPath ? pathV : file)
            };
        }
        return (hasTransformer
            ? transformer(hasPath ? pathV : file)
            : hasPath
                ? pathV
                : this.convertInternal(file, v));
    }
    handleArray(file, v) {
        var _a, _b, _c;
        if (v.length === 0) {
            return [];
        }
        const resultingData = [];
        for (const lookupPath of v) {
            if (lookupPath.path === undefined) {
                const arrayTransformer = (_a = lookupPath.arrayTransformer) === null || _a === void 0 ? void 0 : _a.bind(this);
                v = v.map((element) => {
                    return lodash_1.default.isObject(element)
                        ? lodash_1.default.omit(element, ['arrayTransformer'])
                        : element;
                });
                let output = [];
                v.forEach((element) => {
                    output.push(this.evaluate(file, element));
                });
                if (arrayTransformer !== undefined) {
                    if (Array.isArray(arrayTransformer)) {
                        output = arrayTransformer[0].apply(arrayTransformer[1], [
                            v,
                            this.data
                        ]);
                    }
                    else {
                        output = arrayTransformer.apply(null, [output, this.data]);
                    }
                }
                resultingData.push(...output);
            }
            else {
                const path = lookupPath.path;
                const key = lookupPath.key;
                const arrayTransformer = (_b = lookupPath.arrayTransformer) === null || _b === void 0 ? void 0 : _b.bind(this);
                const transformer = (_c = lookupPath.transformer) === null || _c === void 0 ? void 0 : _c.bind(this);
                if (this.hasPath(file, path)) {
                    const pathVal = this.handlePath(file, path);
                    if (Array.isArray(pathVal)) {
                        v = pathVal.map((element) => {
                            return lodash_1.default.omit(this.convertInternal(element, lookupPath), [
                                'path',
                                'transformer',
                                'arrayTransformer',
                                'key'
                            ]);
                        });
                        if (arrayTransformer !== undefined) {
                            if (Array.isArray(arrayTransformer)) {
                                v = arrayTransformer[0].apply(arrayTransformer[1], [
                                    v,
                                    this.data
                                ]);
                            }
                            else {
                                v = arrayTransformer.apply(null, [v, this.data]);
                            }
                        }
                        if (key !== undefined) {
                            v = collapseDuplicates(v, key, this.collapseResults);
                        }
                        resultingData.push(...v);
                    }
                    else {
                        if (transformer !== undefined) {
                            resultingData.push(transformer(this.handlePath(file, path)));
                        }
                        else {
                            resultingData.push(this.handlePath(file, path));
                        }
                    }
                }
            }
        }
        const uniqueResults = [];
        resultingData.forEach((result) => {
            if (!uniqueResults.some((uniqueResult) => lodash_1.default.isEqual(result, uniqueResult))) {
                uniqueResults.push(result);
            }
        });
        return uniqueResults;
    }
    handlePath(file, path) {
        let pathArray;
        if (typeof path === 'string') {
            pathArray = [path];
        }
        else {
            pathArray = path;
        }
        const index = lodash_1.default.findIndex(pathArray, (p) => this.hasPath(file, p));
        if (index === -1) {
            return '';
        }
        else if (pathArray[index].startsWith('$.')) {
            return lodash_1.default.get(this.data, pathArray[index].slice(2)) || '';
        }
        else {
            return lodash_1.default.get(file, pathArray[index]) || '';
        }
    }
    hasPath(file, path) {
        let pathArray;
        if (typeof path === 'string') {
            pathArray = [path];
        }
        else {
            pathArray = path;
        }
        return lodash_1.default.some(pathArray, (p) => {
            if (p.startsWith('$.')) {
                return lodash_1.default.has(this.data, p.slice(2));
            }
            else {
                return lodash_1.default.has(file, p);
            }
        });
    }
}
exports.BaseConverter = BaseConverter;
//# sourceMappingURL=base-converter.js.map