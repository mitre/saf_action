import splunkjs, { Job } from '@mitre/splunk-sdk-no-env';
import { ExecJSON } from 'inspecjs';
import { Logger } from 'winston';
import { SplunkConfig } from './converters-from-hdf/splunk/reverse-splunk-mapper';
export declare type Hash<T> = {
    [key: string]: T;
};
export declare type SplunkConfigNoIndex = Omit<SplunkConfig, 'index'>;
export declare type GenericPayloadWithMetaData = {
    meta: FileMetaData;
    [key: string]: never[] | Record<string, unknown>;
};
export declare type FileMetaData = {
    guid: string;
    subtype: string;
    hdf_splunk_schema: string;
    filetype: string;
    filename: string;
    profile_sha256: string;
    [key: string]: never[] | unknown;
};
export declare function group_by<T>(items: Array<T>, keyGetter: (v: T) => string): Hash<Array<T>>;
export declare function map_hash<T, G>(old: Hash<T>, mapFunction: (v: T) => G): Hash<G>;
export declare function consolidate_payloads(payloads: GenericPayloadWithMetaData[]): ExecJSON.Execution[];
export declare function replaceKeyValueDescriptions(controls: (ExecJSON.Control & GenericPayloadWithMetaData & {
    descriptions?: {
        [key: string]: string;
    } | ExecJSON.ControlDescription[];
})[]): (ExecJSON.Control & GenericPayloadWithMetaData & {
    descriptions?: ExecJSON.ControlDescription[] | {
        [key: string]: string;
    } | undefined;
})[];
export declare function checkSplunkCredentials(config: SplunkConfig, webCompatibility: boolean): Promise<boolean>;
export declare class SplunkMapper {
    config: SplunkConfig;
    service: splunkjs.Service;
    webCompatibility: boolean;
    constructor(config: SplunkConfig, webCompatibility?: boolean, logService?: Logger, loggingLevel?: string);
    createJob(query: string): Promise<Job>;
    parseSplunkResponse(query: string, results: {
        fields: string[];
        rows: string[];
    }): Record<string, unknown>[];
    queryData(query: string): Promise<any[]>;
    toHdf(guid: string): Promise<ExecJSON.Execution>;
}
