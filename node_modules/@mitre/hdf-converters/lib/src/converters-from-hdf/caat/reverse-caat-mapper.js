"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FromHDFToCAATMapper = exports.CAATHeaders = void 0;
const XLSX = __importStar(require("@e965/xlsx"));
const inspecjs_1 = require("inspecjs");
const _ = __importStar(require("lodash"));
const global_1 = require("../../utils/global");
exports.CAATHeaders = [
    'Control Number',
    'Finding Title',
    'Date Identified',
    'Finding ID',
    'Information System or Program Name',
    'Repeat Findings',
    'Repeat Finding Weakness ID',
    'Finding Description',
    'Weakness Description',
    'Control Weakness Type',
    'Source',
    'Assessment/Audit Company',
    'Test Method',
    'Test Objective',
    'Test Result Description',
    'Test Result',
    'Recommended Corrective Action(s)',
    'Effect on Business',
    'Likelihood',
    'Impact'
];
class FromHDFToCAATMapper {
    static formatDate(date, delimiter) {
        return [
            Intl.DateTimeFormat('en-US', { month: '2-digit' }),
            Intl.DateTimeFormat('en-US', { day: '2-digit' }),
            Intl.DateTimeFormat('en-US', { year: 'numeric' })
        ]
            .map((formatter) => formatter.format(date))
            .join(delimiter);
    }
    static fix(str) {
        return (str ?? '')
            .replace(/(\r\n|\n|\r)/gmu, '\r\n')
            .slice(0, FromHDFToCAATMapper.MaxCellSize);
    }
    constructor(data) {
        if (!Array.isArray(data)) {
            data = [data];
        }
        this.data = data.map((datum) => {
            let contextualizedEvaluation = datum.data;
            if (_.isString(contextualizedEvaluation)) {
                const contextualizedFile = (0, inspecjs_1.convertFileContextual)(contextualizedEvaluation);
                if (!(0, inspecjs_1.isContextualizedEvaluation)(contextualizedFile)) {
                    throw new Error('Input string was not an HDF ExecJSON');
                }
                contextualizedEvaluation = contextualizedFile;
            }
            contextualizedEvaluation = (0, global_1.ensureContextualizedEvaluation)(contextualizedEvaluation);
            return {
                data: contextualizedEvaluation,
                filename: datum.filename ??
                    contextualizedEvaluation.data.profiles.at(0)?.name ??
                    'ExecJSON',
                controls: datum.controls
            };
        });
    }
    newCaveat(hdf) {
        const caveat = hdf.descriptions.caveat
            ? `(Caveat: ${FromHDFToCAATMapper.fix(hdf.descriptions.caveat)})\r\n`
            : '';
        return `${caveat}${FromHDFToCAATMapper.fix(hdf.wraps.desc)}`;
    }
    newTestResultDescription(hdf) {
        const controlStatus = `${hdf.status}:\r\n\r\n`;
        const description = hdf.segments
            ?.map((result) => {
            const statusAndTest = `${result.status.toUpperCase()} -- Test: ${result.code_desc}\r\n`;
            const message = result.message
                ? `Message: ${result.message}\r\n\r\n`
                : '\r\n';
            return `${statusAndTest}${message}`;
        })
            .join('') ?? '';
        return `${controlStatus}${description}`;
    }
    newTestResult(hdf) {
        return hdf.status === 'Passed' ? 'Satisfied' : 'Other Than Satisfied';
    }
    newImpact(hdf) {
        const controlSeverity = hdf.severity === 'medium' ? 'moderate' : hdf.severity;
        return FromHDFToCAATMapper.fix(hdf.wraps.impact === 0 ? 'none' : controlSeverity);
    }
    getRow(control, filename) {
        const hdf = control.hdf;
        const allRows = _.compact(hdf
            .canonized_nist(FromHDFToCAATMapper.NistCanonizationConfig)
            .map((formattedNistTag) => {
            if (!formattedNistTag) {
                return;
            }
            const row = {};
            row['Control Number'] = formattedNistTag;
            row['Finding Title'] = `Test ${FromHDFToCAATMapper.fix(hdf.wraps.id)} - ${FromHDFToCAATMapper.fix(hdf.wraps.title)}`;
            if (hdf.start_time) {
                row['Date Identified'] = FromHDFToCAATMapper.formatDate(new Date(hdf.start_time), '/');
            }
            row['Finding ID'] = `${filename} - Test ${FromHDFToCAATMapper.fix(hdf.wraps.id)}`;
            row['Finding Description'] = FromHDFToCAATMapper.fix(hdf.wraps.title);
            row['Weakness Description'] = this.newCaveat(hdf);
            row['Control Weakness Type'] = 'Security';
            row['Source'] = 'Self-Assessment';
            row['Test Method'] = 'Test';
            row['Test Objective'] = FromHDFToCAATMapper.fix(hdf.descriptions.check ?? hdf.wraps.tags.check);
            row['Test Result Description'] = FromHDFToCAATMapper.fix(this.newTestResultDescription(hdf));
            row['Test Result'] = this.newTestResult(hdf);
            row['Recommended Corrective Action(s)'] = FromHDFToCAATMapper.fix(hdf.descriptions.fix ?? hdf.wraps.tags.fix);
            row['Impact'] = this.newImpact(hdf);
            return row;
        }));
        return allRows;
    }
    toCAAT(returnWorkBook = false, options = { bookType: 'xlsx', type: 'binary' }) {
        const takenSheetNames = [];
        const workBook = XLSX.utils.book_new();
        for (const d of this.data) {
            let renameCount = 2;
            const fullName = `${d.filename ?? d.data.data.profiles.at(0)?.name ?? 'ExecJSON'}`;
            let sheetName = fullName.substring(0, FromHDFToCAATMapper.MaxSheetNameLength);
            while (takenSheetNames.includes(sheetName)) {
                sheetName =
                    fullName.substring(0, FromHDFToCAATMapper.MaxSheetNameLength - 5) +
                        ` (${renameCount})`;
                renameCount++;
            }
            takenSheetNames.push(sheetName);
            workBook.SheetNames.push(sheetName);
            workBook.Props = FromHDFToCAATMapper.FileSettings;
            const processedControls = new Set();
            const rows = [];
            for (const control of d.controls ??
                d.data.contains.flatMap((profile) => profile.contains)) {
                const root = control.root;
                if (processedControls.has(root.hdf.wraps.id)) {
                    continue;
                }
                processedControls.add(root.hdf.wraps.id);
                rows.push(...this.getRow(root, d.filename));
            }
            rows.sort((x, y) => x['Finding Title']?.localeCompare(y['Finding Title'] ?? '') ?? 1);
            const workSheet = XLSX.utils.json_to_sheet(rows, FromHDFToCAATMapper.SheetOptions);
            workBook.Sheets[sheetName] = workSheet;
        }
        if (returnWorkBook) {
            return workBook;
        }
        return XLSX.write(workBook, options);
    }
}
exports.FromHDFToCAATMapper = FromHDFToCAATMapper;
FromHDFToCAATMapper.MaxCellSize = 32000;
FromHDFToCAATMapper.MaxSheetNameLength = 31;
FromHDFToCAATMapper.NistCanonizationConfig = {
    max_specifiers: 3,
    pad_zeros: true,
    allow_letters: false,
    add_spaces: false
};
FromHDFToCAATMapper.FileSettings = {
    Title: 'Compliance Assessment/Audit Tracking (CAAT) Spreadsheet',
    Subject: 'Assessment Data',
    Author: 'MITRE SAF',
    CreatedDate: new Date()
};
FromHDFToCAATMapper.SheetOptions = {
    header: exports.CAATHeaders.slice()
};
//# sourceMappingURL=reverse-caat-mapper.js.map