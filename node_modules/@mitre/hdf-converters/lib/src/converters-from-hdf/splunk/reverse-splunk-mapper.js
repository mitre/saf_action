"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FromHDFToSplunkMapper = exports.FromHDFControlToSplunkControlMapper = exports.FromHDFProfileToSplunkProfileMapper = exports.FromHDFExecutionToSplunkExecutionMapper = exports.createControlMapping = exports.createProfileMapping = exports.getProfileRunLevel = exports.getDependencies = exports.createReportMapping = exports.contextualizeIfNeeded = exports.createGUID = void 0;
const axios_1 = __importDefault(require("axios"));
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const global_1 = require("../../utils/global");
const splunk_tools_1 = require("../../utils/splunk-tools");
const reverse_any_base_converter_1 = require("../reverse-any-base-converter");
const HDF_SPLUNK_SCHEMA = '1.1';
const MAPPER_NAME = 'HDF2Splunk';
const UPLOAD_CHUNK_SIZE = 100;
let logger = (0, global_1.createWinstonLogger)('HDF2Splunk', 'INFO');
function createGUID(length) {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}
exports.createGUID = createGUID;
function contextualizeIfNeeded(data) {
    if ('contains' in data) {
        return data;
    }
    else {
        return (0, inspecjs_1.contextualizeEvaluation)(data);
    }
}
exports.contextualizeIfNeeded = contextualizeIfNeeded;
function createReportMapping(execution, filename, guid) {
    return {
        meta: {
            guid: guid,
            filename: filename,
            subtype: 'header',
            hdf_splunk_schema: HDF_SPLUNK_SCHEMA,
            filetype: 'evaluation'
        },
        passthrough: lodash_1.default.get(execution, 'data.passthrough'),
        profiles: [],
        platform: execution.data.platform,
        statistics: execution.data.statistics,
        version: execution.data.version
    };
}
exports.createReportMapping = createReportMapping;
function getDependencies(profile, execution) {
    if (profile && execution) {
        const dependencies = [];
        if (profile.data.depends) {
            for (const dependency of profile.data.depends) {
                if (dependency.name) {
                    dependencies.push(dependency.name);
                    dependencies.push(...getDependencies(execution.contains.find((execProfile) => execProfile.data.name === dependency.name), execution));
                }
            }
        }
        return dependencies;
    }
    return [];
}
exports.getDependencies = getDependencies;
function getProfileRunLevel(profile, execution) {
    return getDependencies(profile, execution).length;
}
exports.getProfileRunLevel = getProfileRunLevel;
function createProfileMapping(filename, guid) {
    return {
        meta: {
            filename: filename,
            filetype: 'evaluation',
            guid: guid,
            hdf_splunk_schema: HDF_SPLUNK_SCHEMA,
            is_baseline: {
                path: 'data.depends[0].name',
                transformer: (value) => {
                    return !Boolean(value);
                }
            },
            profile_sha256: {
                path: 'data.sha256'
            },
            subtype: 'profile'
        },
        summary: {
            path: 'data.summary'
        },
        name: {
            path: 'data.name'
        },
        sha256: {
            path: 'data.sha256'
        },
        supports: {
            path: 'data.supports'
        },
        copyright: {
            path: 'data.copyright'
        },
        copyright_email: {
            path: 'data.copyright_email'
        },
        maintainer: {
            path: 'data.maintainer'
        },
        version: {
            path: 'data.version'
        },
        license: {
            path: 'data.license'
        },
        title: {
            path: 'data.title'
        },
        controls: [],
        parent_profile: {
            path: 'data.parent_profile'
        },
        depends: {
            path: 'data.depends',
            default: []
        },
        attributes: {
            path: 'data.attributes'
        },
        groups: {
            path: 'data.groups'
        },
        status: {
            path: 'data.status'
        }
    };
}
exports.createProfileMapping = createProfileMapping;
function createControlMapping(control, profile, execution, filename, guid) {
    return {
        meta: {
            guid: guid,
            status: {
                transformer: (data) => {
                    var _a;
                    if (((_a = data.hdf.segments) === null || _a === void 0 ? void 0 : _a.length) === 0 &&
                        data.extendsFrom.length !== 0) {
                        return 'Overlaid Control';
                    }
                    else {
                        return data.hdf.status;
                    }
                }
            },
            profile_sha256: profile.data.sha256,
            filename: filename,
            subtype: 'control',
            hdf_splunk_schema: HDF_SPLUNK_SCHEMA,
            filetype: 'evaluation',
            is_baseline: getProfileRunLevel(profile, execution) === 0,
            is_waived: control.hdf.waived,
            overlay_depth: getProfileRunLevel(profile, execution) + 1
        },
        title: control.data.title,
        code: control.data.code || '',
        desc: control.data.desc || '',
        descriptions: {
            path: 'data.descriptions',
            transformer: (data) => {
                const descObjects = {};
                if (Array.isArray(data)) {
                    for (const item of data) {
                        descObjects[item['label']] = item['data'];
                    }
                }
                return descObjects;
            }
        },
        id: control.data.id,
        impact: control.data.impact,
        refs: control.data.refs || [],
        source_location: control.data.source_location,
        tags: control.data.tags,
        results: control.hdf.segments
    };
}
exports.createControlMapping = createControlMapping;
class FromHDFExecutionToSplunkExecutionMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(evaluation, filename, guid) {
        super(evaluation);
        this.setMappings(createReportMapping(evaluation, filename, guid));
    }
    toSplunkExecution() {
        return this.convertInternal(this.data, this.mappings);
    }
}
exports.FromHDFExecutionToSplunkExecutionMapper = FromHDFExecutionToSplunkExecutionMapper;
class FromHDFProfileToSplunkProfileMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(profile, filename, guid) {
        super(profile);
        this.setMappings(createProfileMapping(filename, guid));
    }
    toSplunkProfile() {
        return this.convertInternal(this.data, this.mappings);
    }
}
exports.FromHDFProfileToSplunkProfileMapper = FromHDFProfileToSplunkProfileMapper;
class FromHDFControlToSplunkControlMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(control, profile, execution, filename, guid) {
        super(control);
        this.setMappings(createControlMapping(control, profile, execution, filename, guid));
    }
    toSplunkControl() {
        return this.convertInternal(this.data, this.mappings);
    }
}
exports.FromHDFControlToSplunkControlMapper = FromHDFControlToSplunkControlMapper;
class FromHDFToSplunkMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(data, logService, loggingLevel) {
        if (logService) {
            logger = logService;
        }
        else {
            logger = (0, global_1.createWinstonLogger)(MAPPER_NAME, loggingLevel || 'debug');
        }
        super(contextualizeIfNeeded(data));
        this.axiosInstance = axios_1.default.create({ params: { output_mode: 'json' } });
        logger.debug(`Initialized ${this.constructor.name} successfully`);
    }
    createSplunkData(guid, filename) {
        const splunkData = {
            controls: [],
            profiles: [],
            reports: []
        };
        splunkData.reports.push(new FromHDFExecutionToSplunkExecutionMapper(this.data, filename, guid).toSplunkExecution());
        for (const profile of this.data.contains) {
            splunkData.profiles.push(new FromHDFProfileToSplunkProfileMapper(profile, filename, guid).toSplunkProfile());
            for (const control of profile.contains) {
                splunkData.controls.push(new FromHDFControlToSplunkControlMapper(control, profile, this.data, filename, guid).toSplunkControl());
            }
        }
        return splunkData;
    }
    async uploadSplunkData(config, targetIndex, splunkData) {
        const hostname = (0, splunk_tools_1.generateHostname)(config);
        this.axiosInstance.defaults.params['sourcetype'] = MAPPER_NAME;
        this.axiosInstance.defaults.params['index'] = targetIndex.name;
        try {
            const execEvents = splunkData.reports.map((report) => {
                return this.axiosInstance
                    .post(`${hostname}/services/receivers/simple`, JSON.stringify(report))
                    .then(() => {
                    logger.verbose(`Successfully uploaded execution for ${report.meta.filename}`);
                });
            });
            await Promise.all(execEvents);
            await this.axiosInstance.post(`${hostname}/services/receivers/simple`, splunkData.profiles.map((profile) => JSON.stringify(profile)).join('\n'));
            logger.verbose(`Successfully uploaded ${splunkData.profiles.length} profile layer(s)`);
            const controlEvents = lodash_1.default.chunk(splunkData.controls, UPLOAD_CHUNK_SIZE).map((chunk) => {
                return this.axiosInstance
                    .post(`${hostname}/services/receivers/simple`, chunk.map((control) => JSON.stringify(control)).join('\n'))
                    .then(() => logger.verbose(`Successfully uploaded ${chunk.length} control(s)`));
            });
            await Promise.all(controlEvents);
        }
        catch (error) {
            throw new Error((0, splunk_tools_1.handleSplunkErrorResponse)(error));
        }
    }
    async toSplunk(config, filename) {
        const hostname = (0, splunk_tools_1.generateHostname)(config);
        const returnCount = 0;
        let indexResponse;
        logger.info(`Logging into Splunk instance at ${hostname} with user ${config.username}`);
        logger.verbose(`Found designated file to transfer: ${filename}`);
        const guid = createGUID(30);
        logger.verbose(`Using GUID: ${guid}`);
        const authResponse = await (0, splunk_tools_1.checkSplunkCredentials)(config);
        this.axiosInstance.defaults.headers.common['Authorization'] = `Bearer ${authResponse}`;
        try {
            indexResponse = await this.axiosInstance.get(`${hostname}/services/data/indexes`, {
                params: { count: returnCount }
            });
        }
        catch (error) {
            throw new Error(`Failed to request indexes - ${(0, splunk_tools_1.handleSplunkErrorResponse)(error)}`);
        }
        if (!lodash_1.default.has(indexResponse, ['data', 'entry'])) {
            throw new Error('Failed to request indexes - Malformed index reponse received');
        }
        const indexes = indexResponse.data.entry;
        if (indexes.length <= 0) {
            throw new Error('Unable to retrieve available indexes, double-check your scheme configuration and try again');
        }
        else {
            const indexNames = indexes.map((index) => index.name);
            logger.verbose(`Available indexes: ${indexNames.join(', ')}`);
            if (indexNames.includes(config.index)) {
                const targetIndex = indexes.filter((index) => index.name === config.index)[0];
                logger.verbose(`Found index: ${targetIndex.name}`);
                const splunkData = this.createSplunkData(guid, filename);
                try {
                    await this.uploadSplunkData(config, targetIndex, splunkData);
                }
                catch (error) {
                    throw new Error(`Failed to upload to Splunk - ${(0, splunk_tools_1.handleSplunkErrorResponse)(error)}`);
                }
                logger.info(`Successfully uploaded to ${config.index}`);
                return guid;
            }
            else {
                throw new Error(`Invalid index - ${config.index}`);
            }
        }
    }
}
exports.FromHDFToSplunkMapper = FromHDFToSplunkMapper;
//# sourceMappingURL=reverse-splunk-mapper.js.map