"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FromHDFToSplunkMapper = exports.FromHDFControlToSplunkControlMapper = exports.FromHDFProfileToSplunkProfileMapper = exports.FromHDFExecutionToSplunkExecutionMapper = exports.createControlMapping = exports.createProfileMapping = exports.getProfileRunLevel = exports.getDependencies = exports.createReportMapping = exports.contextualizeIfNeeded = exports.createGUID = void 0;
const splunk_sdk_no_env_1 = __importDefault(require("@mitre/splunk-sdk-no-env"));
const jquery_http_1 = __importDefault(require("@mitre/splunk-sdk-no-env/lib/platform/client/jquery_http"));
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const global_1 = require("../../utils/global");
const reverse_any_base_converter_1 = require("../reverse-any-base-converter");
const HDF_SPLUNK_SCHEMA = '1.1';
const MAPPER_NAME = 'HDF2Splunk';
const UPLOAD_CHUNK_SIZE = 100;
let logger = (0, global_1.createWinstonLogger)('HDF2Splunk', 'INFO');
function createGUID(length) {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}
exports.createGUID = createGUID;
function contextualizeIfNeeded(data) {
    if ('contains' in data) {
        return data;
    }
    else {
        return (0, inspecjs_1.contextualizeEvaluation)(data);
    }
}
exports.contextualizeIfNeeded = contextualizeIfNeeded;
function createReportMapping(execution, filename, guid) {
    return {
        meta: {
            guid: guid,
            filename: filename,
            subtype: 'header',
            hdf_splunk_schema: HDF_SPLUNK_SCHEMA,
            filetype: 'evaluation'
        },
        passthrough: lodash_1.default.get(execution, 'data.passthrough'),
        profiles: [],
        platform: execution.data.platform,
        statistics: execution.data.statistics,
        version: execution.data.version
    };
}
exports.createReportMapping = createReportMapping;
function getDependencies(profile, execution) {
    var _a;
    if (profile && execution) {
        const dependencies = [];
        (_a = profile.data.depends) === null || _a === void 0 ? void 0 : _a.forEach((dependency) => {
            if (dependency.name) {
                dependencies.push(dependency.name);
                dependencies.push(...getDependencies(execution.contains.find((execProfile) => execProfile.data.name === dependency.name), execution));
            }
        });
        return dependencies;
    }
    return [];
}
exports.getDependencies = getDependencies;
function getProfileRunLevel(profile, execution) {
    return getDependencies(profile, execution).length;
}
exports.getProfileRunLevel = getProfileRunLevel;
function createProfileMapping(filename, guid) {
    return {
        meta: {
            filename: filename,
            filetype: 'evaluation',
            guid: guid,
            hdf_splunk_schema: HDF_SPLUNK_SCHEMA,
            is_baseline: {
                path: 'data.depends[0].name',
                transformer: (value) => {
                    return !Boolean(value);
                }
            },
            profile_sha256: {
                path: 'data.sha256'
            },
            subtype: 'profile'
        },
        summary: {
            path: 'data.summary'
        },
        name: {
            path: 'data.name'
        },
        sha256: {
            path: 'data.sha256'
        },
        supports: {
            path: 'data.supports'
        },
        copyright: {
            path: 'data.copyright'
        },
        copyright_email: {
            path: 'data.copyright_email'
        },
        maintainer: {
            path: 'data.maintainer'
        },
        version: {
            path: 'data.version'
        },
        license: {
            path: 'data.license'
        },
        title: {
            path: 'data.title'
        },
        controls: [],
        parent_profile: {
            path: 'data.parent_profile'
        },
        depends: {
            path: 'data.depends',
            default: []
        },
        attributes: {
            path: 'data.attributes'
        },
        groups: {
            path: 'data.groups'
        },
        status: {
            path: 'data.status'
        }
    };
}
exports.createProfileMapping = createProfileMapping;
function createControlMapping(control, profile, execution, filename, guid) {
    return {
        meta: {
            guid: guid,
            status: {
                transformer: (data) => {
                    var _a;
                    if (((_a = data.hdf.segments) === null || _a === void 0 ? void 0 : _a.length) === 0 &&
                        data.extendsFrom.length !== 0) {
                        return 'Overlaid Control';
                    }
                    else {
                        return data.hdf.status;
                    }
                }
            },
            profile_sha256: profile.data.sha256,
            filename: filename,
            subtype: 'control',
            hdf_splunk_schema: HDF_SPLUNK_SCHEMA,
            filetype: 'evaluation',
            is_baseline: getProfileRunLevel(profile, execution) === 0,
            is_waived: control.hdf.waived,
            overlay_depth: getProfileRunLevel(profile, execution) + 1
        },
        title: control.data.title,
        code: control.data.code || '',
        desc: control.data.desc || '',
        descriptions: {
            path: 'data.descriptions',
            transformer: (data) => {
                const descObjects = {};
                if (Array.isArray(data)) {
                    data.forEach((item) => {
                        descObjects[item['label']] = item['data'];
                    });
                }
                return descObjects;
            }
        },
        id: control.data.id,
        impact: control.data.impact,
        refs: control.data.refs || [],
        source_location: control.data.source_location,
        tags: control.data.tags,
        results: control.hdf.segments
    };
}
exports.createControlMapping = createControlMapping;
class FromHDFExecutionToSplunkExecutionMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(evaluation, filename, guid) {
        super(evaluation);
        this.setMappings(createReportMapping(evaluation, filename, guid));
    }
    toSplunkExecution() {
        return this.convertInternal(this.data, this.mappings);
    }
}
exports.FromHDFExecutionToSplunkExecutionMapper = FromHDFExecutionToSplunkExecutionMapper;
class FromHDFProfileToSplunkProfileMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(profile, filename, guid) {
        super(profile);
        this.setMappings(createProfileMapping(filename, guid));
    }
    toSplunkProfile() {
        return this.convertInternal(this.data, this.mappings);
    }
}
exports.FromHDFProfileToSplunkProfileMapper = FromHDFProfileToSplunkProfileMapper;
class FromHDFControlToSplunkControlMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(control, profile, execution, filename, guid) {
        super(control);
        this.setMappings(createControlMapping(control, profile, execution, filename, guid));
    }
    toSplunkControl() {
        return this.convertInternal(this.data, this.mappings);
    }
}
exports.FromHDFControlToSplunkControlMapper = FromHDFControlToSplunkControlMapper;
class FromHDFToSplunkMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(data, logService, loggingLevel) {
        if (logService) {
            logger = logService;
        }
        else {
            logger = (0, global_1.createWinstonLogger)(MAPPER_NAME, loggingLevel || 'debug');
        }
        super(contextualizeIfNeeded(data));
        logger.debug(`Initialized ${this.constructor.name} successfully`);
    }
    createSplunkData(guid, filename) {
        const splunkData = {
            controls: [],
            profiles: [],
            reports: []
        };
        splunkData.reports.push(new FromHDFExecutionToSplunkExecutionMapper(this.data, filename, guid).toSplunkExecution());
        this.data.contains.forEach((profile) => {
            splunkData.profiles.push(new FromHDFProfileToSplunkProfileMapper(profile, filename, guid).toSplunkProfile());
            profile.contains.forEach((control) => {
                splunkData.controls.push(new FromHDFControlToSplunkControlMapper(control, profile, this.data, filename, guid).toSplunkControl());
            });
        });
        return splunkData;
    }
    async uploadSplunkData(targetIndex, splunkData) {
        return new Promise((resolve, reject) => {
            splunkData.reports.forEach((report) => {
                targetIndex.submitEvent(JSON.stringify(report), {
                    sourcetype: MAPPER_NAME,
                    index: targetIndex.name
                }, (err) => {
                    if (err) {
                        reject(err);
                    }
                    logger.verbose(`Successfully uploaded execution for ${report.meta.filename}`);
                });
            });
            targetIndex.submitEvent(splunkData.profiles
                .map((profile) => JSON.stringify(profile))
                .join('\n'), {
                sourcetype: MAPPER_NAME,
                index: targetIndex.name
            }, (err) => {
                if (err) {
                    reject(err);
                }
                logger.verbose(`Successfully uploaded ${splunkData.profiles.length} profile layer(s)`);
            });
            lodash_1.default.chunk(splunkData.controls, UPLOAD_CHUNK_SIZE).forEach((chunk) => {
                targetIndex.submitEvent(chunk.map((control) => JSON.stringify(control)).join('\n'), {
                    sourcetype: MAPPER_NAME,
                    index: targetIndex.name
                }, (err) => {
                    if (err) {
                        reject(err);
                    }
                    logger.verbose(`Successfully uploaded ${chunk.length} control(s)`);
                    resolve();
                });
            });
        });
    }
    handleSplunkError(error) {
        if (error) {
            let errorMessage = '';
            try {
                const errorCode = lodash_1.default.get(error, 'status');
                if (typeof errorCode === 'number' && errorCode >= 600) {
                    errorMessage =
                        "Unable to connect to your splunk instance. Are you sure you're using the right HTTP Scheme? (http/https)";
                }
                else if (typeof errorCode === 'number' && errorCode === 401) {
                    errorMessage =
                        'Unable to login to your splunk instance. Incorrect username or password';
                }
                else if (typeof errorCode === 'number' && errorCode === 400) {
                    errorMessage =
                        'Unable to authenticate to your splunk instance. Invalid Token provided';
                }
                else {
                    errorMessage = JSON.stringify(error);
                }
            }
            catch {
                errorMessage = String(error);
            }
            logger.error(errorMessage);
            throw new Error(errorMessage);
        }
    }
    async toSplunk(config, filename, webCompatibility = false) {
        let service;
        if (webCompatibility) {
            service = new splunk_sdk_no_env_1.default.Service(new jquery_http_1.default.JQueryHttp(''), config);
        }
        else {
            service = new splunk_sdk_no_env_1.default.Service(config);
        }
        logger.info(`Logging into Splunk Service: ${config.host} with user ${config.username}`);
        logger.verbose('Got Execution: ' + filename);
        const guid = createGUID(30);
        logger.verbose('Using GUID: ' + guid);
        return new Promise((resolve) => {
            if (config.username && config.password) {
                service.login((error) => {
                    this.handleSplunkError(error);
                });
            }
            service.indexes().fetch(async (error, indexes) => {
                if (error) {
                    this.handleSplunkError(error);
                }
                else if (!indexes) {
                    throw new Error('Unable to get available indexes, double-check your scheme configuration and try again');
                }
                else {
                    const availableIndexes = indexes
                        .list()
                        .map((index) => index.name);
                    logger.verbose(`Available Indexes:  + ${availableIndexes.join(', ')}`);
                    if (availableIndexes.includes(config.index)) {
                        const targetIndex = indexes.item(config.index);
                        logger === null || logger === void 0 ? void 0 : logger.verbose(`Have index ${targetIndex.name}`);
                        const splunkData = this.createSplunkData(guid, filename);
                        this.uploadSplunkData(targetIndex, splunkData)
                            .then(() => {
                            logger.info(`Successfully uploaded to ${config.index}`);
                            resolve(guid);
                        })
                            .catch((resolvedError) => {
                            throw new Error(resolvedError);
                        });
                    }
                    else {
                        logger.error(`Invalid Index: ${config.index}`);
                        throw new Error(`Invalid Index: ${config.index}`);
                    }
                }
            });
            return guid;
        });
    }
}
exports.FromHDFToSplunkMapper = FromHDFToSplunkMapper;
//# sourceMappingURL=reverse-splunk-mapper.js.map