"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FromHDFToHTMLMapper = void 0;
const js_1 = require("@mdi/js");
const axios_1 = __importDefault(require("axios"));
const inspecjs_1 = require("inspecjs");
const _ = __importStar(require("lodash"));
const mustache_1 = __importDefault(require("mustache"));
const compliance_1 = require("../../utils/compliance");
var FileExportTypes;
(function (FileExportTypes) {
    FileExportTypes["Executive"] = "Executive";
    FileExportTypes["Manager"] = "Manager";
    FileExportTypes["Administrator"] = "Administrator";
})(FileExportTypes || (FileExportTypes = {}));
const ILLEGAL_CHARACTER_SET = [['\\.', '___PERIOD___']];
class FromHDFToHTMLMapper {
    constructor(files, exportType) {
        this.iconHTMLStore = {
            circleCheck: this.iconDataToSVG(js_1.mdiCheckCircle, 'rgb(76, 176, 79)'),
            circleCross: this.iconDataToSVG(js_1.mdiCloseCircle, 'rgb(243, 67, 53)'),
            circleMinus: this.iconDataToSVG(js_1.mdiMinusCircle, 'rgb(3, 169, 244)'),
            circleAlert: this.iconDataToSVG(js_1.mdiAlertCircle, 'rgb(254, 153, 0)'),
            triangleAlert: this.iconDataToSVG(js_1.mdiAlert, 'rgb(121, 134, 203)'),
            squareEqual: this.iconDataToSVG(js_1.mdiEqualBox, 'black'),
            circleNone: this.iconDataToSVG(js_1.mdiCircle, 'rgb(3, 169, 244)'),
            circleLow: this.iconDataToSVG(js_1.mdiCircle, 'rgb(255, 235, 59)'),
            circleMedium: this.iconDataToSVG(js_1.mdiCircle, 'rgb(255, 152, 0)'),
            circleHigh: this.iconDataToSVG(js_1.mdiCircle, 'rgb(255, 87, 34)'),
            circleCritical: this.iconDataToSVG(js_1.mdiCircle, 'rgb(244, 67, 54)'),
            circleWhite: this.iconDataToSVG(js_1.mdiCircle, 'rgb(0, 0, 0)')
        };
        this.outputData = {
            tailwindStyles: '',
            tailwindElements: '',
            statistics: {
                passed: 0,
                failed: 0,
                notApplicable: 0,
                notReviewed: 0,
                profileError: 0,
                totalResults: 0,
                passedTests: 0,
                passingTestsFailedResult: 0,
                failedTests: 0,
                totalTests: 0
            },
            severity: {
                none: 0,
                low: 0,
                medium: 0,
                high: 0,
                critical: 0
            },
            compliance: {
                level: '',
                color: ''
            },
            files: [],
            resultSets: [],
            showResultSets: false,
            showCode: false,
            exportType: '',
            icons: {
                circleCheck: this.iconHTMLStore.circleCheck,
                circleCross: this.iconHTMLStore.circleCross,
                circleMinus: this.iconHTMLStore.circleMinus,
                circleAlert: this.iconHTMLStore.circleAlert,
                triangleAlert: this.iconHTMLStore.triangleAlert,
                squareEqual: this.iconHTMLStore.squareEqual,
                circleNone: this.iconHTMLStore.circleNone,
                circleLow: this.iconHTMLStore.circleLow,
                circleMedium: this.iconHTMLStore.circleMedium,
                circleHigh: this.iconHTMLStore.circleHigh,
                circleCritical: this.iconHTMLStore.circleCritical
            }
        };
        switch (exportType) {
            case FileExportTypes.Executive:
                this.outputData.showResultSets = false;
                this.outputData.showCode = false;
                break;
            case FileExportTypes.Manager:
                this.outputData.showResultSets = true;
                this.outputData.showCode = false;
                break;
            case FileExportTypes.Administrator:
                this.outputData.showResultSets = true;
                this.outputData.showCode = true;
        }
        this.outputData.files = [];
        this.outputData.resultSets = [];
        for (const file of files) {
            if (_.isString(file.data)) {
                const contextualizedFile = (0, inspecjs_1.convertFileContextual)(file.data);
                if (!(0, inspecjs_1.isContextualizedEvaluation)(contextualizedFile)) {
                    throw new Error('Input string was not an HDF ExecJSON');
                }
                file.data = contextualizedFile;
            }
            this.addFiledata({ data: file.data, fileName: file.fileName, fileID: file.fileID }, exportType);
        }
    }
    addFiledata(file, exportType) {
        this.outputData.files.push({
            filename: file.fileName,
            toolVersion: _.get(file.data, 'data.version'),
            platform: _.get(file.data, 'data.platform.name'),
            duration: _.get(file.data, 'data.statistics.duration')
        });
        this.outputData.exportType = exportType;
        const allResultLevels = [];
        file.data.contains.map((profile) => {
            profile.contains.map((result) => {
                allResultLevels.push(result);
            });
        });
        this.addProfileDetails(allResultLevels);
        this.outputData.resultSets.push({
            filename: file.fileName,
            fileID: file.fileID,
            results: allResultLevels.map((result) => this.addResultDetails(result, allResultLevels.filter((searchingResult) => searchingResult.data.id === result.data.id)))
        });
    }
    addProfileDetails(results) {
        let passed = 0;
        let failed = 0;
        let notApplicable = 0;
        let notReviewed = 0;
        let profileError = 0;
        let none = 0;
        let low = 0;
        let medium = 0;
        let high = 0;
        let critical = 0;
        let passedTests = 0;
        let failedTests = 0;
        let passingTestsFailedResult = 0;
        for (const result of results) {
            switch (result.root.hdf.status) {
                case 'Passed':
                    passed++;
                    passedTests += (result.root.hdf.segments || []).length;
                    break;
                case 'Failed':
                    failed++;
                    passingTestsFailedResult += (result.root.hdf.segments || []).filter((subStatus) => subStatus.status === 'passed').length;
                    failedTests += (result.root.hdf.segments || []).filter((subStatus) => subStatus.status === 'failed').length;
                    break;
                case 'Not Applicable':
                    notApplicable++;
                    break;
                case 'Not Reviewed':
                    notReviewed++;
                    break;
                case 'Profile Error':
                    profileError++;
            }
            switch (result.root.hdf.severity) {
                case 'none':
                    none++;
                    break;
                case 'low':
                    low++;
                    break;
                case 'medium':
                    medium++;
                    break;
                case 'high':
                    high++;
                    break;
                case 'critical':
                    critical++;
            }
        }
        this.outputData.statistics = {
            passed: this.outputData.statistics.passed + passed,
            failed: this.outputData.statistics.failed + failed,
            notApplicable: this.outputData.statistics.notApplicable + notApplicable,
            notReviewed: this.outputData.statistics.notReviewed + notReviewed,
            profileError: this.outputData.statistics.profileError + profileError,
            totalResults: this.outputData.statistics.totalResults + results.length,
            passedTests: this.outputData.statistics.passedTests + passedTests,
            passingTestsFailedResult: this.outputData.statistics.passingTestsFailedResult +
                passingTestsFailedResult,
            failedTests: this.outputData.statistics.failedTests + failedTests,
            totalTests: this.outputData.statistics.totalTests +
                passingTestsFailedResult +
                failedTests
        };
        this.outputData.severity = {
            none: this.outputData.severity.none + none,
            low: this.outputData.severity.low + low,
            medium: this.outputData.severity.medium + medium,
            high: this.outputData.severity.high + high,
            critical: this.outputData.severity.critical + critical
        };
        this.outputData.compliance.level = '0.00%';
        this.outputData.compliance.color = 'low';
        if (this.outputData.statistics.totalResults > 0) {
            const complianceLevel = (0, compliance_1.formatCompliance)((this.outputData.statistics.passed /
                (this.outputData.statistics.totalResults -
                    this.outputData.statistics.notApplicable)) *
                100);
            this.outputData.compliance.level = complianceLevel;
            this.outputData.compliance.color = (0, compliance_1.translateCompliance)(complianceLevel);
        }
    }
    addResultDetails(result, resultLevels) {
        let statusColor;
        switch (result.root.hdf.status) {
            case 'Passed':
                statusColor = this.iconHTMLStore.circleCheck;
                break;
            case 'Failed':
                statusColor = this.iconHTMLStore.circleCross;
                break;
            case 'Not Applicable':
                statusColor = this.iconHTMLStore.circleMinus;
                break;
            case 'Not Reviewed':
                statusColor = this.iconHTMLStore.circleAlert;
                break;
            case 'Profile Error':
                statusColor = this.iconHTMLStore.triangleAlert;
                break;
            default:
                statusColor = this.iconHTMLStore.circleWhite;
        }
        const severity = _.capitalize(result.root.hdf.severity);
        let severityColor;
        switch (result.root.hdf.severity) {
            case 'none':
                severityColor = this.iconHTMLStore.circleNone;
                break;
            case 'low':
                severityColor = this.iconHTMLStore.circleLow;
                break;
            case 'medium':
                severityColor = this.iconHTMLStore.circleMedium;
                break;
            case 'high':
                severityColor = this.iconHTMLStore.circleHigh;
                break;
            case 'critical':
                severityColor = this.iconHTMLStore.circleCritical;
                break;
            default:
                severityColor = this.iconHTMLStore.circleWhite;
        }
        const allControls = _.filter([result.hdf.rawNistTags, result.hdf.wraps.tags.cci], Boolean).flat();
        const filteredControls = allControls
            .map((control) => (control === 'unmapped' ? 'UM-1' : control))
            .filter((control) => control !== 'Rev_4');
        return {
            ..._.set(result, 'hdf.segments', [].concat.apply([], resultLevels.map((resultLevel) => resultLevel.hdf.segments || []))),
            full_code: result.full_code,
            details: [
                {
                    name: 'Control',
                    value: result.data.id
                },
                {
                    name: 'Title',
                    value: result.data.title
                },
                {
                    name: 'Caveat',
                    value: result.hdf.descriptions.caveat
                },
                {
                    name: 'Desc',
                    value: result.data.desc
                },
                {
                    name: 'Rationale',
                    value: result.hdf.descriptions.rationale
                },
                {
                    name: 'Justification',
                    value: result.hdf.descriptions.justification
                },
                {
                    name: 'Severity',
                    value: result.root.hdf.severity
                },
                {
                    name: 'Impact',
                    value: result.data.impact
                },
                {
                    name: 'Nist Controls',
                    value: result.hdf.rawNistTags.join(', ')
                },
                {
                    name: 'Check Text',
                    value: result.hdf.descriptions.check || result.data.tags.check
                },
                {
                    name: 'Fix Text',
                    value: result.hdf.descriptions.fix || result.data.tags.fix
                }
            ].filter((v) => v.value),
            resultID: this.replaceIllegalCharacters(result.hdf.wraps.id),
            resultStatus: {
                status: result.root.hdf.status,
                icon: statusColor
            },
            resultSeverity: {
                severity: severity,
                icon: severityColor
            },
            controlTags: filteredControls
        };
    }
    iconDataToSVG(iconData, fill, widthPx = 24, heightPx = 24, description) {
        let imgLabel;
        if (description) {
            imgLabel = `title="${description}" aria-label="${description}"`;
        }
        else {
            imgLabel = `aria-hidden="true"`;
        }
        return `<svg style="width:${widthPx}px; height:${heightPx}px" viewBox="0 0 ${widthPx} ${heightPx}" role="img" ${imgLabel}><path fill="${fill}" d="${iconData}"/></svg>`;
    }
    replaceIllegalCharacters(text) {
        for (const illegalCharacter of ILLEGAL_CHARACTER_SET) {
            text = text.replace(new RegExp(`${illegalCharacter[0]}`, 'g'), illegalCharacter[1]);
        }
        return text;
    }
    async toHTML(path) {
        const templateRequest = axios_1.default.get(`${path}template.html`);
        const tailwindStylesRequest = axios_1.default.get(`${path}style.css`);
        const tailwindElementsRequest = axios_1.default.get(`${path}tw-elements.min.js`);
        const responses = await axios_1.default.all([
            templateRequest,
            tailwindStylesRequest,
            tailwindElementsRequest
        ]);
        const template = responses[0].data;
        this.outputData.tailwindStyles = responses[1].data;
        this.outputData.tailwindElements = responses[2].data.replace('//# sourceMappingURL=tw-elements.umd.min.js.map', '');
        return mustache_1.default.render(template, this.outputData);
    }
}
exports.FromHDFToHTMLMapper = FromHDFToHTMLMapper;
//# sourceMappingURL=reverse-html-mapper.js.map