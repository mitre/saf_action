"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupControlStatus = exports.setupDetailsAssume = exports.setupResourcesID2 = exports.setupResourcesID = exports.setupProdFieldCheck = exports.setupRemRec = exports.getFixForControl = exports.setupFindingType = exports.setupSevOriginal = exports.setupSevLabel = exports.setupDescr = exports.setupTitle = exports.setupGeneratorId = exports.setupUpdated = exports.setupRegion = exports.setupCreated = exports.setupAwsAcct = exports.setupProductARN = exports.setupId = exports.createCode = exports.createNote = exports.getAllLayers = exports.cleanText = exports.createAssumeRolePolicyDocument = exports.createDescription = exports.statusCount = exports.createProfileInfoFinding = exports.getRunTime = void 0;
const crypto_1 = require("crypto");
const inspecjs_1 = require("inspecjs");
const _ = __importStar(require("lodash"));
const moment_1 = __importDefault(require("moment"));
const package_json_1 = require("../../../package.json");
const global_1 = require("../../utils/global");
const reverse_asff_mapper_1 = require("./reverse-asff-mapper");
function getRunTime(hdf) {
    let time = new Date().toISOString();
    hdf.profiles.forEach((profile) => {
        if (profile.controls[0] &&
            profile.controls[0].results.length &&
            profile.controls[0].results[0].start_time) {
            try {
                time = new Date(profile.controls[0].results[0].start_time).toISOString();
            }
            catch {
                time = new Date().toISOString();
            }
        }
    });
    return time;
}
exports.getRunTime = getRunTime;
function filter_overlays(controls) {
    const idHash = {};
    controls.forEach((c) => {
        const id = c.hdf.wraps.id;
        const old = idHash[id];
        if (old) {
            const newSignificant = c.hdf.status_list && c.hdf.status_list.length > 0;
            if (newSignificant) {
                idHash[id] = c;
            }
        }
        else {
            idHash[id] = c;
        }
    });
    return Array.from(Object.values(idHash));
}
function createProfileInfoFinding(hdf, options) {
    const runTime = getRunTime(hdf);
    const inspecJSJson = (0, inspecjs_1.convertFile)(JSON.stringify(hdf));
    const contextualizedEvaluation = (0, inspecjs_1.contextualizeEvaluation)(inspecJSJson['1_0_ExecJson']);
    const counts = statusCount(contextualizedEvaluation);
    const updatedAt = new Date();
    updatedAt.setMilliseconds(updatedAt.getMilliseconds() +
        (contextualizedEvaluation.contains[0].contains.length || 0));
    const profileInfo = {
        SchemaVersion: '2018-10-08',
        Id: `${options.target}/${hdf.profiles[0].name}`,
        ProductArn: `arn:aws:securityhub:${options.region}:${options.awsAccountId}:product/${options.awsAccountId}/default`,
        GeneratorId: `arn:aws:securityhub:us-east-2:${options.awsAccountId}:ruleset/set/${hdf.profiles[0].name}`,
        AwsAccountId: options.awsAccountId,
        CreatedAt: runTime,
        UpdatedAt: updatedAt,
        Title: `${options.target} | ${hdf.profiles[0].name} | ${(0, moment_1.default)().format('YYYY-MM-DD hh:mm:ss [GMT]ZZ')}`,
        Description: createDescription(counts),
        Severity: {
            Label: 'INFORMATIONAL'
        },
        FindingProviderFields: {
            Severity: {
                Label: 'INFORMATIONAL'
            },
            Types: createProfileInfoFindingFields(hdf, options)
        },
        Resources: [
            {
                Type: 'AwsAccount',
                Id: `AWS::::Account:${options.awsAccountId}`,
                Partition: 'aws',
                Region: options.region
            }
        ]
    };
    return profileInfo;
}
exports.createProfileInfoFinding = createProfileInfoFinding;
function statusCount(evaluation) {
    let controls = [];
    evaluation.contains.forEach((p) => controls.push(...p.contains));
    controls = filter_overlays(controls);
    const statusCounts = {
        Passed: 0,
        PassedTests: 0,
        PassingTestsFailedControl: 0,
        Failed: 0,
        FailedTests: 0,
        NotApplicable: 0,
        NotReviewed: 0
    };
    controls.forEach((control) => {
        if (control.hdf.status === 'Passed') {
            statusCounts.Passed += 1;
            statusCounts.PassedTests += (control.hdf.segments || []).length;
        }
        else if (control.hdf.status === 'Failed') {
            statusCounts.PassingTestsFailedControl += (control.hdf.segments || []).filter((s) => s.status === 'passed').length;
            statusCounts.FailedTests += (control.hdf.segments || []).filter((s) => s.status === 'failed').length;
            statusCounts.Failed += 1;
        }
        else if (control.hdf.status === 'Not Applicable') {
            statusCounts.NotApplicable += 1;
        }
        else if (control.hdf.status === 'Not Reviewed') {
            statusCounts.NotReviewed += 1;
        }
    });
    return statusCounts;
}
exports.statusCount = statusCount;
function createDescription(counts) {
    return `Result Set Status Summary -- Passed: ${counts.Passed} (${counts.PassedTests} individual checks passed) --- Failed: ${counts.Failed} (${counts.PassingTestsFailedControl} individual checks failed out of ${counts.PassingTestsFailedControl + counts.FailedTests} total checks) --- Not Applicable: ${counts.NotApplicable} (System exception or absent component) --- Not Reviewed: ${counts.NotReviewed} (Can only be tested manually at this time)`;
}
exports.createDescription = createDescription;
function createAssumeRolePolicyDocument(layersOfControl, segment) {
    const segmentOverview = createNote(segment);
    const code = layersOfControl.map((layer) => createCode(layer)).join('\n\n');
    return `${code}\n\n${segmentOverview}`;
}
exports.createAssumeRolePolicyDocument = createAssumeRolePolicyDocument;
function cleanText(text) {
    if (text) {
        return text.replace(/  +/g, ' ');
    }
    else {
        return undefined;
    }
}
exports.cleanText = cleanText;
function getAllLayers(hdf, knownControl) {
    if (hdf.profiles.length === 1) {
        return [
            {
                ...knownControl,
                profileInfo: {
                    ..._.omit(hdf.profiles[0], 'controls')
                }
            }
        ];
    }
    else {
        const foundControls = [];
        hdf.profiles.forEach((profile) => {
            profile.controls.forEach((control) => {
                if (control.id === knownControl.id) {
                    foundControls.push({
                        ...control,
                        profileInfo: { ..._.omit(profile, 'controls') }
                    });
                }
            });
        });
        return foundControls;
    }
}
exports.getAllLayers = getAllLayers;
function createNote(segment) {
    if (segment.message) {
        return `Test Description: ${segment.code_desc} --- Test Result: ${segment.message}`;
    }
    else if (segment.skip_message) {
        return `Test Description: ${segment.code_desc} --- Skip Message: ${segment.skip_message}`;
    }
    else {
        return `Test Description: ${segment.code_desc}`;
    }
}
exports.createNote = createNote;
function cleanObjectValues(value) {
    if (Array.isArray(value)) {
        return value.length < 0;
    }
    return !Boolean(value);
}
function createCode(control) {
    var _a, _b;
    const noCodeValue = (_.get(control, 'profileInfo.depends') || [])
        .length > 0
        ? ''
        : JSON.stringify(_.omitBy(_.omit(control, ['results', 'profileInfo']), cleanObjectValues));
    if (!control.code && noCodeValue === '') {
        return '';
    }
    return `=========================================================\n# Profile name: ${(_a = control.profileInfo) === null || _a === void 0 ? void 0 : _a.name}\n=========================================================\n\n${control.code ? (_b = control.code) === null || _b === void 0 ? void 0 : _b.replace(/\\\"/g, '"') : noCodeValue}`;
}
exports.createCode = createCode;
function setupId(control, context) {
    const target = context === null || context === void 0 ? void 0 : context.ioptions.target;
    const name = context === null || context === void 0 ? void 0 : context.data.profiles[0].name;
    return `${target}/${name}/${control.id}/finding/${(0, crypto_1.createHash)('sha256')
        .update(control.id + control.result.code_desc)
        .digest('hex')}`;
}
exports.setupId = setupId;
function setupProductARN(_val, context) {
    return `arn:aws:securityhub:${context === null || context === void 0 ? void 0 : context.ioptions.region}:${context === null || context === void 0 ? void 0 : context.ioptions.awsAccountId}:product/${context === null || context === void 0 ? void 0 : context.ioptions.awsAccountId}/default`;
}
exports.setupProductARN = setupProductARN;
function setupAwsAcct(_val, context) {
    return context === null || context === void 0 ? void 0 : context.ioptions.awsAccountId;
}
exports.setupAwsAcct = setupAwsAcct;
function setupCreated(control) {
    try {
        return (new Date(control.result.start_time).toISOString() ||
            new Date().toISOString());
    }
    catch {
        return new Date().toISOString();
    }
}
exports.setupCreated = setupCreated;
function setupRegion(_val, context) {
    return context === null || context === void 0 ? void 0 : context.ioptions.region;
}
exports.setupRegion = setupRegion;
function setupUpdated(_control, context) {
    const time = new Date();
    time.setMilliseconds(time.getMilliseconds() + ((context === null || context === void 0 ? void 0 : context.index) || 0));
    return time.toISOString();
}
exports.setupUpdated = setupUpdated;
function setupGeneratorId(control, context) {
    return `arn:aws:securityhub:${context === null || context === void 0 ? void 0 : context.ioptions.region}:${context === null || context === void 0 ? void 0 : context.ioptions.awsAccountId}:ruleset/set/${context === null || context === void 0 ? void 0 : context.data.profiles[0].name}/rule/${control.id}`;
}
exports.setupGeneratorId = setupGeneratorId;
function setupTitle(control) {
    const nistTags = control.tags.nist ? `[${control.tags.nist.join(', ')}]` : '';
    return _.truncate(`${control.id} | ${nistTags} | ${cleanText(control.title)}`, { length: 256 });
}
exports.setupTitle = setupTitle;
function setupDescr(control) {
    const checkText = (0, global_1.getDescription)(control.descriptions || [], 'check') ||
        control.tags.check ||
        'Check not available';
    const currentVal = _.truncate(cleanText(`${control.desc} -- Check Text: ${checkText}`), { length: 1024, omission: '[SEE FULL TEXT IN AssumeRolePolicyDocument]' });
    const caveat = (0, global_1.getDescription)(control.descriptions || [], 'caveat');
    if (caveat) {
        return _.truncate(`Caveat: ${cleanText(caveat)} --- Description: ${currentVal}`, { length: 1024, omission: '' });
    }
    return currentVal;
}
exports.setupDescr = setupDescr;
function setupSevLabel(control, context) {
    return (context === null || context === void 0 ? void 0 : context.impactMapping.get(control.impact)) || 'INFORMATIONAL';
}
exports.setupSevLabel = setupSevLabel;
function setupSevOriginal(control) {
    return `${control.impact}`;
}
exports.setupSevOriginal = setupSevOriginal;
function createControlMetadata(control) {
    const types = [
        `Control/ID/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(control.id)}`,
        `Control/Impact/${control.impact}`
    ];
    if (control.title) {
        types.push(`Control/Title/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(control.title)}`);
    }
    if (control.desc) {
        types.push(`Control/Desc/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(control.desc)}`);
    }
    if (control.waiver_data && Object.keys(control.waiver_data).length > 0) {
        types.push(`Control/Waiver_Data/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(JSON.stringify(control.waiver_data))}`);
    }
    if (control.attestation_data) {
        types.push(`Control/Attestation_Data/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(JSON.stringify(control.attestation_data))}`);
    }
    if (control.refs && control.refs.length > 0) {
        types.push(`Control/Refs/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(JSON.stringify(control.refs))}`);
    }
    if (control.source_location &&
        Object.keys(control.source_location).length > 0) {
        types.push(`Control/Source_Location/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(JSON.stringify(control.source_location))}`);
    }
    return types;
}
function getFilename(options) {
    var _a;
    const slashSplit = options === null || options === void 0 ? void 0 : options.input.split('\\')[(options === null || options === void 0 ? void 0 : options.input.split('\\').length) - 1];
    return (_a = slashSplit === null || slashSplit === void 0 ? void 0 : slashSplit.split('/')[slashSplit.split('/').length - 1]) !== null && _a !== void 0 ? _a : '';
}
function createProfileInfoFindingFields(hdf, options) {
    const typesArr = [
        `MITRE/SAF/${package_json_1.version}-hdf2asff`,
        `File/Input/${getFilename(options)}`
    ];
    const executionTargets = ['platform', 'statistics', 'version'];
    executionTargets.forEach((target) => {
        const value = _.get(hdf, target);
        if (_.isString(value) && value.trim()) {
            typesArr.push(`Execution/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(target)}/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(value)}`);
        }
        else {
            typesArr.push(`Execution/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(target)}/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(JSON.stringify(value))}`);
        }
    });
    hdf.profiles.forEach((profile) => {
        const targets = [
            'version',
            'sha256',
            'maintainer',
            'summary',
            'license',
            'copyright',
            'copyright_email',
            'name',
            'title',
            'depends',
            'supports',
            'attributes',
            'description',
            'inspec_version',
            'parent_profile',
            'skip_message',
            'status',
            'status_message'
        ];
        targets.forEach((target) => {
            const value = _.get(profile, target);
            if (typeof value === 'string' && value) {
                typesArr.push(`${(0, reverse_asff_mapper_1.escapeForwardSlashes)(profile.name)}/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(target)}/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(value)}`);
            }
            else if (typeof value === 'object') {
                typesArr.push(`${(0, reverse_asff_mapper_1.escapeForwardSlashes)(profile.name)}/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(target)}/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(JSON.stringify(value))}`);
            }
        });
    });
    const passthrough = _.get(hdf, 'passthrough');
    if (_.isString(passthrough) && passthrough.trim()) {
        typesArr.push(`Execution/passthrough/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(passthrough)}`);
    }
    else if (passthrough !== undefined) {
        typesArr.push(`Execution/passthrough/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(JSON.stringify(passthrough))}`);
    }
    return typesArr;
}
function createSegmentInfo(segment) {
    const typesArr = [];
    const targets = [
        'backtrace',
        'exception',
        'code_desc',
        'message',
        'resource',
        'run_time',
        'start_time',
        'skip_message',
        'status'
    ];
    targets.forEach((target) => {
        if (_.has(segment, target) && _.get(segment, target) !== undefined) {
            if (_.get(segment, target) === '') {
                typesArr.push(`Segment/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(target)}/''`);
            }
            else {
                typesArr.push(`Segment/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(target)}/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(_.get(segment, target))}`);
            }
        }
    });
    return typesArr;
}
function createTagInfo(control) {
    const typesArr = [];
    for (const tag in control.tags) {
        typesArr.push(`Tags/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(tag)}/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(JSON.stringify(control.tags[tag]))}`);
    }
    return typesArr;
}
function createDescriptionInfo(control) {
    var _a;
    const typesArr = [];
    if (Array.isArray(control.descriptions)) {
        (_a = control.descriptions) === null || _a === void 0 ? void 0 : _a.forEach((description) => {
            if (description.data && cleanText(description.data)) {
                typesArr.push(`Descriptions/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(description.label)}/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(cleanText(description.data))}`);
            }
        });
    }
    else {
        Object.entries(control.descriptions || {}).forEach(([key, value]) => {
            if (value && cleanText(value)) {
                typesArr.push(`Descriptions/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(key)}/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(cleanText(value))}`);
            }
        });
    }
    return typesArr;
}
function setupFindingType(control, context) {
    const typesArr = [
        `MITRE/SAF/${package_json_1.version}-hdf2asff`,
        `File/Input/${getFilename(context === null || context === void 0 ? void 0 : context.ioptions)}`
    ];
    typesArr.push(...createControlMetadata(control));
    typesArr.push(...createSegmentInfo(control.result));
    typesArr.push(...createTagInfo(control));
    const nistTagIndex = typesArr.findIndex((typeString) => typeString.startsWith('Tags/nist/'));
    const tagsIndex = typesArr.findIndex((typeString) => typeString.startsWith('Tags/'));
    if (nistTagIndex !== -1) {
        typesArr.splice(tagsIndex, 0, typesArr.splice(nistTagIndex, 1)[0]);
    }
    typesArr.splice(tagsIndex === -1 ? typesArr.length : tagsIndex + 1, 0, ...createDescriptionInfo(control));
    const desc = typesArr.splice(typesArr.findIndex((typeString) => typeString.startsWith('Control/Desc/')), 1)[0];
    const code = `Control/Code/${(0, reverse_asff_mapper_1.escapeForwardSlashes)(control.layersOfControl
        .map((layer) => createCode(layer))
        .join('\n\n'))}`;
    const codeDesc = typesArr.splice(typesArr.findIndex((typeString) => typeString.startsWith('Segment/code_desc/')), 1)[0];
    typesArr.push(..._.compact([desc, code, codeDesc]));
    return typesArr;
}
exports.setupFindingType = setupFindingType;
function getFixForControl(control) {
    return ((0, global_1.getDescription)(control.descriptions || [], 'fix') ||
        control.tags.fix ||
        'Fix not available');
}
exports.getFixForControl = getFixForControl;
function setupRemRec(control) {
    return _.truncate(cleanText(`${createNote(control.result)} --- Fix: ${getFixForControl(control)}`), { length: 512, omission: '... [SEE FULL TEXT IN AssumeRolePolicyDocument]' });
}
exports.setupRemRec = setupRemRec;
function setupProdFieldCheck(control) {
    const checkText = (0, global_1.getDescription)(control.descriptions || [], 'check') ||
        control.tags.check ||
        'Check not available';
    return _.truncate(checkText, { length: 2048, omission: '' });
}
exports.setupProdFieldCheck = setupProdFieldCheck;
function setupResourcesID(_val, context) {
    return `AWS::::Account:${context === null || context === void 0 ? void 0 : context.ioptions.awsAccountId}`;
}
exports.setupResourcesID = setupResourcesID;
function setupResourcesID2(control) {
    return `${control.id} Validation Code`;
}
exports.setupResourcesID2 = setupResourcesID2;
function setupDetailsAssume(control) {
    return createAssumeRolePolicyDocument(control.layersOfControl, control.result);
}
exports.setupDetailsAssume = setupDetailsAssume;
function setupControlStatus(control) {
    if (control.results.some((result) => 'backtrace' in result)) {
        return 'NOT_AVAILABLE';
    }
    const status = control.result.status === 'skipped'
        ? 'WARNING'
        : control.result.status === 'passed';
    if (typeof status === 'boolean') {
        return status ? 'PASSED' : 'FAILED';
    }
    return status;
}
exports.setupControlStatus = setupControlStatus;
//# sourceMappingURL=transformers.js.map