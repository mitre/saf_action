import { ExecJSON } from 'inspecjs';
import { MappedTransform } from '../../base-converter';
import { FromHdfBaseConverter } from '../reverse-base-converter';
import { IExecJSONASFF, IFindingASFF, IOptions } from './asff-types';
export declare const TO_ASFF_TYPES_SLASH_REPLACEMENT = "{{{SLASH}}}";
export declare function escapeForwardSlashes<T>(s: T): T;
export type SegmentedControl = ExecJSON.Control & {
    result: ExecJSON.ControlResult;
    layersOfControl: (ExecJSON.Control & {
        fix?: string;
        profileInfo?: Record<string, unknown>;
    })[];
};
export interface ILookupPathASFF {
    path?: string;
    transformer?: (value: SegmentedControl, context?: FromHdfToAsffMapper) => unknown;
    arrayTransformer?: (value: unknown[], file: ExecJSON.Execution) => unknown[];
    key?: string;
    passParent?: boolean;
}
export declare class FromHdfToAsffMapper extends FromHdfBaseConverter {
    mappings: () => MappedTransform<IExecJSONASFF, ILookupPathASFF>;
    contextProfiles: any;
    counts: any;
    ioptions: IOptions;
    index?: number;
    impactMapping: Map<number, string>;
    constructor(hdfObj: ExecJSON.Execution, options: IOptions | undefined);
    defaultOptions(): IOptions;
    setMappings(customMappings: MappedTransform<IExecJSONASFF, ILookupPathASFF>): void;
    controlsToSegments(): SegmentedControl[];
    restrictionAttributesLessThan32KiB(finding: IFindingASFF): IFindingASFF;
    restrictionFindingLessThan240KB(profileInfoFindingId: string, finding: IFindingASFF, numRemoved: number, numTruncated: number): [IFindingASFF | undefined, number, number];
    restrictionTypesArrayLengthLessThan50(profileInfoFindingId: string, finding: IFindingASFF, numTruncated: number): [IFindingASFF, number];
    restrictionTypesArrayMustBeUnique(profileInfoFindingId: string, finding: IFindingASFF, numRemoved: number): [IFindingASFF | undefined, number];
    restrictToSchemaSizes(resList: IFindingASFF[]): IFindingASFF[];
    toAsff(): IFindingASFF[];
}
