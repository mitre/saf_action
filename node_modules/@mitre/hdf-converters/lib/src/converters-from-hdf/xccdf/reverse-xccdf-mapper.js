"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FromHDFToXCCDFMapper = void 0;
const _ = __importStar(require("lodash"));
const moment_1 = __importDefault(require("moment"));
const mustache_1 = __importDefault(require("mustache"));
const package_json_1 = require("../../../package.json");
const global_1 = require("../../utils/global");
const DATE_FORMAT = 'YYYY-MM-DD';
const TESTING_DATE_OVERRIDE = '1970-01-01';
const TESTING_DATETIME_OVERRIDE = '2022-05-06T21:46:47.939Z';
function arrayifyObjectDescriptions(descriptions) {
    if (!descriptions) {
        return [];
    }
    if (Array.isArray(descriptions)) {
        return descriptions;
    }
    return Object.entries(descriptions).map(([key, value]) => {
        return {
            label: key,
            data: value
        };
    });
}
function getXCCDFResult(control) {
    if (control.results.some((result) => result.backtrace)) {
        return 'error';
    }
    if (control.results.some((result) => !result.status)) {
        return 'unknown';
    }
    if (control.results.every((result) => result.status === 'passed')) {
        return 'pass';
    }
    if (control.results.every((result) => result.status === 'skipped')) {
        return 'notchecked';
    }
    if (control.results.some((result) => result.status === 'failed')) {
        return 'fail';
    }
    return 'unknown';
}
function getXCCDFResultMessageSeverity(segments) {
    if (segments.some((result) => result.backtrace)) {
        return 'medium';
    }
    return 'info';
}
function toMessageLine(segment) {
    switch (segment.status) {
        case 'skipped':
            return `SKIPPED -- ${segment.skip_message}\n`;
        case 'failed':
            return `FAILED -- Test: ${segment.code_desc}\nMessage: ${segment.message}\n`;
        case 'passed':
            return `PASSED -- ${segment.code_desc}"`;
        case 'error':
            return `ERROR -- Test: ${segment.code_desc}\nMessage: ${segment.message}`;
        default:
            return `Exception: ${segment.exception}`;
    }
}
function getMessages(segments) {
    return segments.map(toMessageLine).join('\n\n');
}
class FromHDFToXCCDFMapper {
    constructor(data, xccdfTemplate, dateOverride = false) {
        this.data = JSON.parse(data);
        this.xccdfTemplate = xccdfTemplate;
        this.dateOverride = dateOverride;
    }
    getSeverity(control) {
        if (control.impact < 0.1) {
            return 'info';
        }
        else if (control.impact < 0.4) {
            return 'low';
        }
        else if (control.impact < 0.7) {
            return 'medium';
        }
        else {
            return 'high';
        }
    }
    getControlInfo(control) {
        const knownDescriptions = [
            'default',
            'check',
            'fix',
            'gtitle',
            'gid',
            'rid',
            'stig_id',
            'cci',
            'satisfies',
            'fix_id',
            'documentable'
        ];
        return {
            groupId: 'xccdf_hdf_group_' +
                control.id
                    .replace(/_/g, '-')
                    .replace(/[^\w-.]/g, '_'),
            id: 'xccdf_hdf_rule_' +
                (control.tags.rid ||
                    control.id.replace(/_/g, '-').replace(/[^\w-.]/g, '_') + '_rule'),
            version: control.tags.stig_id || '',
            gtitle: control.tags.gtitle || control.title,
            title: control.title || '',
            severity: this.getSeverity(control),
            description: control.desc +
                (control.tags.satisfies
                    ? '\n\nSatisfies: ' + control.tags.satisfies.join(', ')
                    : '') ||
                (0, global_1.getDescription)(control.descriptions || [], 'default') ||
                '',
            documentable: control.tags.documentable || false,
            descriptions: arrayifyObjectDescriptions(control.descriptions).filter((description) => !knownDescriptions.includes(description.label)),
            waiver: control.waiver_data ? JSON.stringify(control.waiver_data) : '',
            checkContent: (0, global_1.getDescription)(control.descriptions || [], 'check') ||
                control.tags.check ||
                '',
            tags: Object.entries(control.tags)
                .filter(([key]) => !knownDescriptions.includes(key))
                .map(([key, value]) => `${key}: ${value}`),
            code: control.code || '',
            fixid: control.tags.fix_id,
            fix: (0, global_1.getDescription)(control.descriptions || [], 'fix') ||
                control.tags.fix ||
                '',
            ccis: control.tags.cci || []
        };
    }
    getExecutionTime(isoTime = false) {
        const results = [];
        this.data.profiles.forEach((profile) => {
            if (profile.controls[0].results) {
                results.push(...profile.controls[0].results);
            }
        });
        for (const result of results) {
            if (typeof result.start_time === 'string') {
                try {
                    const parsedDate = (0, moment_1.default)(result.start_time);
                    if (parsedDate.isValid()) {
                        return isoTime
                            ? (0, moment_1.default)(result.start_time).toISOString()
                            : (0, moment_1.default)(result.start_time, false).format(DATE_FORMAT);
                    }
                }
                catch {
                    return isoTime
                        ? (0, moment_1.default)().toISOString()
                        : (0, moment_1.default)().format(DATE_FORMAT);
                }
            }
        }
        return isoTime ? (0, moment_1.default)().toISOString() : (0, moment_1.default)().format(DATE_FORMAT);
    }
    getControlResultsInfo(control) {
        return {
            idref: 'xccdf_hdf_rule_' +
                (control.tags.rid ||
                    control.id
                        .replace(/_/g, '-')
                        .replace(/[^\w-.]/g, '_') + '_rule'),
            result: getXCCDFResult(control),
            message: getMessages(control.results),
            messageType: getXCCDFResultMessageSeverity(control.results),
            code: control.code || ''
        };
    }
    toXCCDF() {
        const passthrough = _.get(this.data, 'passthrough');
        let passthroughString = '';
        if (typeof passthrough === 'object') {
            passthroughString = JSON.stringify(passthrough);
        }
        else if (typeof passthrough !== 'undefined') {
            passthroughString = String(passthrough);
        }
        const mappedData = {
            Benchmark: {
                id: 'xccdf_mitre.hdf-converters.xccdf_benchmark_hdf2xccdf',
                title: this.data.profiles[0].title || 'HDF to XCCDF Benchmark',
                date: this.dateOverride
                    ? TESTING_DATE_OVERRIDE
                    : this.getExecutionTime(),
                metadata: {
                    copyright: this.data.profiles[0].copyright || '',
                    maintainer: this.data.profiles[0].maintainer || ''
                },
                passthrough: passthroughString,
                version: package_json_1.version,
                Profile: [],
                Rule: [],
                TestResult: {
                    endTime: this.dateOverride
                        ? TESTING_DATETIME_OVERRIDE
                        : this.getExecutionTime(true),
                    hasAttributes: false,
                    attributes: [],
                    results: []
                }
            }
        };
        this.data.profiles.forEach((profile) => {
            mappedData.Benchmark.Profile.push({
                id: 'xccdf_mitre.hdf-converters_profile_hdf2xccdf_' +
                    (profile.title?.replace(/[^\w-.]/g, '_') || 'profile_missing_title'),
                title: profile.title || '',
                description: profile.description || '',
                select: profile.controls.map((control) => 'xccdf_hdf_rule_' +
                    (control.tags.rid ||
                        control.id.replace(/_/g, '-').replace(/[^\w-.]/g, '_') + '_rule'))
            });
            mappedData.Benchmark.TestResult.attributes.push(...(profile.attributes || []));
            if (mappedData.Benchmark.TestResult.attributes.length > 0) {
                mappedData.Benchmark.TestResult.hasAttributes = true;
            }
            profile.controls.forEach((control) => {
                if (control.results) {
                    mappedData.Benchmark.TestResult.results.push(this.getControlResultsInfo(control));
                }
            });
        });
        this.data.profiles[0].controls.forEach((control) => {
            mappedData.Benchmark.Rule.push(this.getControlInfo(control));
        });
        return mustache_1.default.render(this.xccdfTemplate, mappedData);
    }
}
exports.FromHDFToXCCDFMapper = FromHDFToXCCDFMapper;
//# sourceMappingURL=reverse-xccdf-mapper.js.map