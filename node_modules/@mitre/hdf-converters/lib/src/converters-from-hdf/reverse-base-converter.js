"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FromHdfBaseConverter = void 0;
const _ = __importStar(require("lodash"));
class FromHdfBaseConverter {
    constructor(data, collapseResults = false) {
        this.data = data;
        this.collapseResults = collapseResults;
    }
    setMappings(mappings) {
        this.mappings = mappings;
    }
    convertInternal(file, fields) {
        const result = this.objectMap(fields, (v) => this.evaluate(file, v));
        return result;
    }
    objectMap(obj, fn) {
        return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, fn(v)]));
    }
    evaluate(file, v) {
        const transformer = _.get(v, 'transformer');
        if (Array.isArray(v)) {
            return this.handleArray(file, v);
        }
        if (typeof v === 'string' ||
            typeof v === 'number' ||
            typeof v === 'boolean' ||
            v === undefined ||
            v === null) {
            return v;
        }
        if (typeof transformer === 'function') {
            if (!v.path) {
                if (v.passParent) {
                    return transformer(file, this);
                }
                else {
                    return transformer(file);
                }
            }
            else {
                if (v.passParent) {
                    return transformer(this.handlePath(file, v.path), this);
                }
                else {
                    return transformer(this.handlePath(file, v.path));
                }
            }
        }
        else {
            if (v.path) {
                return this.handlePath(file, v.path);
            }
        }
        return this.convertInternal(file, v);
    }
    handleArray(file, v) {
        const resultingData = [];
        if (v[0] && !v[0].path) {
            const arrayTransformer = v[0].arrayTransformer;
            let output = v.map((element) => this.evaluate(file, element));
            if (arrayTransformer) {
                output = arrayTransformer(output, this.data);
            }
            resultingData.push(...output);
        }
        else if (v[0] && v[0].path) {
            const path = v[0].path;
            const arrayTransformer = v[0].arrayTransformer;
            const transformer = v[0].transformer;
            if (this.hasPath(file, path)) {
                const pathVal = this.handlePath(file, path);
                if (Array.isArray(pathVal)) {
                    v = pathVal.map((element) => this.convertInternal(element, v[0]));
                    if (arrayTransformer) {
                        v = arrayTransformer(v, this.data);
                    }
                    resultingData.push(...v);
                }
                else {
                    if (transformer) {
                        resultingData.push(transformer(this.handlePath(file, path)));
                    }
                    else {
                        resultingData.push(this.handlePath(file, path));
                    }
                }
            }
        }
        const uniqueResults = [];
        resultingData.forEach((result) => {
            if (!uniqueResults.some((uniqueResult) => _.isEqual(result, uniqueResult))) {
                uniqueResults.push(result);
            }
        });
        return uniqueResults;
    }
    handlePath(file, path) {
        if (path.startsWith('$.')) {
            return _.get(this.data, path.slice(2));
        }
        else {
            return _.get(file, path);
        }
    }
    hasPath(file, path) {
        if (path.startsWith('$.')) {
            return _.has(this.data, path.slice(2));
        }
        else {
            return _.has(file, path);
        }
    }
}
exports.FromHdfBaseConverter = FromHdfBaseConverter;
//# sourceMappingURL=reverse-base-converter.js.map