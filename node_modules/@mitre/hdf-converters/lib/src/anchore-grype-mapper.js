"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnchoreGrypeMapper = void 0;
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const IMPACT_MAPPING = new Map([
    ['critical', 0.9],
    ['high', 0.7],
    ['medium', 0.5],
    ['low', 0.3],
    ['negligible', 0.0],
    ['unknown', 0.5]
]);
function skipSeverityNegligibleOrUnknown(controls) {
    if (controls) {
        controls
            .filter((control) => {
            const rating = lodash_1.default.get(control, 'tags.severity', '');
            return rating === 'Negligible' || rating === 'Unknown';
        })
            .map((control) => control.results.map((result) => {
            result.status = inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
            result.skip_message =
                'Manual review required because a Anchore Grype rating severity is set to `negligible` or `unknown`.';
        }));
    }
    return controls;
}
function description(data) {
    const vulnerability = data.vulnerability;
    const relatedVulnerabilities = data.relatedVulnerabilities;
    if (!vulnerability.description && relatedVulnerabilities.length > 0) {
        return relatedVulnerabilities.filter((relatedVulnerability) => relatedVulnerability.id === vulnerability.id)[0].description;
    }
    else if (vulnerability.description) {
        return vulnerability.description;
    }
    return 'no description found';
}
class AnchoreGrypeMapper extends base_converter_1.BaseConverter {
    controlMatches(matchesPath, idTransformer, impactTransformer, resultMessageTransformer) {
        return {
            path: matchesPath,
            key: 'id',
            tags: {
                nist: ['SA-11', 'RA-5'],
                cveid: { path: 'vulnerability.id' },
                severity: { path: 'vulnerability.severity' }
            },
            descriptions: [
                {
                    data: {
                        path: 'vulnerability.fix',
                        transformer: (data) => data.state == 'fixed'
                            ? `vulnerability is ${lodash_1.default.get(data, 'state')} for versions ${lodash_1.default.get(data, 'versions').join(', ')}`
                            : `vulnerability is not known to be fixed in any versions`
                    },
                    label: 'fix'
                },
                {
                    data: {
                        path: 'relatedVulnerabilities',
                        transformer: (data) => `${JSON.stringify(lodash_1.default.get(data, 'cvss'), null, 2)}`
                    },
                    label: 'check'
                }
            ],
            refs: {
                transformer: (data) => {
                    const vuln_urls = lodash_1.default.get(data, 'vulnerability.urls');
                    const relatedVulnerabilities = lodash_1.default.get(data, 'relatedVulnerabilities');
                    let relatedVulnerabilitiesUrls = [];
                    if (relatedVulnerabilities) {
                        relatedVulnerabilitiesUrls = relatedVulnerabilities.map((element) => element.urls);
                    }
                    return vuln_urls.concat(...relatedVulnerabilitiesUrls).map((element) => ({ url: element }));
                }
            },
            source_location: {},
            title: {
                transformer: (data) => `Grype found a vulnerability to ${lodash_1.default.get(data, 'vulnerability.id')} in ${lodash_1.default.get(this.metadata, 'source.target.userInput')}`
            },
            id: {
                transformer: idTransformer
            },
            desc: {
                transformer: description
            },
            impact: {
                path: 'vulnerability.severity',
                transformer: impactTransformer
            },
            code: {
                transformer: (data) => `${JSON.stringify(lodash_1.default.omitBy(lodash_1.default.pick(data, ['vulnerability', 'relatedVulnerabilities']), (value) => value === null || value === ''), null, 2)}`
            },
            arrayTransformer: skipSeverityNegligibleOrUnknown,
            results: [
                {
                    status: inspecjs_1.ExecJSON.ControlResultStatus.Failed,
                    code_desc: {
                        transformer: (data) => `${JSON.stringify(lodash_1.default.get(data, 'matchDetails'), null, 2)}`
                    },
                    message: {
                        transformer: resultMessageTransformer
                    },
                    start_time: lodash_1.default.get(this.metadata, 'descriptor.timestamp')
                }
            ]
        };
    }
    mapping() {
        return {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version,
                target_id: null
            },
            version: package_json_1.version,
            statistics: {
                duration: null
            },
            profiles: [
                {
                    name: 'Anchore - Grype',
                    title: 'Anchore Grype Matches',
                    version: lodash_1.default.get(this.metadata, 'descriptor.version'),
                    maintainer: null,
                    summary: null,
                    license: null,
                    copyright: null,
                    copyright_email: null,
                    supports: [],
                    attributes: [],
                    depends: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            ...this.controlMatches('wrapper.matches', (data) => `Grype/${lodash_1.default.get(data, 'vulnerability.id')}`, (0, base_converter_1.impactMapping)(IMPACT_MAPPING), (data) => `${JSON.stringify(lodash_1.default.get(data, 'artifact'), null, 2)}`)
                        },
                        {
                            ...this.controlMatches('wrapper.ignoredMatches', (data) => `Grype-Ignored-Match/${lodash_1.default.get(data, 'vulnerability.id')}`, () => 0, (data) => `This finding is ignored due to the following applied ignored rules:\n${JSON.stringify(lodash_1.default.get(data, 'appliedIgnoreRules'), null, 2)}\nArtifact Information:\n${JSON.stringify(lodash_1.default.get(data, 'artifact'), null, 2)}`)
                        }
                    ],
                    sha256: ''
                }
            ],
            passthrough: {
                transformer: (data) => {
                    return {
                        auxiliary_data: [{ name: '', data: lodash_1.default.omit([]) }],
                        ...(this.withRaw && { raw: data })
                    };
                }
            }
        };
    }
    constructor(exportJson, withRaw = false) {
        const temp = JSON.parse(exportJson);
        super({ wrapper: lodash_1.default.pick(temp, ['matches', 'ignoredMatches']) });
        this.metadata = lodash_1.default.omit(temp, ['matches', 'ignoredMatches']);
        this.withRaw = withRaw;
        this.setMappings(this.mapping());
    }
}
exports.AnchoreGrypeMapper = AnchoreGrypeMapper;
//# sourceMappingURL=anchore-grype-mapper.js.map