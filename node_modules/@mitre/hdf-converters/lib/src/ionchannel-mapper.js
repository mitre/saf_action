"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IonChannelMapper = exports.IonChannelAPIMapper = void 0;
const axios_1 = __importDefault(require("axios"));
const lodash_1 = __importDefault(require("lodash"));
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const global_1 = require("./utils/global");
function extractAllDependencies(dependency) {
    const result = [];
    result.push({
        ...dependency,
        parentDependencies: []
    });
    if (Array.isArray(dependency.dependencies)) {
        dependency.dependencies.forEach((subDependency) => {
            result.push(...extractAllDependencies(subDependency));
        });
    }
    return result;
}
function preprocessIonChannelData(ionchannelData) {
    const result = {
        metadata: {},
        scans: {
            vulnerability: [],
            dependency: {
                dependencies: [],
                contextualizedDependencies: []
            },
            ecosystems: [],
            community: [],
            buildsystems: [],
            virus: [],
            license: [],
            difference: [],
            about_yml: []
        }
    };
    const parsed = JSON.parse(ionchannelData);
    const scanSummaries = lodash_1.default.get(parsed, 'scan_summaries');
    result.metadata = lodash_1.default.omit(parsed, 'scan_summaries');
    if (!Array.isArray(scanSummaries)) {
        throw new Error(`Ion Channel scan_summaries invalid summary data (expecting array, got ${typeof scanSummaries})`);
    }
    scanSummaries.forEach((scanSummary) => {
        switch (scanSummary.name) {
            case 'dependency':
                if (!scanSummary.results.data.dependencies) {
                    throw new Error('Dependency scan contains no dependencies array');
                }
                result.scans.dependency.dependencies =
                    scanSummary.results.data.dependencies;
                break;
            default:
                break;
        }
    });
    const dependencyGraph = {};
    result.scans.dependency.dependencies.forEach((topLevelDependency) => {
        const flatDependencies = extractAllDependencies(topLevelDependency);
        flatDependencies.forEach((dependency) => {
            dependencyGraph[`${dependency.org}/${dependency.name}`] = dependency;
        });
    });
    Object.entries(dependencyGraph).forEach(([, dependency]) => {
        if (Array.isArray(dependency.dependencies)) {
            dependency.dependencies.forEach((subDependency) => {
                dependencyGraph[`${subDependency.org}/${subDependency.name}`].parentDependencies.push(`${dependency.org}/${dependency.name}`);
            });
        }
    });
    Object.entries(dependencyGraph).forEach(([, dependency]) => {
        result.scans.dependency.contextualizedDependencies.push(dependency);
    });
    return result;
}
class IonChannelAPIMapper {
    constructor(apiKey, projectId, teamId, analysisId) {
        this.apiKey = apiKey;
        this.projectId = projectId;
        this.teamId = teamId;
        this.analysisId = analysisId;
        this.apiClient = axios_1.default.create();
        this.apiClient.defaults.headers.common['Authorization'] = `Bearer ${this.apiKey}`;
        this.apiClient.defaults.headers.common['Accept'] =
            'application/json, text/plain, */*';
    }
    async toHdf() {
        const analysis = await this.getAnalysis();
        const mapper = new IonChannelMapper(JSON.stringify(analysis.analysis));
        return mapper.toHdf();
    }
    async setTeam(teamName) {
        const availableTeams = await this.getTeams();
        const foundTeam = availableTeams.find((team) => team.name.toLowerCase() === teamName.toLowerCase());
        if (!foundTeam) {
            throw new Error(`Team ${teamName} not found in available teams: ${availableTeams
                .map((team) => team.name)
                .join(', ')}`);
        }
        this.teamId = foundTeam.id;
    }
    async getTeams() {
        if (!this.apiKey) {
            throw new Error('No API-Key Set');
        }
        return this.apiClient
            .get('https://api.ionchannel.io/v1/teams/getTeams')
            .then(({ data }) => data.data);
    }
    async setProject(projectName) {
        const availableProjects = await this.getProjects();
        const foundProject = availableProjects.find((project) => project.name.toLowerCase() === projectName.toLowerCase());
        if (!foundProject) {
            throw new Error(`Project ${projectName} not found in available projects: ${availableProjects
                .map((project) => project.name)
                .join(', ')}`);
        }
        this.projectId = foundProject.id;
        this.analysisId = foundProject.analysis_summary.analysis_id;
    }
    async getProjects() {
        if (!this.apiKey) {
            throw new Error('No API-Key Defined');
        }
        if (!this.teamId) {
            throw new Error('No Team ID Defined');
        }
        return this.apiClient
            .get('https://api.ionchannel.io/v1/report/getProjects', {
            params: {
                team_id: this.teamId
            }
        })
            .then(({ data }) => data.data);
    }
    async getAnalysis() {
        if (!this.apiKey) {
            throw new Error('No API-Key Defined');
        }
        if (!this.projectId) {
            throw new Error('No Project ID Defined');
        }
        if (!this.teamId) {
            throw new Error('No Team ID Defined');
        }
        if (!this.analysisId) {
            throw new Error('No Analysis ID Defined');
        }
        return this.apiClient
            .get('https://api.ionchannel.io/v1/report/getAnalysis', {
            params: {
                project_id: this.projectId,
                team_id: this.teamId,
                analysis_id: this.analysisId
            }
        })
            .then(({ data }) => data.data);
    }
}
exports.IonChannelAPIMapper = IonChannelAPIMapper;
class IonChannelMapper extends base_converter_1.BaseConverter {
    constructor(ionchannelJson) {
        super(preprocessIonChannelData(ionchannelJson));
        this.mappings = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version,
                target_id: { path: 'metadata.project_id' }
            },
            passthrough: {
                ionchannel_metadata: {
                    path: 'metadata'
                }
            },
            version: package_json_1.version,
            statistics: {
                duration: null
            },
            profiles: [
                {
                    name: 'IonChannel SBOM Analysis',
                    version: '',
                    title: {
                        path: 'metadata.source',
                        transformer: (source) => `IonChannel Analysis of ${source}`
                    },
                    maintainer: 'saf@groups.mitre.org',
                    summary: '',
                    license: null,
                    copyright: null,
                    copyright_email: null,
                    supports: [],
                    attributes: [],
                    depends: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: 'scans.dependency.contextualizedDependencies',
                            key: 'id',
                            tags: {
                                transformer: (dependency) => {
                                    return Array.isArray(dependency.dependencies)
                                        ? {
                                            ...lodash_1.default.omit(dependency, 'dependencies'),
                                            nist: global_1.DEFAULT_INFORMATION_SYSTEM_COMPONENT_MANAGEMENT_NIST_TAGS,
                                            cci: (0, global_1.getCCIsForNISTTags)(global_1.DEFAULT_INFORMATION_SYSTEM_COMPONENT_MANAGEMENT_NIST_TAGS),
                                            dependencies: dependency.dependencies.map((subDependency) => `${subDependency.name}`)
                                        }
                                        : {
                                            ...lodash_1.default.omit(dependency, 'dependencies'),
                                            nist: global_1.DEFAULT_INFORMATION_SYSTEM_COMPONENT_MANAGEMENT_NIST_TAGS,
                                            cci: (0, global_1.getCCIsForNISTTags)(global_1.DEFAULT_INFORMATION_SYSTEM_COMPONENT_MANAGEMENT_NIST_TAGS)
                                        };
                                }
                            },
                            descriptions: [],
                            refs: [],
                            source_location: {},
                            title: {
                                transformer: (dependency) => {
                                    if (dependency.type === 'pypi' &&
                                        dependency.package === 'egg' &&
                                        dependency.name === '-e') {
                                        return `Python requirements file ${dependency.file}`;
                                    }
                                    let title = `Dependency ${dependency.name} `;
                                    if (dependency.org && dependency.org.toLowerCase() !== 'n/a') {
                                        title += `from ${dependency.org} `;
                                    }
                                    if (dependency.version &&
                                        dependency.version.toLowerCase() !== 'n/a') {
                                        title += `@ ${dependency.version} `;
                                    }
                                    if (dependency.requirement &&
                                        dependency.requirement.toLowerCase() !== 'n/a') {
                                        title += `(Required ${dependency.requirement}) `;
                                    }
                                    return title.trim();
                                }
                            },
                            id: {
                                transformer: (dependency) => {
                                    return `dependency-${dependency.org}/${dependency.name}`;
                                }
                            },
                            desc: '',
                            impact: 0.0,
                            code: {
                                transformer: (dependency) => JSON.stringify(dependency, null, 2)
                            },
                            results: []
                        }
                    ],
                    sha256: ''
                }
            ]
        };
    }
}
exports.IonChannelMapper = IonChannelMapper;
//# sourceMappingURL=ionchannel-mapper.js.map