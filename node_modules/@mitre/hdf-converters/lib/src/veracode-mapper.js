"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VeracodeMapper = void 0;
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const CweNistMapping_1 = require("./mappings/CweNistMapping");
const global_1 = require("./utils/global");
const STATIC_FLAWS = 'staticflaws.flaw';
const SEVERITY = 'detailedreport.severity';
const FILE_PATH_VALUE = 'file_paths.file_path.value';
const CWE_NIST_MAPPING = new CweNistMapping_1.CweNistMapping();
const DEFAULT_NIST_TAG = ['SI-2', 'RA-5'];
const IMPACT_MAPPING = new Map([
    ['5', 0.9],
    ['4', 0.7],
    ['3', 0.5],
    ['2', 0.3],
    ['1', 0.1],
    ['0', 0.0]
]);
function impactMapping(severity) {
    return IMPACT_MAPPING.get(severity.toString()) || 0.1;
}
function nistTag(input) {
    const cwes = [];
    let cwe = lodash_1.default.get(input, 'cwe');
    if (!Array.isArray(cwe)) {
        cwe = [cwe];
    }
    cwes.push(...cwe.map((value) => lodash_1.default.get(value, 'cweid')));
    return CWE_NIST_MAPPING.nistFilter(cwes, DEFAULT_NIST_TAG);
}
function formatRecommendations(input) {
    const text = [];
    if (lodash_1.default.has(input, 'recommendations.para')) {
        if (lodash_1.default.has(input, 'recommendations.para.text')) {
            text.push(`${lodash_1.default.get(input, 'recommendations.para.text')}`);
        }
        else {
            text.push(...lodash_1.default.get(input, `recommendations.para`).map((value) => lodash_1.default.get(value, 'text')));
        }
    }
    if (lodash_1.default.has(input, 'recommendations.para.bulletitem')) {
        if (Array.isArray(lodash_1.default.get(input, `recommendations.para.bulletitem`))) {
            text.push(...lodash_1.default.get(input, `recommendations.para.bulletitem`).map((value) => lodash_1.default.get(value, 'text')));
        }
    }
    return text.join('\n');
}
function formatDesc(input) {
    const text = [];
    if (lodash_1.default.has(input, 'desc.para')) {
        if (lodash_1.default.has(input, 'desc.para.text')) {
            text.push(`${lodash_1.default.get(input, 'desc.para.text')}`);
        }
        else {
            text.push(...lodash_1.default.get(input, `desc.para`).map((value) => lodash_1.default.get(value, 'text')));
        }
    }
    return text.join('\n');
}
function formatCweData(input) {
    const text = [];
    const categories = [
        'pcrirelated',
        'owasp',
        'owasp2013',
        'sans',
        'certc',
        'certccp',
        'certjava',
        'owaspmobile'
    ];
    if (lodash_1.default.has(input, 'cwe')) {
        let cweInput = lodash_1.default.get(input, 'cwe');
        if (!Array.isArray(cweInput)) {
            cweInput = [cweInput];
        }
        text.push(...cweInput.map((cweinfo) => {
            let cwe = `CWE-${lodash_1.default.get(cweinfo, 'cweid')}: `;
            cwe += `${lodash_1.default.get(cweinfo, 'cwename')}`;
            cwe += categories
                .map((value) => {
                if (lodash_1.default.has(cweinfo, value)) {
                    return `${value}: ${lodash_1.default.get(cweinfo, value)}\n`;
                }
                else {
                    return '';
                }
            })
                .join('');
            return cwe;
        }));
    }
    return text.join('\n');
}
function formatCweDesc(input) {
    const text = [];
    if (lodash_1.default.has(input, 'cwe')) {
        let cwe = lodash_1.default.get(input, 'cwe');
        if (!Array.isArray(cwe)) {
            cwe = [cwe];
        }
        text.push(...cwe.map((value) => `CWE-${lodash_1.default.get(value, 'cweid')}: ${lodash_1.default.get(value, 'cwename')} Description: ${lodash_1.default.get(value, 'description.text.text')}; `));
    }
    return text.join('\n');
}
function getFlaws(input) {
    const flawArr = [];
    if (!Array.isArray(input)) {
        input = [input];
    }
    for (const value of input) {
        let staticFlaw = lodash_1.default.get(value, STATIC_FLAWS);
        if (!Array.isArray(staticFlaw)) {
            staticFlaw = [staticFlaw];
        }
        flawArr.push(...staticFlaw);
    }
    return flawArr;
}
function formatCodeDesc(input) {
    let flawDesc = '';
    const categories = [
        ['Line Number', 'line'],
        ['Affect Policy Compliance', 'affects_policy_compliance'],
        ['Remediation Effort', 'remediationeffort'],
        ['Exploit level', 'exploitLevel'],
        ['Issue ID', 'issueid'],
        ['Module', 'module'],
        ['Type', 'type'],
        ['CWE ID', 'cweid'],
        ['Date First Occurence', 'date_first_occurence'],
        ['CIA Impact', 'cia_impact'],
        ['Description', 'description'],
        ['Source File', 'sourcefile'],
        ['Scope', 'scope'],
        ['CIA Impact', 'cia_impact'],
        ['PCI Related', 'pcirelated'],
        ['Function Prototype', 'functionprototype'],
        ['Function Relative Location', 'functionrelativelocation']
    ];
    if (lodash_1.default.has(input, 'sourcefilepath')) {
        flawDesc = `Sourcefile Path: ${lodash_1.default.get(input, 'sourcefilepath')}\n`;
        flawDesc += categories
            .map(([title, name]) => {
            if (lodash_1.default.has(input, name)) {
                return `${title}: ${lodash_1.default.get(input, name)}\n`;
            }
            else {
                return '';
            }
        })
            .join('');
    }
    return flawDesc;
}
function formatSCACodeDesc(input) {
    let flawDesc = '';
    const categories = [
        'sha1',
        'file_name',
        'max_cvss_score',
        'version',
        'library',
        'library_id',
        'vendor',
        'description',
        'added_date',
        'component_affects_policy_compliance'
    ];
    if (lodash_1.default.has(input, 'component_id')) {
        flawDesc = `component_id: ${lodash_1.default.get(input, 'component_id')}\n`;
        flawDesc += lodash_1.default.compact(categories.map((value) => {
            if (lodash_1.default.has(input, value)) {
                return `${value}: ${lodash_1.default.get(input, value)}`;
            }
            else {
                return '';
            }
        })).join('\n');
        if (lodash_1.default.has(input, FILE_PATH_VALUE)) {
            flawDesc += `\nfile_path: ${lodash_1.default.get(input, FILE_PATH_VALUE)}\n`;
        }
    }
    return flawDesc;
}
function formatSourceLocation(input) {
    const flawArr = [];
    if (!Array.isArray(input)) {
        input = [input];
    }
    for (const value of input) {
        if (!Array.isArray(lodash_1.default.get(value, STATIC_FLAWS))) {
            flawArr.push(lodash_1.default.get(value, STATIC_FLAWS));
        }
        else {
            flawArr.push(...lodash_1.default.get(value, STATIC_FLAWS));
        }
    }
    return flawArr.map((value) => lodash_1.default.get(value, 'sourcefile')).join('\n');
}
function componentListCreate(input) {
    const componentList = [];
    let component = lodash_1.default.get(input, 'component');
    if (!Array.isArray(component)) {
        component = [component];
    }
    for (const value of component) {
        if (lodash_1.default.get(value, `vulnerabilities`) !== '') {
            componentList.push(value);
        }
    }
    return componentList;
}
function componentTransform(input) {
    const componentList = componentListCreate(input);
    const vulns = componentList
        .map((component) => {
        let vulnerability = lodash_1.default.get(component, 'vulnerabilities.vulnerability');
        if (!Array.isArray(vulnerability)) {
            vulnerability = [vulnerability];
        }
        vulnerability = vulnerability.map((vuln) => ({
            ...vuln,
            components: [component]
        }));
        return vulnerability;
    })
        .flat()
        .reduce((acc, cur) => {
        const cveId = lodash_1.default.get(cur, 'cve_id');
        const index = acc.findIndex(({ cve_id }) => cveId === cve_id);
        if (index === -1) {
            return [...acc, cur];
        }
        else {
            lodash_1.default.get(acc[index], 'components').push(...lodash_1.default.get(cur, 'components'));
            return acc;
        }
    }, []);
    return vulns;
}
function controlMappingCve() {
    return {
        id: { path: 'cve_id' },
        title: { path: 'cve_id' },
        desc: { path: 'cve_summary' },
        impact: { path: 'severity', transformer: impactMapping },
        refs: [],
        tags: {
            cwe: { path: 'cwe_id' },
            nist: {
                path: 'cwe_id',
                transformer: (value) => {
                    if (!Array.isArray(value)) {
                        value = [value];
                    }
                    return CWE_NIST_MAPPING.nistFilter(value.map((val) => val.substring(4)), DEFAULT_NIST_TAG);
                }
            }
        },
        source_location: {
            ref: {
                transformer: (vuln) => lodash_1.default.get(vuln, 'components')
                    .map((comp) => lodash_1.default.get(comp, FILE_PATH_VALUE))
                    .join('\n')
            }
        },
        results: [
            {
                path: 'components',
                status: inspecjs_1.ExecJSON.ControlResultStatus.Failed,
                code_desc: { transformer: formatSCACodeDesc },
                start_time: { path: '$.detailedreport.first_build_submitted_date' }
            }
        ]
    };
}
function controlMappingCwe(severity) {
    return {
        id: { path: 'categoryid' },
        title: { path: 'categoryname' },
        desc: { transformer: formatDesc },
        descriptions: [
            {
                data: { transformer: formatRecommendations },
                label: 'fix'
            }
        ],
        impact: impactMapping(severity),
        refs: [],
        tags: {
            cweid: { transformer: formatCweData },
            cweDescription: { transformer: formatCweDesc },
            cci: {
                transformer: (data) => (0, global_1.getCCIsForNISTTags)(nistTag(data))
            },
            nist: { transformer: nistTag }
        },
        source_location: {
            ref: {
                path: 'cwe',
                transformer: formatSourceLocation
            }
        },
        results: [
            {
                path: 'cwe',
                pathTransform: getFlaws,
                status: inspecjs_1.ExecJSON.ControlResultStatus.Failed,
                code_desc: { transformer: formatCodeDesc },
                start_time: { path: '$.detailedreport.first_build_submitted_date' },
                message: {
                    path: 'exploitability_adjustments.exploitability_adjustment.note'
                }
            }
        ]
    };
}
function componentPass(component) {
    const vulnList = [];
    lodash_1.default.set(component, 'control_ids', vulnList);
    if (lodash_1.default.get(component, 'vulnerabilities.vulnerability')) {
        if (!Array.isArray(lodash_1.default.get(component, 'vulnerabilities.vulnerability'))) {
            vulnList.push(lodash_1.default.get(component, 'vulnerabilities.vulnerability.cve_id'));
            lodash_1.default.set(component, 'control_ids', vulnList);
        }
        else {
            vulnList.push(...lodash_1.default.get(component, 'vulnerabilities.vulnerability').map((vuln) => lodash_1.default.get(vuln, 'cve_id')));
            lodash_1.default.set(component, 'control_ids', vulnList);
        }
    }
    return lodash_1.default.omit(component, 'vulnerabilities');
}
class VeracodeMapper extends base_converter_1.BaseConverter {
    constructor(xml, withRaw = false) {
        const parsedXML = (0, base_converter_1.parseXml)(xml);
        if (lodash_1.default.has(parsedXML, 'summaryreport')) {
            throw new Error('Current mapper does not accept summary reports');
        }
        const arrayedControls = lodash_1.default.get(parsedXML, SEVERITY).map((control) => {
            if (Array.isArray(control.category)) {
                return { level: control.level, category: control.category };
            }
            else if (!control.category) {
                return { level: control.level };
            }
            else {
                return { level: control.level, category: [control.category] };
            }
        });
        lodash_1.default.set(parsedXML, SEVERITY, arrayedControls);
        super(parsedXML);
        this.originalData = xml;
        this.setMappings(this.defaultMapping(withRaw));
    }
    defaultMapping(withRaw = false) {
        return {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version
            },
            passthrough: {
                components: {
                    path: 'detailedreport.software_composition_analysis.vulnerable_components',
                    transformer: (value) => lodash_1.default.get(value, 'component').map((component) => componentPass(component))
                },
                auxiliary_data: [
                    {
                        name: 'veracode',
                        data: {
                            transformer: (value) => lodash_1.default.omit(value, SEVERITY, 'detailedreport.software_composition_analysis')
                        }
                    }
                ],
                ...(withRaw && { raw: this.originalData })
            },
            version: package_json_1.version,
            statistics: {},
            profiles: [
                {
                    name: { path: 'detailedreport.policy_name' },
                    version: { path: 'detailedreport.policy_version' },
                    title: { path: 'detailedreport.static-analysis.modules.module.name' },
                    supports: [],
                    attributes: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        ...lodash_1.default.range(0, 6).map((value) => ({
                            path: `detailedreport.severity[${value}].category`,
                            ...controlMappingCwe(5 - value)
                        })),
                        {
                            path: 'detailedreport.software_composition_analysis.vulnerable_components',
                            pathTransform: componentTransform,
                            ...controlMappingCve()
                        }
                    ],
                    sha256: ''
                }
            ]
        };
    }
}
exports.VeracodeMapper = VeracodeMapper;
//# sourceMappingURL=veracode-mapper.js.map