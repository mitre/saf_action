"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPreviouslyHDF = void 0;
const html_entities_1 = require("html-entities");
const inspecjs_1 = require("inspecjs");
const _ = __importStar(require("lodash"));
const global_1 = require("../utils/global");
const asff_mapper_1 = require("./asff-mapper");
function replaceTypesSlashes(type) {
    if (!_.isString(type)) {
        return type;
    }
    return type.replace(global_1.FROM_ASFF_TYPES_SLASH_REPLACEMENT, '/');
}
function objectifyTypesArray(typesArray) {
    if (!Array.isArray(typesArray)) {
        typesArray = _.get(typesArray, 'FindingProviderFields.Types');
    }
    const groupedTypes = _.groupBy(typesArray, (typeString) => typeString.split('/').slice(0, -1).join('/'));
    const ret = {};
    for (const [typeAndAttribute, values] of Object.entries(groupedTypes)) {
        _.merge(ret, (() => {
            const [type, attribute] = typeAndAttribute.split('/');
            let parsed = replaceTypesSlashes(values.map((v) => v.split('/').slice(-1)).join(''));
            try {
                parsed = JSON.parse(parsed);
            }
            catch { }
            return { [type]: { [attribute]: parsed } };
        })());
    }
    return ret;
}
function findExecutionFindingIndex(asffOrFindings, asffFindingToMatch) {
    if (asffFindingToMatch) {
        const targetToMatch = asffFindingToMatch.Id.split('/')[0];
        return _.findIndex(Array.isArray(asffOrFindings)
            ? asffOrFindings
            : _.get(asffOrFindings, 'Findings'), (finding) => _.get(finding, 'Id').split('/').length === 2 &&
            _.get(finding, 'Id').startsWith(targetToMatch));
    }
    return _.findIndex(Array.isArray(asffOrFindings)
        ? asffOrFindings
        : _.get(asffOrFindings, 'Findings'), (finding) => _.get(finding, 'Id').split('/').length === 2);
}
function preprocessingASFF(asff) {
    const clone = _.cloneDeep(asff);
    const index = findExecutionFindingIndex(clone);
    _.pullAt(_.get(clone, 'Findings'), index);
    return clone;
}
function supportingDocs(input) {
    const [asff, docs] = input;
    const index = findExecutionFindingIndex(asff);
    const docsClone = _.cloneDeep(docs);
    docsClone.set(asff_mapper_1.SpecialCasing.PreviouslyHDF, {
        execution: _.get(asff, `Findings[${index}]`)
    });
    return docsClone;
}
function productName(findings) {
    const finding = Array.isArray(findings) ? findings[0] : findings;
    const name = _.get(finding, 'Id');
    return (0, html_entities_1.encode)(name.split('/').slice(0, 2).join(' - '));
}
function titlePrefix() {
    return '';
}
function code(group) {
    return group[0].code || '';
}
function waiverData(group) {
    return group[0].waiver_data || {};
}
function filename(findingInfo) {
    const index = findExecutionFindingIndex(findingInfo[1], findingInfo[0]);
    const target = replaceTypesSlashes(_.get(findingInfo[1][index], 'Id').split('/')[0]);
    const finding = findingInfo[0];
    return `${_.get(objectifyTypesArray(finding), 'File.Input')}-${target}.json`;
}
function getCodeForProfileLayer(finding, profileName) {
    var _a, _b, _c;
    const profileLayerToCodeMapping = {};
    (_c = (_b = (_a = _.get(finding, 'Resources')
        .find((resource) => resource.Type === 'AwsIamRole')) === null || _a === void 0 ? void 0 : _a.Details) === null || _b === void 0 ? void 0 : _b.AwsIamRole) === null || _c === void 0 ? void 0 : _c.AssumeRolePolicyDocument.split('=========================================================\n# Profile name: ').filter((codeLayer) => codeLayer).forEach((codeLayer) => {
        const [profileLevel, code] = codeLayer.split('\n=========================================================\n\n');
        profileLayerToCodeMapping[profileLevel] = code
            .split('Test Description:')[0]
            .trim();
    });
    if (profileName in profileLayerToCodeMapping) {
        return profileLayerToCodeMapping[profileName];
    }
    else {
        return '';
    }
}
function mapping(context) {
    var _a;
    const execution = _.get(context.supportingDocs.get(asff_mapper_1.SpecialCasing.PreviouslyHDF), 'execution');
    const executionTypes = objectifyTypesArray(execution);
    const profileNames = Object.keys(executionTypes || {}).filter((type) => !['MITRE', 'File', 'Execution', 'HDF2ASFF-converter'].includes(type));
    return {
        shortcircuit: true,
        platform: {
            ..._.get(executionTypes, 'Execution.platform'),
            target_id: ((_a = context.supportingDocs.get(asff_mapper_1.SpecialCasing.PreviouslyHDF)) === null || _a === void 0 ? void 0 : _a.execution.Id).split('/')[0]
        },
        version: _.get(executionTypes, 'Execution.version'),
        statistics: _.get(executionTypes, 'Execution.statistics'),
        profiles: _.map(profileNames, (profileName, index) => {
            return {
                name: _.get(executionTypes, `${profileName}.name`),
                ...(0, global_1.conditionallyProvideAttribute)('version', _.get(executionTypes, `${profileName}.version`), _.has(executionTypes, `${profileName}.version`)),
                ...(0, global_1.conditionallyProvideAttribute)('title', _.get(executionTypes, `${profileName}.title`), _.has(executionTypes, `${profileName}.title`)),
                ...(0, global_1.conditionallyProvideAttribute)('maintainer', _.get(executionTypes, `${profileName}.maintainer`), _.has(executionTypes, `${profileName}.maintainer`)),
                ...(0, global_1.conditionallyProvideAttribute)('summary', _.get(executionTypes, `${profileName}.summary`), _.has(executionTypes, `${profileName}.summary`)),
                ...(0, global_1.conditionallyProvideAttribute)('license', _.get(executionTypes, `${profileName}.license`), _.has(executionTypes, `${profileName}.license`)),
                ...(0, global_1.conditionallyProvideAttribute)('copyright', _.get(executionTypes, `${profileName}.copyright`), _.has(executionTypes, `${profileName}.copyright`)),
                ...(0, global_1.conditionallyProvideAttribute)('copyright_email', _.get(executionTypes, `${profileName}.copyright_email`), _.has(executionTypes, `${profileName}.copyright_email`)),
                supports: _.get(executionTypes, `${profileName}.supports`, []),
                attributes: _.get(executionTypes, `${profileName}.attributes`, []),
                ...(0, global_1.conditionallyProvideAttribute)('depends', _.get(executionTypes, `${profileName}.depends`), _.has(executionTypes, `${profileName}.depends`)),
                groups: [],
                ...(0, global_1.conditionallyProvideAttribute)('status', _.get(executionTypes, `${profileName}.status`), _.has(executionTypes, `${profileName}.status`)),
                ...(0, global_1.conditionallyProvideAttribute)('description', _.get(executionTypes, `${profileName}.description`), _.has(executionTypes, `${profileName}.description`)),
                ...(0, global_1.conditionallyProvideAttribute)('inspec_version', _.get(executionTypes, `${profileName}.inspec_version`), _.has(executionTypes, `${profileName}.inspec_version`)),
                ...(0, global_1.conditionallyProvideAttribute)('parent_profile', _.get(executionTypes, `${profileName}.parent_profile`), _.has(executionTypes, `${profileName}.parent_profile`)),
                ...(0, global_1.conditionallyProvideAttribute)('skip_message', _.get(executionTypes, `${profileName}.skip_message`), _.has(executionTypes, `${profileName}.skip_message`)),
                ...(0, global_1.conditionallyProvideAttribute)('status_message', _.get(executionTypes, `${profileName}.status_message`), _.has(executionTypes, `${profileName}.status_message`)),
                controls: (0, asff_mapper_1.consolidate)(context, (() => {
                    return _.map(_.get(context.data, 'Findings'), (finding) => {
                        const findingTypes = objectifyTypesArray(finding);
                        return {
                            id: _.get(findingTypes, 'Control.ID'),
                            ...(0, global_1.conditionallyProvideAttribute)('title', _.get(findingTypes, 'Control.Title'), _.has(findingTypes, 'Control.Title')),
                            ...(0, global_1.conditionallyProvideAttribute)('desc', _.get(findingTypes, 'Control.Desc'), _.has(findingTypes, 'Control.Desc')),
                            impact: _.get(findingTypes, 'Control.Impact'),
                            tags: {
                                ..._.omit(_.get(findingTypes, 'Tags'), ['nist']),
                                nist: (() => {
                                    const nisttags = _.get(findingTypes, 'Tags.nist');
                                    if (nisttags === undefined || nisttags.length === 0) {
                                        return global_1.DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS;
                                    }
                                    return nisttags;
                                })()
                            },
                            descriptions: _.map(Object.entries(_.get(findingTypes, 'Descriptions') || {}), ([key, value]) => ({ label: key, data: value })),
                            refs: _.get(findingTypes, 'Control.Refs', []),
                            source_location: _.get(findingTypes, 'Control.Source_Location', {}),
                            ...(0, global_1.conditionallyProvideAttribute)('waiver_data', _.get(findingTypes, 'Control.Waiver_Data'), _.has(findingTypes, 'Control.Waiver_Data')),
                            code: getCodeForProfileLayer(finding, profileName),
                            results: (() => {
                                if (index !== profileNames.length - 1) {
                                    return [];
                                }
                                const ret = [
                                    {
                                        code_desc: _.get(findingTypes, 'Segment.code_desc'),
                                        start_time: _.get(findingTypes, 'Segment.start_time'),
                                        ..._.omit(_.get(findingTypes, 'Segment'), ['code_desc', 'start_time'])
                                    }
                                ];
                                return _.has(findingTypes, 'HDF2ASFF-converter.warning')
                                    ? ret.concat([
                                        {
                                            code_desc: '',
                                            start_time: '',
                                            status: inspecjs_1.ExecJSON.ControlResultStatus.Skipped,
                                            skip_message: 'Warning: Entry was truncated when converted to ASFF (AWS Security Hub)'
                                        }
                                    ])
                                    : ret;
                            })()
                        };
                    });
                })(), context.data),
                sha256: _.get(executionTypes, `${profileName}.sha256`)
            };
        }),
        ...(0, global_1.conditionallyProvideAttribute)('passthrough', _.has(executionTypes, 'HDF2ASFF-converter.warning')
            ? [
                _.get(executionTypes, 'Execution.passthrough'),
                'Warning: Entry was truncated when converted to ASFF (AWS Security Hub)'
            ]
            : _.get(executionTypes, 'Execution.passthrough'), _.has(executionTypes, 'Execution.passthrough'))
    };
}
function getPreviouslyHDF() {
    return {
        preprocessingASFF,
        supportingDocs,
        productName,
        titlePrefix,
        code,
        waiverData,
        filename,
        mapping
    };
}
exports.getPreviouslyHDF = getPreviouslyHDF;
//# sourceMappingURL=case-previously-hdf.js.map