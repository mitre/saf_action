"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPreviouslyHDF = void 0;
const html_entities_1 = require("html-entities");
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const global_1 = require("../utils/global");
const asff_mapper_1 = require("./asff-mapper");
function replaceTypesSlashes(type) {
    if (!lodash_1.default.isString(type)) {
        return type;
    }
    return type.replace(global_1.FROM_ASFF_TYPES_SLASH_REPLACEMENT, '/');
}
function objectifyTypesArray(typesArray) {
    if (!Array.isArray(typesArray)) {
        typesArray = lodash_1.default.get(typesArray, 'FindingProviderFields.Types');
    }
    const groupedTypes = lodash_1.default.groupBy(typesArray, (typeString) => typeString.split('/').slice(0, -1).join('/'));
    const ret = {};
    for (const [typeAndAttribute, values] of Object.entries(groupedTypes)) {
        lodash_1.default.merge(ret, (() => {
            const [type, attribute] = typeAndAttribute.split('/');
            let parsed = replaceTypesSlashes(values.map((v) => v.split('/').slice(-1)).join(''));
            try {
                parsed = JSON.parse(parsed);
            }
            catch { }
            return { [type]: { [attribute]: parsed } };
        })());
    }
    return ret;
}
function findExecutionFindingIndex(asffOrFindings, asffFindingToMatch) {
    if (asffFindingToMatch) {
        const targetToMatch = asffFindingToMatch.Id.split('/')[0];
        return lodash_1.default.findIndex(Array.isArray(asffOrFindings)
            ? asffOrFindings
            : lodash_1.default.get(asffOrFindings, 'Findings'), (finding) => lodash_1.default.get(finding, 'Id').split('/').length === 2 &&
            lodash_1.default.get(finding, 'Id').startsWith(targetToMatch));
    }
    return lodash_1.default.findIndex(Array.isArray(asffOrFindings)
        ? asffOrFindings
        : lodash_1.default.get(asffOrFindings, 'Findings'), (finding) => lodash_1.default.get(finding, 'Id').split('/').length === 2);
}
function preprocessingASFF(asff) {
    const clone = lodash_1.default.cloneDeep(asff);
    const index = findExecutionFindingIndex(clone);
    lodash_1.default.pullAt(lodash_1.default.get(clone, 'Findings'), index);
    return clone;
}
function supportingDocs(input) {
    const [asff, docs] = input;
    const index = findExecutionFindingIndex(asff);
    const docsClone = lodash_1.default.cloneDeep(docs);
    docsClone.set(asff_mapper_1.SpecialCasing.PreviouslyHDF, {
        execution: lodash_1.default.get(asff, `Findings[${index}]`)
    });
    return docsClone;
}
function productName(findings) {
    const finding = Array.isArray(findings) ? findings[0] : findings;
    const name = lodash_1.default.get(finding, 'Id');
    return (0, html_entities_1.encode)(name.split('/').slice(0, 2).join(' - '));
}
function titlePrefix() {
    return '';
}
function code(group) {
    return group[0].code || '';
}
function waiverData(group) {
    return group[0].waiver_data || {};
}
function filename(findingInfo) {
    const index = findExecutionFindingIndex(findingInfo[1], findingInfo[0]);
    const target = replaceTypesSlashes(lodash_1.default.get(findingInfo[1][index], 'Id').split('/')[0]);
    const finding = findingInfo[0];
    return `${lodash_1.default.get(objectifyTypesArray(finding), 'File.Input')}-${target}.json`;
}
function getCodeForProfileLayer(finding, profileName) {
    var _a, _b, _c;
    const profileLayerToCodeMapping = {};
    (_c = (_b = (_a = lodash_1.default.get(finding, 'Resources')
        .find((resource) => resource.Type === 'AwsIamRole')) === null || _a === void 0 ? void 0 : _a.Details) === null || _b === void 0 ? void 0 : _b.AwsIamRole) === null || _c === void 0 ? void 0 : _c.AssumeRolePolicyDocument.split('=========================================================\n# Profile name: ').filter((codeLayer) => codeLayer).forEach((codeLayer) => {
        const [profileLevel, code] = codeLayer.split('\n=========================================================\n\n');
        profileLayerToCodeMapping[profileLevel] = code
            .split('Test Description:')[0]
            .trim();
    });
    if (profileName in profileLayerToCodeMapping) {
        return profileLayerToCodeMapping[profileName];
    }
    else {
        return '';
    }
}
function mapping(context) {
    var _a;
    const execution = lodash_1.default.get(context.supportingDocs.get(asff_mapper_1.SpecialCasing.PreviouslyHDF), 'execution');
    const executionTypes = objectifyTypesArray(execution);
    const profileNames = Object.keys(executionTypes || {}).filter((type) => !['MITRE', 'File', 'Execution', 'HDF2ASFF-converter'].includes(type));
    return {
        shortcircuit: true,
        platform: {
            ...lodash_1.default.get(executionTypes, 'Execution.platform'),
            target_id: ((_a = context.supportingDocs.get(asff_mapper_1.SpecialCasing.PreviouslyHDF)) === null || _a === void 0 ? void 0 : _a.execution.Id).split('/')[0]
        },
        version: lodash_1.default.get(executionTypes, 'Execution.version'),
        statistics: lodash_1.default.get(executionTypes, 'Execution.statistics'),
        profiles: lodash_1.default.map(profileNames, (profileName, index) => {
            return {
                name: lodash_1.default.get(executionTypes, `${profileName}.name`),
                ...(0, global_1.conditionallyProvideAttribute)('version', lodash_1.default.get(executionTypes, `${profileName}.version`), lodash_1.default.has(executionTypes, `${profileName}.version`)),
                ...(0, global_1.conditionallyProvideAttribute)('title', lodash_1.default.get(executionTypes, `${profileName}.title`), lodash_1.default.has(executionTypes, `${profileName}.title`)),
                ...(0, global_1.conditionallyProvideAttribute)('maintainer', lodash_1.default.get(executionTypes, `${profileName}.maintainer`), lodash_1.default.has(executionTypes, `${profileName}.maintainer`)),
                ...(0, global_1.conditionallyProvideAttribute)('summary', lodash_1.default.get(executionTypes, `${profileName}.summary`), lodash_1.default.has(executionTypes, `${profileName}.summary`)),
                ...(0, global_1.conditionallyProvideAttribute)('license', lodash_1.default.get(executionTypes, `${profileName}.license`), lodash_1.default.has(executionTypes, `${profileName}.license`)),
                ...(0, global_1.conditionallyProvideAttribute)('copyright', lodash_1.default.get(executionTypes, `${profileName}.copyright`), lodash_1.default.has(executionTypes, `${profileName}.copyright`)),
                ...(0, global_1.conditionallyProvideAttribute)('copyright_email', lodash_1.default.get(executionTypes, `${profileName}.copyright_email`), lodash_1.default.has(executionTypes, `${profileName}.copyright_email`)),
                supports: lodash_1.default.get(executionTypes, `${profileName}.supports`, []),
                attributes: lodash_1.default.get(executionTypes, `${profileName}.attributes`, []),
                ...(0, global_1.conditionallyProvideAttribute)('depends', lodash_1.default.get(executionTypes, `${profileName}.depends`), lodash_1.default.has(executionTypes, `${profileName}.depends`)),
                groups: [],
                ...(0, global_1.conditionallyProvideAttribute)('status', lodash_1.default.get(executionTypes, `${profileName}.status`), lodash_1.default.has(executionTypes, `${profileName}.status`)),
                ...(0, global_1.conditionallyProvideAttribute)('description', lodash_1.default.get(executionTypes, `${profileName}.description`), lodash_1.default.has(executionTypes, `${profileName}.description`)),
                ...(0, global_1.conditionallyProvideAttribute)('inspec_version', lodash_1.default.get(executionTypes, `${profileName}.inspec_version`), lodash_1.default.has(executionTypes, `${profileName}.inspec_version`)),
                ...(0, global_1.conditionallyProvideAttribute)('parent_profile', lodash_1.default.get(executionTypes, `${profileName}.parent_profile`), lodash_1.default.has(executionTypes, `${profileName}.parent_profile`)),
                ...(0, global_1.conditionallyProvideAttribute)('skip_message', lodash_1.default.get(executionTypes, `${profileName}.skip_message`), lodash_1.default.has(executionTypes, `${profileName}.skip_message`)),
                ...(0, global_1.conditionallyProvideAttribute)('status_message', lodash_1.default.get(executionTypes, `${profileName}.status_message`), lodash_1.default.has(executionTypes, `${profileName}.status_message`)),
                controls: (0, asff_mapper_1.consolidate)(context, (() => {
                    return lodash_1.default.map(lodash_1.default.get(context.data, 'Findings'), (finding) => {
                        const findingTypes = objectifyTypesArray(finding);
                        return {
                            id: lodash_1.default.get(findingTypes, 'Control.ID'),
                            ...(0, global_1.conditionallyProvideAttribute)('title', lodash_1.default.get(findingTypes, 'Control.Title'), lodash_1.default.has(findingTypes, 'Control.Title')),
                            ...(0, global_1.conditionallyProvideAttribute)('desc', lodash_1.default.get(findingTypes, 'Control.Desc'), lodash_1.default.has(findingTypes, 'Control.Desc')),
                            impact: lodash_1.default.get(findingTypes, 'Control.Impact'),
                            tags: {
                                ...lodash_1.default.omit(lodash_1.default.get(findingTypes, 'Tags'), ['nist']),
                                nist: (() => {
                                    const nisttags = lodash_1.default.get(findingTypes, 'Tags.nist');
                                    if (nisttags === undefined || nisttags.length === 0) {
                                        return global_1.DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS;
                                    }
                                    return nisttags;
                                })()
                            },
                            descriptions: lodash_1.default.map(Object.entries(lodash_1.default.get(findingTypes, 'Descriptions') || {}), ([key, value]) => ({ label: key, data: value })),
                            refs: lodash_1.default.get(findingTypes, 'Control.Refs', []),
                            source_location: lodash_1.default.get(findingTypes, 'Control.Source_Location', {}),
                            ...(0, global_1.conditionallyProvideAttribute)('waiver_data', lodash_1.default.get(findingTypes, 'Control.Waiver_Data'), lodash_1.default.has(findingTypes, 'Control.Waiver_Data')),
                            code: getCodeForProfileLayer(finding, profileName),
                            results: (() => {
                                if (index !== profileNames.length - 1) {
                                    return [];
                                }
                                const ret = [
                                    {
                                        code_desc: lodash_1.default.get(findingTypes, 'Segment.code_desc'),
                                        start_time: lodash_1.default.get(findingTypes, 'Segment.start_time'),
                                        ...lodash_1.default.omit(lodash_1.default.get(findingTypes, 'Segment'), ['code_desc', 'start_time'])
                                    }
                                ];
                                return lodash_1.default.has(findingTypes, 'HDF2ASFF-converter.warning')
                                    ? ret.concat([
                                        {
                                            code_desc: '',
                                            start_time: '',
                                            status: inspecjs_1.ExecJSON.ControlResultStatus.Skipped,
                                            skip_message: 'Warning: Entry was truncated when converted to ASFF (AWS Security Hub)'
                                        }
                                    ])
                                    : ret;
                            })()
                        };
                    });
                })(), context.data),
                sha256: lodash_1.default.get(executionTypes, `${profileName}.sha256`)
            };
        }),
        ...(0, global_1.conditionallyProvideAttribute)('passthrough', lodash_1.default.has(executionTypes, 'HDF2ASFF-converter.warning')
            ? [
                lodash_1.default.get(executionTypes, 'Execution.passthrough'),
                'Warning: Entry was truncated when converted to ASFF (AWS Security Hub)'
            ]
            : lodash_1.default.get(executionTypes, 'Execution.passthrough'), lodash_1.default.has(executionTypes, 'Execution.passthrough'))
    };
}
function getPreviouslyHDF() {
    return {
        preprocessingASFF,
        supportingDocs,
        productName,
        titlePrefix,
        code,
        waiverData,
        filename,
        mapping
    };
}
exports.getPreviouslyHDF = getPreviouslyHDF;
//# sourceMappingURL=case-previously-hdf.js.map