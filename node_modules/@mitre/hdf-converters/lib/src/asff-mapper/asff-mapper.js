"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASFFResults = exports.ASFFMapper = exports.consolidate = exports.SpecialCasing = void 0;
const compare_versions_1 = require("compare-versions");
const html_entities_1 = require("html-entities");
const inspecjs_1 = require("inspecjs");
const _ = __importStar(require("lodash"));
const package_json_1 = require("../../package.json");
const base_converter_1 = require("../base-converter");
const global_1 = require("../utils/global");
const case_cms_inspec_1 = require("./case-cms-inspec");
const case_firewall_manager_1 = require("./case-firewall-manager");
const case_guardduty_1 = require("./case-guardduty");
const case_inspector_1 = require("./case-inspector");
const case_previously_hdf_1 = require("./case-previously-hdf");
const case_prowler_1 = require("./case-prowler");
const case_security_hub_1 = require("./case-security-hub");
const case_trivy_1 = require("./case-trivy");
const IMPACT_MAPPING = new Map([
    ['CRITICAL', 0.9],
    ['HIGH', 0.7],
    ['MEDIUM', 0.5],
    ['LOW', 0.3],
    ['INFORMATIONAL', 0.0]
]);
const SEVERITY_LABEL = 'Severity.Label';
const COMPLIANCE_STATUS = 'Compliance.Status';
var SpecialCasing;
(function (SpecialCasing) {
    SpecialCasing["CMSInSpec"] = "CMS Chef InSpec";
    SpecialCasing["FirewallManager"] = "AWS Firewall Manager";
    SpecialCasing["GuardDuty"] = "AWS GuardDuty";
    SpecialCasing["Inspector"] = "AWS Inspector";
    SpecialCasing["Prowler"] = "Prowler";
    SpecialCasing["SecurityHub"] = "AWS Security Hub";
    SpecialCasing["Trivy"] = "Aqua Trivy";
    SpecialCasing["PreviouslyHDF"] = "MITRE SAF HDF2ASFF";
    SpecialCasing["Default"] = "Default";
})(SpecialCasing = exports.SpecialCasing || (exports.SpecialCasing = {}));
function whichSpecialCase(finding) {
    const productArn = _.get(finding, 'ProductArn');
    if (_.get(finding, 'ProductName') === 'Default' &&
        _.get(finding, 'GeneratorId') === 'cms.Chef Inspec') {
        return SpecialCasing.CMSInSpec;
    }
    else if (productArn.match(/^arn:[^:]+:securityhub:[^:]+:[^:]*:product\/aws\/firewall-manager$/)) {
        return SpecialCasing.FirewallManager;
    }
    else if (productArn.match(/^arn:[^:]+:securityhub:[^:]+:[^:]*:product\/aws\/guardduty$/)) {
        return SpecialCasing.GuardDuty;
    }
    else if (_.some(_.get(finding, 'FindingProviderFields.Types'), (type) => {
        var _a, _b;
        if (!_.startsWith(type, 'MITRE/SAF/')) {
            return false;
        }
        const version = (_b = (_a = type.split('/').pop()) === null || _a === void 0 ? void 0 : _a.split('-')[0]) !== null && _b !== void 0 ? _b : '';
        return (0, compare_versions_1.validate)(version) && (0, compare_versions_1.compare)(version, '2.6.20', '>');
    })) {
        return SpecialCasing.PreviouslyHDF;
    }
    else if (productArn.match(/^arn:[^:]+:securityhub:[^:]+:[^:]*:product\/aws\/inspector$/)) {
        return SpecialCasing.Inspector;
    }
    else if (productArn.match(/^arn:[^:]+:securityhub:[^:]+:[^:]*:product\/prowler\/prowler$/)) {
        return SpecialCasing.Prowler;
    }
    else if (productArn.match(/^arn:[^:]+:securityhub:[^:]+:[^:]*:product\/aws\/securityhub$/)) {
        return SpecialCasing.SecurityHub;
    }
    else if (productArn.match(/^arn:[^:]+:securityhub:[^:]+:[^:]*:product\/aquasecurity\/aquasecurity$/)) {
        return SpecialCasing.Trivy;
    }
    else {
        return SpecialCasing.Default;
    }
}
const SPECIAL_CASE_MAPPING = new Map([
    [SpecialCasing.CMSInSpec, (0, case_cms_inspec_1.getCMSInSpec)()],
    [SpecialCasing.FirewallManager, (0, case_firewall_manager_1.getFirewallManager)()],
    [SpecialCasing.GuardDuty, (0, case_guardduty_1.getGuardDuty)()],
    [SpecialCasing.Inspector, (0, case_inspector_1.getInspector)()],
    [SpecialCasing.PreviouslyHDF, (0, case_previously_hdf_1.getPreviouslyHDF)()],
    [SpecialCasing.Prowler, (0, case_prowler_1.getProwler)()],
    [SpecialCasing.SecurityHub, (0, case_security_hub_1.getSecurityHub)()],
    [SpecialCasing.Trivy, (0, case_trivy_1.getTrivy)()]
]);
function externalProductHandler(context, product, data, func, defaultVal) {
    var _a;
    if (product !== SpecialCasing.Default &&
        _.has(SPECIAL_CASE_MAPPING.get(product), func)) {
        let keywords = {};
        if (context.supportingDocs.has(product)) {
            keywords = { ...context.supportingDocs.get(product) };
        }
        return (_a = _.get(SPECIAL_CASE_MAPPING.get(product), func)) === null || _a === void 0 ? void 0 : _a.apply(context, [
            data,
            keywords
        ]);
    }
    else {
        if (typeof defaultVal === 'function') {
            return defaultVal();
        }
        else {
            return defaultVal;
        }
    }
}
function handleIdGroup(context, idGroup) {
    const [id, data] = idGroup;
    const group = data.map((d) => d[0]);
    const findings = data.map((d) => d[1]);
    const productInfo = _.get(findings[0], 'ProductArn')
        .split(':')
        .slice(-1)[0]
        .split('/');
    const productName = externalProductHandler(context, whichSpecialCase(findings[0]), findings, 'productName', (0, html_entities_1.encode)(`${productInfo[1]}/${productInfo[2]}`));
    const titlePrefix = externalProductHandler(context, whichSpecialCase(findings[0]), findings, 'titlePrefix', `${productName}: `);
    const waiverData = externalProductHandler(context, whichSpecialCase(findings[0]), group, 'waiverData', {});
    return {
        id: id,
        title: `${titlePrefix}${_.uniq(group.map((d) => d.title)).join(';')}`,
        tags: _.mergeWith({}, ...group.map((d) => d.tags), (acc, cur) => {
            if (acc === undefined || cur === undefined) {
                return acc || cur;
            }
            else {
                return Array.isArray(acc) || Array.isArray(cur)
                    ? _.uniq(_.concat([], acc, cur))
                    : acc;
            }
        }),
        impact: Math.max(...group.map((d) => d.impact)),
        desc: externalProductHandler(context, whichSpecialCase(findings[0]), group, 'desc', _.uniq(group.map((d) => d.desc)).join('\n')),
        descriptions: group
            .map((d) => d.descriptions)
            .flat()
            .filter((element, index, arr) => element &&
            element.data !== '' &&
            index ===
                arr.findIndex((e) => e !== null && e !== undefined && e.data === element.data)),
        refs: group
            .map((d) => d.refs)
            .flat()
            .filter((element) => _.get(element, 'url') !== undefined),
        source_location: (() => {
            const locs = _.uniq(group.map((d) => d.source_location)).filter((loc) => Object.keys(loc || {}).length !== 0);
            if (locs.length === 0) {
                return {};
            }
            else if (locs.length === 1) {
                return locs[0];
            }
            else {
                return { ref: JSON.stringify(locs) };
            }
        })(),
        ...(Object.keys(waiverData || {}).length !== 0 && {
            waiver_data: waiverData
        }),
        code: externalProductHandler(context, whichSpecialCase(findings[0]), group, 'code', JSON.stringify({ Findings: findings }, null, 2)),
        results: group.map((d) => d.results).flat()
    };
}
function consolidate(context, input, file) {
    const allFindings = _.get(file, 'Findings');
    if (input.length !== allFindings.length) {
        throw new Error('The number of generated controls should be the same as the number of findings while consolidating.');
    }
    const idGroups = _.groupBy(_.zip(input, allFindings), (value) => {
        const [hdfControl, asffFinding] = value;
        return externalProductHandler(context, whichSpecialCase(asffFinding), asffFinding, 'subfindingsId', _.get(hdfControl, 'id'));
    });
    return Object.entries(idGroups || {}).map((idGroup) => handleIdGroup(context, idGroup));
}
exports.consolidate = consolidate;
function wrapWithFindingsObject(output) {
    if (!_.has(output, 'Findings')) {
        if (Array.isArray(output)) {
            output = { Findings: output };
        }
        else {
            output = { Findings: [output] };
        }
    }
    return output;
}
function fixFileInput(asffJson) {
    let output = {};
    try {
        output = JSON.parse(asffJson);
    }
    catch {
        const fixedInput = `[${asffJson
            .trim()
            .replace(/}\n/g, '},\n')
            .replace(/\},\n\$/g, '')}]`;
        output = JSON.parse(fixedInput);
    }
    return wrapWithFindingsObject(output);
}
class ASFFMapper extends base_converter_1.BaseConverter {
    constructor(asff, supportingDocs, meta = undefined) {
        super(asff);
        this.defaultMappings = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version,
                target_id: {
                    transformer: (record) => {
                        const productInfo = _.get(record, 'Findings[0].ProductArn')
                            .split(':')
                            .slice(-1)[0]
                            .split('/');
                        const defaultTargetId = `${productInfo[1]} - ${productInfo[2]}`;
                        return externalProductHandler(this, whichSpecialCase(_.get(record, 'Findings[0]')), [_.get(record, 'Findings[0]'), record.Findings], 'productName', (0, html_entities_1.encode)(defaultTargetId));
                    }
                }
            },
            version: package_json_1.version,
            statistics: {
                duration: null
            },
            profiles: [
                {
                    name: {
                        transformer: () => {
                            var _a;
                            return ((_a = this.meta) === null || _a === void 0 ? void 0 : _a.name) || 'AWS Security Finding Format';
                        }
                    },
                    version: '',
                    title: {
                        transformer: () => {
                            return _.get(this.meta, 'title') || 'ASFF Findings';
                        }
                    },
                    maintainer: null,
                    summary: '',
                    license: null,
                    copyright: null,
                    copyright_email: null,
                    supports: [],
                    attributes: [],
                    depends: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: 'Findings',
                            key: 'id',
                            arrayTransformer: consolidate.bind(this, this),
                            id: {
                                transformer: (finding) => externalProductHandler(this, whichSpecialCase(finding), finding, 'findingId', (0, html_entities_1.encode)(_.get(finding, 'GeneratorId')))
                            },
                            title: {
                                transformer: (finding) => externalProductHandler(this, whichSpecialCase(finding), finding, 'findingTitle', (0, html_entities_1.encode)(_.get(finding, 'Title')))
                            },
                            desc: {
                                transformer: (finding) => externalProductHandler(this, whichSpecialCase(finding), finding, 'findingDescription', (0, html_entities_1.encode)(_.get(finding, 'Description')))
                            },
                            impact: {
                                transformer: (finding) => {
                                    let impact;
                                    if (_.get(finding, 'Workflow.Status') === 'SUPPRESSED') {
                                        impact = 'INFORMATIONAL';
                                    }
                                    else {
                                        const defaultFunc = () => _.get(finding, SEVERITY_LABEL)
                                            ? _.get(finding, SEVERITY_LABEL)
                                            : _.get(finding, 'Severity.Normalized') /
                                                100.0;
                                        impact = externalProductHandler(this, whichSpecialCase(finding), finding, 'findingImpact', defaultFunc);
                                    }
                                    return typeof impact === 'string'
                                        ? IMPACT_MAPPING.get(impact) || 0
                                        : impact;
                                }
                            },
                            tags: {
                                transformer: (finding) => externalProductHandler(this, whichSpecialCase(finding), finding, 'findingTags', {}),
                                cci: {
                                    transformer: (finding) => {
                                        const tags = externalProductHandler(this, whichSpecialCase(finding), finding, 'findingNistTag', []);
                                        if (tags.length === 0) {
                                            return (0, global_1.getCCIsForNISTTags)(global_1.DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS);
                                        }
                                        else {
                                            return (0, global_1.getCCIsForNISTTags)(tags);
                                        }
                                    }
                                },
                                nist: {
                                    transformer: (finding) => {
                                        const tags = externalProductHandler(this, whichSpecialCase(finding), finding, 'findingNistTag', []);
                                        if (tags.length === 0) {
                                            return global_1.DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS;
                                        }
                                        else {
                                            return tags;
                                        }
                                    }
                                }
                            },
                            descriptions: [
                                {
                                    data: {
                                        path: 'Remediation.Recommendation',
                                        transformer: (input) => {
                                            const data = [];
                                            if (_.has(input, 'Text')) {
                                                data.push(_.get(input, 'Text'));
                                            }
                                            if (_.has(input, 'Url')) {
                                                data.push(_.get(input, 'Url'));
                                            }
                                            return data.join('\n');
                                        }
                                    },
                                    label: 'fix'
                                }
                            ],
                            refs: [
                                {
                                    transformer: (finding) => {
                                        return {
                                            ...(_.has(finding, 'SourceUrl') && {
                                                url: _.get(finding, 'SourceUrl')
                                            })
                                        };
                                    }
                                }
                            ],
                            source_location: {},
                            code: '',
                            results: [
                                {
                                    status: {
                                        transformer: (finding) => {
                                            const defaultFunc = () => {
                                                if (_.has(finding, COMPLIANCE_STATUS)) {
                                                    switch (_.get(finding, COMPLIANCE_STATUS)) {
                                                        case 'PASSED':
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Passed;
                                                        case 'WARNING':
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
                                                        case 'FAILED':
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
                                                        case 'NOT_AVAILABLE':
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
                                                        default:
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Error;
                                                    }
                                                }
                                                else {
                                                    return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
                                                }
                                            };
                                            return externalProductHandler(this, whichSpecialCase(finding), finding, 'subfindingsStatus', defaultFunc);
                                        }
                                    },
                                    code_desc: {
                                        transformer: (finding) => {
                                            let output = externalProductHandler(this, whichSpecialCase(finding), finding, 'subfindingsCodeDesc', '');
                                            if (output) {
                                                output += '; ';
                                            }
                                            const resources = _.get(finding, 'Resources')
                                                .map((resource) => {
                                                let hash = `Type: ${(0, html_entities_1.encode)(_.get(resource, 'Type'))}, Id: ${(0, html_entities_1.encode)(_.get(resource, 'Id'))}`;
                                                if (_.has(resource, 'Partition')) {
                                                    hash += `, Partition: ${(0, html_entities_1.encode)(_.get(resource, 'Partition'))}`;
                                                }
                                                if (_.has(resource, 'Region')) {
                                                    hash += `, Region: ${(0, html_entities_1.encode)(_.get(resource, 'Region'))}`;
                                                }
                                                return hash;
                                            })
                                                .join(', ');
                                            output += `Resources: [${resources}]`;
                                            return output;
                                        }
                                    },
                                    transformer: (finding) => {
                                        const message = (() => {
                                            const defaultFunc = () => {
                                                const statusReason = this.statusReason(finding);
                                                switch (_.get(finding, COMPLIANCE_STATUS)) {
                                                    case undefined:
                                                        return undefined;
                                                    case 'PASSED':
                                                        return statusReason;
                                                    case 'WARNING':
                                                        return undefined;
                                                    case 'FAILED':
                                                        return statusReason;
                                                    case 'NOT_AVAILABLE':
                                                        return undefined;
                                                    default:
                                                        return statusReason;
                                                }
                                            };
                                            return externalProductHandler(this, whichSpecialCase(finding), finding, 'subfindingsMessage', defaultFunc);
                                        })();
                                        const skipMessage = (() => {
                                            const statusReason = this.statusReason(finding);
                                            switch (_.get(finding, COMPLIANCE_STATUS)) {
                                                case undefined:
                                                    return statusReason;
                                                case 'PASSED':
                                                    return undefined;
                                                case 'WARNING':
                                                    return statusReason;
                                                case 'FAILED':
                                                    return undefined;
                                                case 'NOT_AVAILABLE':
                                                    return statusReason;
                                                default:
                                                    return undefined;
                                            }
                                        })();
                                        return {
                                            ...(message !== undefined && { message }),
                                            ...(skipMessage !== undefined && {
                                                skip_message: skipMessage
                                            })
                                        };
                                    },
                                    start_time: {
                                        transformer: (finding) => _.get(finding, 'LastObservedAt') ||
                                            _.get(finding, 'UpdatedAt')
                                    }
                                }
                            ]
                        }
                    ],
                    sha256: ''
                }
            ]
        };
        this.meta = meta;
        this.supportingDocs = supportingDocs;
        this.setMappings();
    }
    statusReason(finding) {
        const statusReasons = _.get(finding, 'Compliance.StatusReasons');
        if (statusReasons !== undefined &&
            statusReasons !== null &&
            _.isArray(statusReasons)) {
            return statusReasons
                .map((reason) => Object.entries(reason || {}).map(([key, value]) => {
                return `${(0, html_entities_1.encode)(key)}: ${(0, html_entities_1.encode)(value)}`;
            }))
                .flat()
                .join('\n');
        }
        else {
            return undefined;
        }
    }
    setMappings() {
        this.mappings = externalProductHandler(this, whichSpecialCase(_.get(this.data, 'Findings[0]')), this, 'mapping', this.defaultMappings);
    }
}
exports.ASFFMapper = ASFFMapper;
class ASFFResults {
    constructor(asffJson, securityhubStandardsJsonArray = undefined, meta = undefined) {
        this.meta = meta;
        this.supportingDocs = new Map();
        this.supportingDocs.set(SpecialCasing.SecurityHub, _.get(SPECIAL_CASE_MAPPING.get(SpecialCasing.SecurityHub), 'securityhubSupportingDocs', (standards) => {
            throw new Error(`supportingDocs function should've been defined: ${standards}`);
        })(securityhubStandardsJsonArray));
        const findings = _.get(fixFileInput(asffJson), 'Findings');
        this.data = _.groupBy(findings, (finding) => {
            const productInfo = _.get(finding, 'ProductArn')
                .split(':')
                .slice(-1)[0]
                .split('/');
            const defaultFilename = `${productInfo[1]} - ${productInfo[2]}.json`;
            return externalProductHandler(this, whichSpecialCase(finding), [finding, findings], 'filename', (0, html_entities_1.encode)(defaultFilename));
        });
    }
    toHdf() {
        return _.mapValues(this.data, (val) => {
            const wrapped = wrapWithFindingsObject(val);
            return new ASFFMapper(externalProductHandler(this, whichSpecialCase(_.get(wrapped, 'Findings[0]')), wrapped, 'preprocessingASFF', wrapped), externalProductHandler(this, whichSpecialCase(_.get(wrapped, 'Findings[0]')), [wrapped, this.supportingDocs], 'supportingDocs', this.supportingDocs), externalProductHandler(this, whichSpecialCase(_.get(wrapped, 'Findings[0]')), undefined, 'meta', this.meta)).toHdf();
        });
    }
}
exports.ASFFResults = ASFFResults;
//# sourceMappingURL=asff-mapper.js.map