"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CycloneDXSBOMMapper = exports.CycloneDXSBOMResults = void 0;
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const CweNistMapping_1 = require("./mappings/CweNistMapping");
const global_1 = require("./utils/global");
const cvssMethods = ['CVSSv2', 'CVSSv3', 'CVSSv31', 'CVSSv4'];
const CWE_NIST_MAPPING = new CweNistMapping_1.CweNistMapping();
const DEFAULT_NIST_TAG = ['SI-2', 'RA-5'];
const IMPACT_MAPPING = new Map([
    ['critical', 1.0],
    ['high', 0.7],
    ['medium', 0.5],
    ['low', 0.3],
    ['info', 0.5],
    ['none', 0.0],
    ['unknown', 0.5]
]);
function formatCWETags(input, addPrefix = true) {
    return input && Array.isArray(input)
        ? input.map((cwe) => (addPrefix ? `CWE-${cwe}` : `${cwe}`))
        : [];
}
function getNISTTags(input) {
    return CWE_NIST_MAPPING.nistFilter(formatCWETags(input, false), DEFAULT_NIST_TAG);
}
function maxImpact(ratings) {
    return ratings
        .map((rating) => {
        var _a, _b, _c;
        return rating.score &&
            rating.method &&
            cvssMethods.includes(rating.method)
            ?
                rating.score / 10
            :
                ((_c = IMPACT_MAPPING.get((_b = (_a = rating.severity) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : '')) !== null && _c !== void 0 ? _c : 0.5);
    })
        .reduce((maxValue, newValue) => maxValue > newValue ? maxValue : newValue, 0);
}
function skipSeverityInfoOrUnknown(controls) {
    if (controls) {
        controls
            .filter((control) => {
            const ratings = lodash_1.default.get(control, 'tags.ratings', '').split(/ - |, /);
            return ((ratings.includes('info') || ratings.includes('unknown')) &&
                !(ratings.includes('critical') ||
                    ratings.includes('high') ||
                    ratings.includes('medium') ||
                    ratings.includes('low') ||
                    ratings.includes('none')));
        })
            .map((control) => control.results.map((result) => {
            result.status = inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
            result.skip_message =
                'Manual review required because a CycloneDX rating severity is set to `info` or `unknown`.';
        }));
    }
    return controls;
}
class CycloneDXSBOMResults {
    constructor(sbomJson, withRaw = false) {
        this.data = {
            components: [],
            vulnerabilities: [],
            raw: JSON.parse(sbomJson)
        };
        this.withRaw = withRaw;
        if (this.data.raw.components) {
            this.flattenComponents(this.data);
            if (this.data.raw.vulnerabilities) {
                this.generateIntermediary(this.data);
            }
        }
        else if (this.data.raw.vulnerabilities) {
            this.formatVEX(this.data);
        }
        else {
            throw new Error('Unrecognized CycloneDX format detected. We currently only support SBOM and VEX formats.');
        }
    }
    flattenComponents(data) {
        data.components = lodash_1.default.cloneDeep(data.raw.components);
        for (const component of data.components) {
            if (component.components) {
                data.components.push(...component.components);
                delete component.components;
            }
        }
    }
    generateIntermediary(data) {
        data.vulnerabilities = lodash_1.default.cloneDeep(data.raw.vulnerabilities);
        for (const vulnerability of data.vulnerabilities) {
            vulnerability.affectedComponents = [];
            vulnerability.affectedComponents.push(...Array.from(data.components.entries())
                .filter(([_index, component]) => {
                var _a;
                return (_a = vulnerability.affects) === null || _a === void 0 ? void 0 : _a.map((id) => id.ref.toString()).includes(component['bom-ref']);
            })
                .map(([index, _component]) => index));
            for (const index of vulnerability.affectedComponents) {
                if (!data.components[index].affectingVulnerabilities) {
                    data.components[index].affectingVulnerabilities = [];
                }
                data.components[index].affectingVulnerabilities.push(lodash_1.default.get(vulnerability, 'bom-ref'));
            }
        }
    }
    formatVEX(data) {
        var _a;
        data.vulnerabilities = [
            ...lodash_1.default.cloneDeep(data.raw.vulnerabilities)
        ];
        for (const vulnerability of data.vulnerabilities) {
            vulnerability.affectedComponents = (_a = vulnerability.affects) === null || _a === void 0 ? void 0 : _a.map((id) => {
                const dummy = {
                    name: `${id.ref}`,
                    'bom-ref': `${id.ref}`,
                    isDummy: true,
                    type: 'application'
                };
                data.components.push(dummy);
                return data.components.length - 1;
            });
        }
    }
    toHdf() {
        return new CycloneDXSBOMMapper(this.data, this.withRaw).toHdf();
    }
}
exports.CycloneDXSBOMResults = CycloneDXSBOMResults;
class CycloneDXSBOMMapper extends base_converter_1.BaseConverter {
    getComponentValueAtIndex(index, keys) {
        return lodash_1.default.pick(this.data.components[index], keys);
    }
    constructor(exportJson, withRaw = false) {
        super(exportJson, true);
        this.mappings = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version
            },
            version: package_json_1.version,
            statistics: {},
            profiles: [
                {
                    name: {
                        path: 'raw.metadata.component',
                        transformer: (input) => lodash_1.default.has(input, 'bom-ref')
                            ? `CycloneDX BOM Report: ${input.type}/${input['bom-ref']}`
                            : 'CycloneDX BOM Report'
                    },
                    title: {
                        path: 'raw.metadata.component',
                        transformer: (input) => {
                            if (input.name) {
                                const group = input.group ? `${input.group}/` : '';
                                return `${group}${input.name} CycloneDX BOM Report`;
                            }
                            else {
                                return 'CycloneDX BOM Report';
                            }
                        }
                    },
                    version: {
                        path: 'raw.metadata.component.version',
                        transformer: global_1.filterString
                    },
                    maintainer: {
                        path: 'raw.metadata.component',
                        transformer: (input) => {
                            const manufacturer = lodash_1.default.has(input, 'manufacturer')
                                ? ` (${input.manufacturer.name})`
                                : '';
                            if (lodash_1.default.has(input, 'authors')) {
                                return input.authors
                                    .map((author) => `${author.name}${manufacturer}`)
                                    .join(', ');
                            }
                            else if (input.author) {
                                return `${input.author}${manufacturer}`;
                            }
                            else {
                                return undefined;
                            }
                        }
                    },
                    summary: {
                        path: 'raw.metadata.component.description',
                        transformer: global_1.filterString
                    },
                    copyright: {
                        path: 'raw.metadata.component.copyright',
                        transformer: global_1.filterString
                    },
                    license: {
                        path: 'raw.metadata.component',
                        transformer: (input) => {
                            var _a;
                            if (!input.licenses) {
                                return undefined;
                            }
                            return (_a = input.licenses) === null || _a === void 0 ? void 0 : _a.map((license) => {
                                var _a, _b;
                                return ((_a = license === null || license === void 0 ? void 0 : license.license) === null || _a === void 0 ? void 0 : _a.name)
                                    ? license.license.name
                                    : (_b = license === null || license === void 0 ? void 0 : license.license) === null || _b === void 0 ? void 0 : _b.id;
                            }).filter((identifier) => identifier).join(', ');
                        }
                    },
                    supports: [],
                    attributes: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: 'vulnerabilities',
                            key: 'id',
                            tags: {
                                nist: {
                                    path: 'cwes',
                                    transformer: getNISTTags
                                },
                                cci: {
                                    path: 'cwes',
                                    transformer: (input) => (0, global_1.getCCIsForNISTTags)(getNISTTags(input))
                                },
                                cwe: { path: 'cwes', transformer: formatCWETags },
                                'bom-ref': {
                                    path: 'bom-ref',
                                    transformer: global_1.filterString
                                },
                                ratings: {
                                    path: 'ratings',
                                    transformer: (input) => input
                                        ? [...input]
                                            .map((rating) => {
                                            var _a, _b;
                                            const ratingSource = ((_a = rating.source) === null || _a === void 0 ? void 0 : _a.name)
                                                ? `${(_b = rating.source) === null || _b === void 0 ? void 0 : _b.name} - `
                                                : 'Unidentified Source - ';
                                            return `${ratingSource}${rating.severity}`;
                                        })
                                            .join(', ')
                                        : undefined
                                },
                                created: {
                                    path: 'created',
                                    transformer: global_1.filterString
                                },
                                published: {
                                    path: 'published',
                                    transformer: global_1.filterString
                                },
                                updated: {
                                    path: 'updated',
                                    transformer: global_1.filterString
                                },
                                rejected: {
                                    path: 'rejected',
                                    transformer: global_1.filterString
                                },
                                credits: {
                                    path: 'credits',
                                    transformer: (input) => {
                                        var _a;
                                        return input
                                            ? `${(_a = input.individuals) === null || _a === void 0 ? void 0 : _a.map((individual) => individual.name).filter((name) => name).join(', ')}`
                                            : undefined;
                                    }
                                },
                                tools: {
                                    path: 'tools',
                                    transformer: (input) => {
                                        var _a, _b, _c, _d;
                                        if (!input) {
                                            return undefined;
                                        }
                                        if (Array.isArray(input)) {
                                            return input
                                                .map((tool) => tool.name)
                                                .filter((name) => name)
                                                .join(', ');
                                        }
                                        return [
                                            ...((_b = (_a = input.components) === null || _a === void 0 ? void 0 : _a.map((component) => component.name)) !== null && _b !== void 0 ? _b : []),
                                            ...((_d = (_c = input.services) === null || _c === void 0 ? void 0 : _c.map((component) => component.name)) !== null && _d !== void 0 ? _d : [])
                                        ].join(', ');
                                    }
                                },
                                'analysis.state': {
                                    path: 'analysis.state',
                                    transformer: global_1.filterString
                                },
                                'analysis.justification': {
                                    path: 'analysis.justification',
                                    transformer: global_1.filterString
                                },
                                'analysis.response': {
                                    path: 'analysis.response',
                                    transformer: (input) => input && input.length > 0 ? input.join(', ') : undefined
                                },
                                'analysis.detail': {
                                    path: 'analysis.detail',
                                    transformer: global_1.filterString
                                },
                                'analysis.firstIssued': {
                                    path: 'analysis.firstIssued',
                                    transformer: global_1.filterString
                                },
                                'analysis.lastUpdated': {
                                    path: 'analysis.lastUpdated',
                                    transformer: global_1.filterString
                                }
                            },
                            descriptions: {
                                transformer: (input) => {
                                    const recommendation = input.recommendation
                                        ? `Recommendation: ${input.recommendation}`
                                        : '';
                                    const workaround = lodash_1.default.has(input, 'workaround')
                                        ? `Workaround: ${input.workaround}`
                                        : '';
                                    return [
                                        recommendation || workaround
                                            ? {
                                                data: `${recommendation}\n\n${workaround}`.trim(),
                                                label: 'fix'
                                            }
                                            : undefined,
                                        lodash_1.default.has(input, 'proofOfConcept')
                                            ? {
                                                data: `Proof of concept: ${JSON.stringify(lodash_1.default.get(input, 'proofOfConcept'), null, 2)}`,
                                                label: 'check'
                                            }
                                            : undefined
                                    ].filter((subdescription) => subdescription);
                                }
                            },
                            refs: [
                                {
                                    transformer: (input) => {
                                        const searchFor = ['source', 'references', 'advisories'];
                                        const ref = searchFor
                                            .filter((key) => input.hasOwnProperty(key))
                                            .map((key) => lodash_1.default.pick(input, key));
                                        return { ref: ref };
                                    }
                                }
                            ],
                            source_location: {},
                            title: {
                                transformer: (input) => input.description ? `${input.description}` : `${input.id}`
                            },
                            id: { path: 'id' },
                            desc: {
                                transformer: (input) => {
                                    const description = input.description
                                        ? `Description: ${input.description}`
                                        : '';
                                    const detail = input.detail ? `Detail: ${input.detail}` : '';
                                    return (0, global_1.filterString)(`${description}\n\n${detail}`.trim());
                                }
                            },
                            impact: {
                                transformer: (input) => { var _a; return maxImpact((_a = input.ratings) !== null && _a !== void 0 ? _a : []); }
                            },
                            code: {
                                transformer: (vulnerability) => JSON.stringify(lodash_1.default.omit(vulnerability, 'affectedComponents'), null, 2)
                            },
                            arrayTransformer: skipSeverityInfoOrUnknown,
                            results: [
                                {
                                    path: 'affectedComponents',
                                    status: inspecjs_1.ExecJSON.ControlResultStatus.Failed,
                                    code_desc: {
                                        transformer: (index) => {
                                            const selectComponentValues = this.getComponentValueAtIndex(index, ['group', 'version', 'name']);
                                            const group = lodash_1.default.has(selectComponentValues, 'group')
                                                ? `${selectComponentValues.group}/`
                                                : '';
                                            const version = lodash_1.default.has(selectComponentValues, 'version')
                                                ? `@${selectComponentValues.version}`
                                                : '';
                                            return `Component ${group}${lodash_1.default.get(selectComponentValues, 'name')}${version} is vulnerable`;
                                        }
                                    },
                                    message: {
                                        transformer: (index) => {
                                            const selectComponentValues = this.getComponentValueAtIndex(index, [
                                                'type',
                                                'mime-type',
                                                'bom-ref',
                                                'supplier',
                                                'manufacturer',
                                                'authors',
                                                'author',
                                                'publisher',
                                                'group',
                                                'name',
                                                'version',
                                                'description',
                                                'licenses',
                                                'copyright'
                                            ]);
                                            const msg = Object.keys(selectComponentValues)
                                                .map((key) => {
                                                return Array.isArray(selectComponentValues[key])
                                                    ? `\n\n- ${lodash_1.default.capitalize(key)}: ${JSON.stringify(selectComponentValues[key], null, 2)}`
                                                    : `\n\n- ${lodash_1.default.capitalize(key)}: ${selectComponentValues[key]}`;
                                            })
                                                .join('');
                                            return `-Component Summary-${msg}`;
                                        }
                                    },
                                    start_time: ''
                                }
                            ]
                        }
                    ],
                    sha256: ''
                }
            ],
            passthrough: {
                transformer: (input) => {
                    const components = input.components.filter((component) => !component.isDummy);
                    return {
                        auxiliary_data: [
                            {
                                name: 'SBOM',
                                components: components.length ? components : undefined,
                                dependencies: lodash_1.default.get(input, 'raw.dependencies'),
                                data: lodash_1.default.omit(input.raw, [
                                    'components',
                                    'vulnerabilities',
                                    'dependencies'
                                ])
                            }
                        ],
                        ...(this.withRaw && { raw: input.raw })
                    };
                }
            }
        };
        this.withRaw = withRaw;
    }
}
exports.CycloneDXSBOMMapper = CycloneDXSBOMMapper;
//# sourceMappingURL=cyclonedx-sbom-mapper.js.map