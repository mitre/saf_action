"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASFFResults = exports.ASFFMapper = void 0;
const html_entities_1 = require("html-entities");
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const AwsConfigMapping_1 = require("./mappings/AwsConfigMapping");
const IMPACT_MAPPING = new Map([
    ['CRITICAL', 0.9],
    ['HIGH', 0.7],
    ['MEDIUM', 0.5],
    ['LOW', 0.3],
    ['INFORMATIONAL', 0.0]
]);
const DEFAULT_NIST_TAG = ['SA-11', 'RA-5'];
const SEVERITY_LABEL = 'Severity.Label';
const COMPLIANCE_STATUS = 'Compliance.Status';
var SpecialCasing;
(function (SpecialCasing) {
    SpecialCasing["FirewallManager"] = "AWS Firewall Manager";
    SpecialCasing["Prowler"] = "Prowler";
    SpecialCasing["SecurityHub"] = "AWS Security Hub";
    SpecialCasing["Trivy"] = "Aqua Trivy";
    SpecialCasing["HDF2ASFF"] = "MITRE SAF HDF2ASFF";
    SpecialCasing["Default"] = "Default";
})(SpecialCasing || (SpecialCasing = {}));
function whichSpecialCase(finding) {
    const productArn = lodash_1.default.get(finding, 'ProductArn');
    if (!productArn) {
        console.trace(finding, productArn);
    }
    if (productArn.match(/^arn:[^:]+:securityhub:[^:]+:[^:]*:product\/aws\/firewall-manager$/)) {
        return SpecialCasing.FirewallManager;
    }
    else if (productArn.match(/^arn:[^:]+:securityhub:[^:]+:[^:]*:product\/prowler\/prowler$/)) {
        return SpecialCasing.Prowler;
    }
    else if (productArn.match(/^arn:[^:]+:securityhub:[^:]+:[^:]*:product\/aws\/securityhub$/)) {
        return SpecialCasing.SecurityHub;
    }
    else if (productArn.match(/^arn:[^:]+:securityhub:[^:]+:[^:]*:product\/aquasecurity\/aquasecurity$/)) {
        return SpecialCasing.Trivy;
    }
    else if (lodash_1.default.some(lodash_1.default.get(finding, 'FindingProviderFields.Types'), (type) => {
        const version = type.split('/')[2].split('-')[0];
        const [major, minor, patch] = version.split('.');
        if (parseInt(major) > 1 &&
            parseInt(minor) > 5 &&
            parseInt(patch) > 20) {
            return lodash_1.default.startsWith(type, 'MITRE/SAF/');
        }
        else {
            return false;
        }
    })) {
        return SpecialCasing.HDF2ASFF;
    }
    else {
        return SpecialCasing.Default;
    }
}
const SPECIAL_CASE_MAPPING = new Map([
    [SpecialCasing.FirewallManager, getFirewallManager()],
    [SpecialCasing.Prowler, getProwler()],
    [SpecialCasing.SecurityHub, getSecurityHub()],
    [SpecialCasing.Trivy, getTrivy()],
    [SpecialCasing.HDF2ASFF, getHDF2ASFF()]
]);
function externalProductHandler(context, product, data, func, defaultVal) {
    var _a;
    if (product !== SpecialCasing.Default &&
        lodash_1.default.has(SPECIAL_CASE_MAPPING.get(product), func)) {
        let keywords = {};
        if (context.supportingDocs.has(product)) {
            keywords = { ...context.supportingDocs.get(product) };
        }
        return (_a = lodash_1.default.get(SPECIAL_CASE_MAPPING.get(product), func)) === null || _a === void 0 ? void 0 : _a.apply(context, [
            data,
            keywords
        ]);
    }
    else {
        if (typeof defaultVal === 'function') {
            return defaultVal();
        }
        else {
            return defaultVal;
        }
    }
}
function consolidate(context, input, file) {
    const allFindings = lodash_1.default.get(file, 'Findings');
    if (input.length !== allFindings.length) {
        throw new Error('The number of generated controls should be the same as the number of findings at this point in the process.');
    }
    const idGroups = lodash_1.default.groupBy(lodash_1.default.zip(input, allFindings), (value) => {
        const [hdfControl, asffFinding] = value;
        return externalProductHandler(context, whichSpecialCase(asffFinding), asffFinding, 'subfindingsId', lodash_1.default.get(hdfControl, 'id'));
    });
    const output = [];
    Object.entries(idGroups || {}).forEach((idGroup) => {
        const [id, data] = idGroup;
        const group = data.map((d) => d[0]);
        const findings = data.map((d) => d[1]);
        const productInfo = lodash_1.default.get(findings[0], 'ProductArn')
            .split(':')
            .slice(-1)[0]
            .split('/');
        const productName = externalProductHandler(context, whichSpecialCase(findings[0]), findings, 'productName', (0, html_entities_1.encode)(`${productInfo[1]}/${productInfo[2]}`));
        const hasNoTitlePrefix = externalProductHandler(context, whichSpecialCase(findings[0]), null, 'doesNotHaveFindingTitlePrefix', false);
        const titlePrefix = hasNoTitlePrefix ? '' : `${productName}: `;
        const waiverData = externalProductHandler(context, whichSpecialCase(findings[0]), group, 'waiverData', {});
        const item = {
            id: id,
            title: `${titlePrefix}${lodash_1.default.uniq(group.map((d) => d.title)).join(';')}`,
            tags: lodash_1.default.mergeWith({}, ...group.map((d) => d.tags), (acc, cur) => {
                if (acc === undefined || cur === undefined) {
                    return acc || cur;
                }
                else if (lodash_1.default.isEqual(acc, cur)) {
                    return acc;
                }
                else {
                    return lodash_1.default.uniq(lodash_1.default.concat([], acc, cur));
                }
            }),
            impact: Math.max(...group.map((d) => d.impact)),
            desc: externalProductHandler(context, whichSpecialCase(findings[0]), group, 'desc', lodash_1.default.uniq(group.map((d) => d.desc)).join('\n')),
            descriptions: group
                .map((d) => d.descriptions)
                .flat()
                .filter((element, index, arr) => element !== null &&
                element !== undefined &&
                element.data !== '' &&
                index ===
                    arr.findIndex((e) => e !== null && e !== undefined && e.data === element.data)),
            refs: group
                .map((d) => d.refs)
                .flat()
                .filter((element) => lodash_1.default.get(element, 'url') !== undefined),
            source_location: (() => {
                const locs = lodash_1.default.uniq(group.map((d) => d.source_location)).filter((loc) => Object.keys(loc || {}).length !== 0);
                if (locs.length === 0) {
                    return {};
                }
                else if (locs.length === 1) {
                    return locs[0];
                }
                else {
                    return { ref: JSON.stringify(locs) };
                }
            })(),
            ...(Object.keys(waiverData || {}).length !== 0 && {
                waiver_data: waiverData
            }),
            code: externalProductHandler(context, whichSpecialCase(findings[0]), group, 'code', JSON.stringify({ Findings: findings }, null, 2)),
            results: group.map((d) => d.results).flat()
        };
        output.push(item);
    });
    return output;
}
function wrapWithFindingsObject(output) {
    if (!lodash_1.default.has(output, 'Findings')) {
        if (Array.isArray(output)) {
            output = { Findings: output };
        }
        else {
            output = { Findings: [output] };
        }
    }
    return output;
}
function fixFileInput(asffJson) {
    let output = {};
    try {
        output = JSON.parse(asffJson);
    }
    catch {
        const fixedInput = `[${asffJson
            .trim()
            .replace(/}\n/g, '},\n')
            .replace(/\},\n\$/g, '')}]`;
        output = JSON.parse(fixedInput);
    }
    return wrapWithFindingsObject(output);
}
function getFirewallManager() {
    const findingId = (finding) => (0, html_entities_1.encode)(lodash_1.default.get(finding, 'Title'));
    const productName = (findings) => {
        const finding = Array.isArray(findings) ? findings[0] : findings;
        return (0, html_entities_1.encode)(`${lodash_1.default.get(finding, 'ProductFields.aws/securityhub/CompanyName')} ${lodash_1.default.get(finding, 'ProductFields.aws/securityhub/ProductName')}`);
    };
    const filename = (findingInfo) => {
        return `${productName(findingInfo[1])}.json`;
    };
    return {
        findingId,
        productName,
        filename
    };
}
function getProwler() {
    const subfindingsCodeDesc = (finding) => (0, html_entities_1.encode)(lodash_1.default.get(finding, 'Description'));
    const findingId = (finding) => {
        const generatorId = lodash_1.default.get(finding, 'GeneratorId');
        const hyphenIndex = generatorId.indexOf('-');
        return (0, html_entities_1.encode)(generatorId.slice(hyphenIndex + 1));
    };
    const productName = (findings) => {
        const finding = Array.isArray(findings) ? findings[0] : findings;
        return (0, html_entities_1.encode)(lodash_1.default.get(finding, 'ProductFields.ProviderName'));
    };
    const desc = () => ' ';
    const filename = (findingInfo) => {
        return `${productName(findingInfo[1])}.json`;
    };
    const meta = () => {
        return { name: 'Prowler', title: 'Prowler Findings' };
    };
    return {
        subfindingsCodeDesc,
        findingId,
        productName,
        desc,
        filename,
        meta
    };
}
function getSecurityHub() {
    const FINDING_STANDARDS_CONTROL_ARN = 'ProductFields.StandardsControlArn';
    const correspondingControl = (controls, finding) => {
        return controls.find((control) => lodash_1.default.get(control, 'StandardsControlArn') ===
            lodash_1.default.get(finding, FINDING_STANDARDS_CONTROL_ARN));
    };
    const securityhubSupportingDocs = (standards) => {
        let controls;
        try {
            if (Array.isArray(standards)) {
                controls = standards
                    .map((standard) => lodash_1.default.get(JSON.parse(standard), 'Controls'))
                    .flat();
            }
            else {
                controls = null;
            }
        }
        catch (error) {
            throw new Error(`Invalid supporting docs for Security Hub:\nException: ${error}`);
        }
        const AWS_CONFIG_MAPPING = new AwsConfigMapping_1.AwsConfigMapping();
        return {
            controls,
            awsConfigMapping: AWS_CONFIG_MAPPING
        };
    };
    const findingId = (finding, { controls = null }) => {
        let output;
        let control;
        if (controls !== null &&
            (control = correspondingControl(controls, finding)) !== null) {
            output = lodash_1.default.get(control, 'ControlId');
        }
        else if (lodash_1.default.has(finding, 'ProductFields.ControlId')) {
            output = lodash_1.default.get(finding, 'ProductFields.ControlId');
        }
        else if (lodash_1.default.has(finding, 'ProductFields.RuleId')) {
            output = lodash_1.default.get(finding, 'ProductFields.RuleId');
        }
        else {
            output = lodash_1.default.get(finding, 'GeneratorId').split('/').slice(-1)[0];
        }
        return (0, html_entities_1.encode)(output);
    };
    const findingImpact = (finding, { controls = null }) => {
        let impact;
        let control;
        if (controls !== null &&
            (control = correspondingControl(controls, finding)) !== null) {
            impact = lodash_1.default.get(control, 'SeverityRating');
        }
        else {
            impact =
                lodash_1.default.get(finding, SEVERITY_LABEL) ||
                    lodash_1.default.get(finding, 'Severity.Normalized') / 100.0;
            if (typeof impact === 'string' && impact === 'INFORMATIONAL') {
                impact = 'MEDIUM';
            }
        }
        return impact;
    };
    const findingNistTag = (finding, { awsConfigMapping }) => {
        if (lodash_1.default.get(finding, 'ProductFields.RelatedAWSResources:0/type') !==
            'AWS::Config::ConfigRule') {
            return [];
        }
        return awsConfigMapping.searchNIST([
            lodash_1.default.get(finding, 'ProductFields.RelatedAWSResources:0/name')
        ]);
    };
    const findingTitle = (finding, { controls = null }) => {
        let control;
        if (controls !== null &&
            (control = correspondingControl(controls, finding)) !== null) {
            return (0, html_entities_1.encode)(lodash_1.default.get(control, 'Title'));
        }
        else {
            return (0, html_entities_1.encode)(lodash_1.default.get(finding, 'Title'));
        }
    };
    const productName = (findings) => {
        const finding = Array.isArray(findings) ? findings[0] : findings;
        let standardName;
        if (lodash_1.default.get(finding, 'Types[0]')
            .split('/')
            .slice(-1)[0]
            .replace(/-/gi, ' ')
            .toLowerCase() ===
            lodash_1.default.get(finding, FINDING_STANDARDS_CONTROL_ARN)
                .split('/')
                .slice(-4)[0]
                .replace(/-/gi, ' ')
                .toLowerCase()) {
            standardName = lodash_1.default.get(finding, 'Types[0]')
                .split('/')
                .slice(-1)[0]
                .replace(/-/gi, ' ');
        }
        else {
            standardName = lodash_1.default.get(finding, FINDING_STANDARDS_CONTROL_ARN)
                .split('/')
                .slice(-4)[0]
                .replace(/-/gi, ' ')
                .split(/\s+/)
                .map((element) => {
                return element.charAt(0).toUpperCase() + element.slice(1);
            })
                .join(' ');
        }
        return (0, html_entities_1.encode)(`${standardName} v${lodash_1.default.get(finding, FINDING_STANDARDS_CONTROL_ARN)
            .split('/')
            .slice(-2)[0]}`);
    };
    const filename = (findingInfo) => {
        return `${productName(findingInfo[0])}.json`;
    };
    return {
        securityhubSupportingDocs,
        findingId,
        findingImpact,
        findingNistTag,
        findingTitle,
        productName,
        filename
    };
}
function getTrivy() {
    const findingId = (finding) => {
        const generatorId = lodash_1.default.get(finding, 'GeneratorId');
        const cveId = lodash_1.default.get(finding, 'Resources[0].Details.Other.CVE ID');
        if (typeof cveId === 'string') {
            return (0, html_entities_1.encode)(`${generatorId}/${cveId}`);
        }
        else {
            const id = lodash_1.default.get(finding, 'Id');
            return (0, html_entities_1.encode)(`${generatorId}/${id}`);
        }
    };
    const findingNistTag = (finding) => {
        const cveId = lodash_1.default.get(finding, 'Resources[0].Details.Other.CVE ID');
        if (typeof cveId === 'string') {
            return ['SI-2', 'RA-5'];
        }
        else {
            return [];
        }
    };
    const subfindingsStatus = () => {
        return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
    };
    const subfindingsMessage = (finding) => {
        const cveId = lodash_1.default.get(finding, 'Resources[0].Details.Other.CVE ID');
        if (typeof cveId === 'string') {
            const patchedPackage = lodash_1.default.get(finding, 'Resources[0].Details.Other.Patched Package');
            const patchedVersionMessage = patchedPackage.length === 0
                ? 'There is no patched version of the package.'
                : `The package has been patched since version(s): ${patchedPackage}.`;
            return `For package ${lodash_1.default.get(finding, 'Resources[0].Details.Other.PkgName')}, the current version that is installed is ${lodash_1.default.get(finding, 'Resources[0].Details.Other.Installed Package')}.  ${patchedVersionMessage}`;
        }
        else {
            return undefined;
        }
    };
    const productName = () => {
        return 'Aqua Security - Trivy';
    };
    const doesNotHaveFindingTitlePrefix = () => true;
    const filename = () => {
        return `${productName()}.json`;
    };
    const meta = () => {
        return { name: 'Trivy', title: 'Trivy Findings' };
    };
    return {
        findingId,
        findingNistTag,
        subfindingsStatus,
        subfindingsMessage,
        doesNotHaveFindingTitlePrefix,
        productName,
        filename,
        meta
    };
}
function getHDF2ASFF() {
    const replaceTypesSlashes = (type) => {
        if (!lodash_1.default.isString(type)) {
            return type;
        }
        const FROM_ASFF_TYPES_SLASH_REPLACEMENT = /{{{SLASH}}}/gi;
        return type.replace(FROM_ASFF_TYPES_SLASH_REPLACEMENT, '/');
    };
    const objectifyTypesArray = (typesArray) => {
        if (!Array.isArray(typesArray)) {
            typesArray = lodash_1.default.get(typesArray, 'FindingProviderFields.Types');
        }
        const ret = {};
        for (const typeString of typesArray) {
            lodash_1.default.merge(ret, (() => {
                const [type, attribute, value] = typeString.split('/');
                let parsed = replaceTypesSlashes(value);
                try {
                    parsed = JSON.parse(parsed);
                }
                catch { }
                return { [type]: { [attribute]: parsed } };
            })());
        }
        return ret;
    };
    const findExecutionFindingIndex = (asffOrFindings, asffFindingToMatch) => {
        if (asffFindingToMatch) {
            const targetToMatch = asffFindingToMatch.Id.split('/')[0];
            return lodash_1.default.findIndex(Array.isArray(asffOrFindings)
                ? asffOrFindings
                : lodash_1.default.get(asffOrFindings, 'Findings'), (finding) => lodash_1.default.get(finding, 'Id').split('/').length === 2 &&
                lodash_1.default.get(finding, 'Id').startsWith(targetToMatch));
        }
        return lodash_1.default.findIndex(Array.isArray(asffOrFindings)
            ? asffOrFindings
            : lodash_1.default.get(asffOrFindings, 'Findings'), (finding) => lodash_1.default.get(finding, 'Id').split('/').length === 2);
    };
    const preprocessingASFF = (asff) => {
        const clone = lodash_1.default.cloneDeep(asff);
        const index = findExecutionFindingIndex(clone);
        lodash_1.default.pullAt(lodash_1.default.get(clone, 'Findings'), index);
        return clone;
    };
    const supportingDocs = (input) => {
        const [asff, docs] = input;
        const index = findExecutionFindingIndex(asff);
        const docsClone = lodash_1.default.cloneDeep(docs);
        docsClone.set(SpecialCasing.HDF2ASFF, {
            execution: lodash_1.default.get(asff, `Findings[${index}]`)
        });
        return docsClone;
    };
    const productName = (findings) => {
        const finding = Array.isArray(findings) ? findings[0] : findings;
        const name = lodash_1.default.get(finding, 'Id');
        return (0, html_entities_1.encode)(name.split('/').slice(0, 2).join(' - '));
    };
    const doesNotHaveFindingTitlePrefix = () => true;
    const code = (group) => {
        return group[0].code || '';
    };
    const waiverData = (group) => {
        return group[0].waiver_data || {};
    };
    const filename = (findingInfo) => {
        const index = findExecutionFindingIndex(findingInfo[1], findingInfo[0]);
        const target = replaceTypesSlashes(lodash_1.default.get(findingInfo[1][index], 'Id').split('/')[0]);
        const finding = findingInfo[0];
        return `${lodash_1.default.get(objectifyTypesArray(finding), 'File.Input')}-${target}.json`;
    };
    const mapping = (context) => {
        var _a;
        const execution = lodash_1.default.get(context.supportingDocs.get(SpecialCasing.HDF2ASFF), 'execution');
        const executionTypes = objectifyTypesArray(execution);
        const profileNames = Object.keys(executionTypes || {}).filter((type) => !['MITRE', 'File', 'Execution'].includes(type));
        return {
            shortcircuit: true,
            platform: {
                ...lodash_1.default.get(executionTypes, 'Execution.platform'),
                target_id: ((_a = context.supportingDocs.get(SpecialCasing.HDF2ASFF)) === null || _a === void 0 ? void 0 : _a.execution.Id).split('/')[0]
            },
            version: lodash_1.default.get(executionTypes, 'Execution.version'),
            statistics: lodash_1.default.get(executionTypes, 'Execution.statistics'),
            profiles: lodash_1.default.map(profileNames, (profileName, index) => {
                return {
                    name: lodash_1.default.get(executionTypes, `${profileName}.name`),
                    ...(lodash_1.default.has(executionTypes, `${profileName}.version`) && {
                        version: lodash_1.default.get(executionTypes, `${profileName}.version`)
                    }),
                    ...(lodash_1.default.has(executionTypes, `${profileName}.title`) && {
                        title: lodash_1.default.get(executionTypes, `${profileName}.title`)
                    }),
                    ...(lodash_1.default.has(executionTypes, `${profileName}.maintainer`) && {
                        maintainer: lodash_1.default.get(executionTypes, `${profileName}.maintainer`)
                    }),
                    ...(lodash_1.default.has(executionTypes, `${profileName}.summary`) && {
                        summary: lodash_1.default.get(executionTypes, `${profileName}.summary`)
                    }),
                    ...(lodash_1.default.has(executionTypes, `${profileName}.license`) && {
                        license: lodash_1.default.get(executionTypes, `${profileName}.license`)
                    }),
                    ...(lodash_1.default.has(executionTypes, `${profileName}.copyright`) && {
                        copyright: lodash_1.default.get(executionTypes, `${profileName}.copyright`)
                    }),
                    ...(lodash_1.default.has(executionTypes, `${profileName}.copyright_email`) && {
                        copyright_email: lodash_1.default.get(executionTypes, `${profileName}.copyright_email`)
                    }),
                    supports: lodash_1.default.get(executionTypes, `${profileName}.supports`, []),
                    attributes: lodash_1.default.get(executionTypes, `${profileName}.attributes`, []),
                    ...(lodash_1.default.has(executionTypes, `${profileName}.depends`) && {
                        depends: lodash_1.default.get(executionTypes, `${profileName}.depends`)
                    }),
                    groups: [],
                    ...(lodash_1.default.has(executionTypes, `${profileName}.status`) && {
                        status: lodash_1.default.get(executionTypes, `${profileName}.status`)
                    }),
                    ...(lodash_1.default.has(executionTypes, `${profileName}.description`) && {
                        description: lodash_1.default.get(executionTypes, `${profileName}.description`)
                    }),
                    ...(lodash_1.default.has(executionTypes, `${profileName}.inspec_version`) && {
                        inspec_version: lodash_1.default.get(executionTypes, `${profileName}.inspec_version`)
                    }),
                    ...(lodash_1.default.has(executionTypes, `${profileName}.parent_profile`) && {
                        parent_profile: lodash_1.default.get(executionTypes, `${profileName}.parent_profile`)
                    }),
                    ...(lodash_1.default.has(executionTypes, `${profileName}.skip_message`) && {
                        skip_message: lodash_1.default.get(executionTypes, `${profileName}.skip_message`)
                    }),
                    ...(lodash_1.default.has(executionTypes, `${profileName}.status_message`) && {
                        status_message: lodash_1.default.get(executionTypes, `${profileName}.status_message`)
                    }),
                    controls: consolidate(context, (() => {
                        console.log('findings length', lodash_1.default.get(context.data, 'Findings')
                            .length);
                        return lodash_1.default.map(lodash_1.default.get(context.data, 'Findings'), (finding) => {
                            const findingTypes = objectifyTypesArray(finding);
                            return {
                                id: lodash_1.default.get(findingTypes, 'Control.ID'),
                                ...(lodash_1.default.has(findingTypes, 'Control.Title') && {
                                    title: lodash_1.default.get(findingTypes, 'Control.Title')
                                }),
                                ...(lodash_1.default.has(findingTypes, 'Control.Desc') && {
                                    desc: lodash_1.default.get(findingTypes, 'Control.Desc')
                                }),
                                impact: lodash_1.default.get(findingTypes, 'Control.Impact'),
                                tags: {
                                    ...lodash_1.default.omit(lodash_1.default.get(findingTypes, 'Tags'), ['nist']),
                                    nist: (() => {
                                        const nisttags = lodash_1.default.get(findingTypes, 'Tags.nist');
                                        if (nisttags === undefined || nisttags.length === 0) {
                                            return DEFAULT_NIST_TAG;
                                        }
                                        else {
                                            return nisttags;
                                        }
                                    })()
                                },
                                descriptions: lodash_1.default.map(Object.entries(lodash_1.default.get(findingTypes, 'Descriptions') || {}), ([key, value]) => ({ label: key, data: value })),
                                refs: lodash_1.default.get(findingTypes, 'Control.Refs', []),
                                source_location: lodash_1.default.get(findingTypes, 'Control.Source_Location', {}),
                                ...(lodash_1.default.has(findingTypes, 'Control.Waiver_Data') && {
                                    waiver_data: lodash_1.default.get(findingTypes, 'Control.Waiver_Data')
                                }),
                                code: '',
                                results: index === profileNames.length - 1
                                    ? [
                                        {
                                            code_desc: lodash_1.default.get(findingTypes, 'Segment.code_desc'),
                                            start_time: lodash_1.default.get(findingTypes, 'Segment.start_time'),
                                            ...lodash_1.default.omit(lodash_1.default.get(findingTypes, 'Segment'), [
                                                'code_desc',
                                                'start_time'
                                            ])
                                        }
                                    ]
                                    : []
                            };
                        });
                    })(), context.data),
                    sha256: lodash_1.default.get(executionTypes, `${profileName}.sha256`)
                };
            })
        };
    };
    return {
        preprocessingASFF,
        supportingDocs,
        productName,
        doesNotHaveFindingTitlePrefix,
        code,
        waiverData,
        filename,
        mapping
    };
}
class ASFFMapper extends base_converter_1.BaseConverter {
    constructor(asff, supportingDocs, meta = undefined) {
        super(asff);
        this.meta = meta;
        this.supportingDocs = supportingDocs;
        this.setMappings();
    }
    statusReason(finding) {
        var _a;
        return (_a = lodash_1.default.get(finding, 'Compliance.StatusReasons')) === null || _a === void 0 ? void 0 : _a.map((reason) => Object.entries(reason || {}).map(([key, value]) => {
            return `${(0, html_entities_1.encode)(key)}: ${(0, html_entities_1.encode)(value)}`;
        })).flat().join('\n');
    }
    setMappings() {
        this.mappings = externalProductHandler(this, whichSpecialCase(lodash_1.default.get(this.data, 'Findings[0]')), this, 'mapping', {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version,
                target_id: {
                    transformer: (record) => {
                        const productInfo = lodash_1.default.get(record, 'Findings[0].ProductArn')
                            .split(':')
                            .slice(-1)[0]
                            .split('/');
                        const defaultTargetId = `${productInfo[1]} | ${productInfo[2]}`;
                        return externalProductHandler(this, whichSpecialCase(lodash_1.default.get(record, 'Findings[0]')), [lodash_1.default.get(record, 'Findings[0]'), record.Findings], 'productName', (0, html_entities_1.encode)(defaultTargetId));
                    }
                }
            },
            version: package_json_1.version,
            statistics: {
                duration: null
            },
            profiles: [
                {
                    name: {
                        transformer: () => {
                            var _a;
                            return ((_a = this.meta) === null || _a === void 0 ? void 0 : _a.name) || 'AWS Security Finding Format';
                        }
                    },
                    version: '',
                    title: {
                        transformer: () => {
                            return lodash_1.default.get(this.meta, 'title') || 'ASFF Findings';
                        }
                    },
                    maintainer: null,
                    summary: '',
                    license: null,
                    copyright: null,
                    copyright_email: null,
                    supports: [],
                    attributes: [],
                    depends: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: 'Findings',
                            key: 'id',
                            arrayTransformer: consolidate.bind(this, this),
                            id: {
                                transformer: (finding) => externalProductHandler(this, whichSpecialCase(finding), finding, 'findingId', (0, html_entities_1.encode)(lodash_1.default.get(finding, 'GeneratorId')))
                            },
                            title: {
                                transformer: (finding) => externalProductHandler(this, whichSpecialCase(finding), finding, 'findingTitle', (0, html_entities_1.encode)(lodash_1.default.get(finding, 'Title')))
                            },
                            desc: {
                                path: 'Description',
                                transformer: (input) => (0, html_entities_1.encode)(input)
                            },
                            impact: {
                                transformer: (finding) => {
                                    let impact;
                                    if (lodash_1.default.get(finding, 'Workflow.Status') === 'SUPPRESSED') {
                                        impact = 'INFORMATIONAL';
                                    }
                                    else {
                                        const defaultFunc = () => lodash_1.default.get(finding, SEVERITY_LABEL)
                                            ? lodash_1.default.get(finding, SEVERITY_LABEL)
                                            : lodash_1.default.get(finding, 'Severity.Normalized') /
                                                100.0;
                                        impact = externalProductHandler(this, whichSpecialCase(finding), finding, 'findingImpact', defaultFunc);
                                    }
                                    return typeof impact === 'string'
                                        ? IMPACT_MAPPING.get(impact) || 0
                                        : impact;
                                }
                            },
                            tags: {
                                transformer: (finding) => externalProductHandler(this, whichSpecialCase(finding), finding, 'findingTags', {}),
                                nist: {
                                    transformer: (finding) => {
                                        const tags = externalProductHandler(this, whichSpecialCase(finding), finding, 'findingNistTag', []);
                                        if (tags.length === 0) {
                                            return DEFAULT_NIST_TAG;
                                        }
                                        else {
                                            return tags;
                                        }
                                    }
                                }
                            },
                            descriptions: [
                                {
                                    data: {
                                        path: 'Remediation.Recommendation',
                                        transformer: (input) => {
                                            const data = [];
                                            if (lodash_1.default.has(input, 'Text')) {
                                                data.push(lodash_1.default.get(input, 'Text'));
                                            }
                                            if (lodash_1.default.has(input, 'Url')) {
                                                data.push(lodash_1.default.get(input, 'Url'));
                                            }
                                            return data.join('\n');
                                        }
                                    },
                                    label: 'fix'
                                }
                            ],
                            refs: [
                                {
                                    transformer: (finding) => {
                                        return {
                                            ...(lodash_1.default.has(finding, 'SourceUrl') && {
                                                url: {
                                                    path: 'SourceUrl'
                                                }
                                            })
                                        };
                                    }
                                }
                            ],
                            source_location: {},
                            code: '',
                            results: [
                                {
                                    status: {
                                        transformer: (finding) => {
                                            const defaultFunc = () => {
                                                if (lodash_1.default.has(finding, COMPLIANCE_STATUS)) {
                                                    switch (lodash_1.default.get(finding, COMPLIANCE_STATUS)) {
                                                        case 'PASSED':
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Passed;
                                                        case 'WARNING':
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
                                                        case 'FAILED':
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
                                                        case 'NOT_AVAILABLE':
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
                                                        default:
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Error;
                                                    }
                                                }
                                                else {
                                                    return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
                                                }
                                            };
                                            return externalProductHandler(this, whichSpecialCase(finding), finding, 'subfindingsStatus', defaultFunc);
                                        }
                                    },
                                    code_desc: {
                                        transformer: (finding) => {
                                            let output = externalProductHandler(this, whichSpecialCase(finding), finding, 'subfindingsCodeDesc', '');
                                            if (output) {
                                                output += '; ';
                                            }
                                            const resources = lodash_1.default.get(finding, 'Resources')
                                                .map((resource) => {
                                                let hash = `Type: ${(0, html_entities_1.encode)(lodash_1.default.get(resource, 'Type'))}, Id: ${(0, html_entities_1.encode)(lodash_1.default.get(resource, 'Id'))}`;
                                                if (lodash_1.default.has(resource, 'Partition')) {
                                                    hash += `, Partition: ${(0, html_entities_1.encode)(lodash_1.default.get(resource, 'Partition'))}`;
                                                }
                                                if (lodash_1.default.has(resource, 'Region')) {
                                                    hash += `, Region: ${(0, html_entities_1.encode)(lodash_1.default.get(resource, 'Region'))}`;
                                                }
                                                return hash;
                                            })
                                                .join(', ');
                                            output += `Resources: [${resources}]`;
                                            return output;
                                        }
                                    },
                                    transformer: (finding) => {
                                        const message = (() => {
                                            const defaultFunc = () => {
                                                const statusReason = this.statusReason(finding);
                                                switch (lodash_1.default.get(finding, COMPLIANCE_STATUS)) {
                                                    case undefined:
                                                        return undefined;
                                                    case 'PASSED':
                                                        return statusReason;
                                                    case 'WARNING':
                                                        return undefined;
                                                    case 'FAILED':
                                                        return statusReason;
                                                    case 'NOT_AVAILABLE':
                                                        return undefined;
                                                    default:
                                                        return statusReason;
                                                }
                                            };
                                            return externalProductHandler(this, whichSpecialCase(finding), finding, 'subfindingsMessage', defaultFunc);
                                        })();
                                        const skipMessage = (() => {
                                            const statusReason = this.statusReason(finding);
                                            switch (lodash_1.default.get(finding, COMPLIANCE_STATUS)) {
                                                case undefined:
                                                    return statusReason;
                                                case 'PASSED':
                                                    return undefined;
                                                case 'WARNING':
                                                    return statusReason;
                                                case 'FAILED':
                                                    return undefined;
                                                case 'NOT_AVAILABLE':
                                                    return statusReason;
                                                default:
                                                    return undefined;
                                            }
                                        })();
                                        return {
                                            ...(message !== undefined && { message }),
                                            ...(skipMessage !== undefined && {
                                                skip_message: skipMessage
                                            })
                                        };
                                    },
                                    start_time: {
                                        transformer: (finding) => lodash_1.default.get(finding, 'LastObservedAt') ||
                                            lodash_1.default.get(finding, 'UpdatedAt')
                                    }
                                }
                            ]
                        }
                    ],
                    sha256: ''
                }
            ]
        });
    }
}
exports.ASFFMapper = ASFFMapper;
class ASFFResults {
    constructor(asffJson, securityhubStandardsJsonArray = undefined, meta = undefined) {
        this.meta = meta;
        this.supportingDocs = new Map();
        this.supportingDocs.set(SpecialCasing.SecurityHub, lodash_1.default.get(SPECIAL_CASE_MAPPING.get(SpecialCasing.SecurityHub), 'securityhubSupportingDocs', (standards) => {
            throw new Error(`supportingDocs function should've been defined: ${standards}`);
        })(securityhubStandardsJsonArray));
        const findings = lodash_1.default.get(fixFileInput(asffJson), 'Findings');
        this.data = lodash_1.default.groupBy(findings, (finding) => {
            const productInfo = lodash_1.default.get(finding, 'ProductArn')
                .split(':')
                .slice(-1)[0]
                .split('/');
            const defaultFilename = `${productInfo[1]} | ${productInfo[2]}.json`;
            return externalProductHandler(this, whichSpecialCase(finding), [finding, findings], 'filename', (0, html_entities_1.encode)(defaultFilename));
        });
    }
    toHdf() {
        return lodash_1.default.mapValues(this.data, (val) => {
            const wrapped = wrapWithFindingsObject(val);
            const ret = new ASFFMapper(externalProductHandler(this, whichSpecialCase(lodash_1.default.get(wrapped, 'Findings[0]')), wrapped, 'preprocessingASFF', wrapped), externalProductHandler(this, whichSpecialCase(lodash_1.default.get(wrapped, 'Findings[0]')), [wrapped, this.supportingDocs], 'supportingDocs', this.supportingDocs), externalProductHandler(this, whichSpecialCase(lodash_1.default.get(wrapped, 'Findings[0]')), undefined, 'meta', this.meta)).toHdf();
            return ret;
        });
    }
}
exports.ASFFResults = ASFFResults;
//# sourceMappingURL=asff-mapper.js.map