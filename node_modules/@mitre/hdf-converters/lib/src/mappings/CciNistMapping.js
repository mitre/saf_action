"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CciNistMapping = exports.CciNistTwoWayMapper = void 0;
const fast_xml_parser_1 = require("fast-xml-parser");
const lodash_1 = __importDefault(require("lodash"));
const CCI_List_1 = require("../utils/CCI_List");
const CciNistMappingData_1 = require("./CciNistMappingData");
const CciNistMappingItem_1 = require("./CciNistMappingItem");
class CciNistTwoWayMapper {
    constructor() {
        const alwaysArray = ['cci_item', 'reference'];
        const options = {
            ignoreAttributes: false,
            isArray: (tagName) => {
                if (alwaysArray.includes(tagName)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        };
        const parser = new fast_xml_parser_1.XMLParser(options);
        this.data = parser.parse(CCI_List_1.CCI_List);
    }
    nistFilter(identifiers, defaultNist, collapse = true) {
        const DEFAULT_NIST_TAGS = defaultNist;
        let matches = [];
        for (const id of identifiers) {
            const nistRef = this.findHighestVersionNistControlByCci(id);
            if (nistRef) {
                matches.push(nistRef);
            }
        }
        if (collapse) {
            matches = lodash_1.default.uniq(matches);
        }
        return matches !== null && matches !== void 0 ? matches : DEFAULT_NIST_TAGS;
    }
    cciFilter(identifiers, defaultCci) {
        const matches = [];
        for (const id of identifiers) {
            matches.push(...this.findMatchingCciIdsByNistControl(id));
        }
        return matches !== null && matches !== void 0 ? matches : defaultCci;
    }
    findHighestVersionNistControlByCci(targetId) {
        let highestVersionControl = null;
        let highestVersion = -1;
        const { cci_item } = this.data.cci_list.cci_items;
        const targetItem = cci_item.find((item) => item['@_id'] === targetId);
        if (targetItem) {
            for (const reference of targetItem.references.reference) {
                const version = parseFloat(reference['@_version']);
                if (version > highestVersion) {
                    highestVersion = version;
                    highestVersionControl = reference['@_index'];
                }
            }
        }
        return highestVersionControl;
    }
    findMatchingCciIdsByNistControl(pattern) {
        const matchingIds = [];
        const { cci_item } = this.data.cci_list.cci_items;
        for (const item of cci_item) {
            for (const reference of item.references.reference) {
                const regexPattern = new RegExp(`^${pattern}`);
                if (RegExp(regexPattern).exec(reference['@_index']) &&
                    item.type === 'technical') {
                    matchingIds.push(item['@_id']);
                    break;
                }
                if (matchingIds.length === 0) {
                    const regexEditedPattern = new RegExp(`${/\w\w-\d\d?\d?/g.exec(pattern)}`);
                    if (RegExp(regexEditedPattern).exec(reference['@_index']) &&
                        item.type === 'technical') {
                        matchingIds.push(item['@_id']);
                        break;
                    }
                }
            }
        }
        return matchingIds;
    }
}
exports.CciNistTwoWayMapper = CciNistTwoWayMapper;
class CciNistMapping {
    constructor() {
        this.data = [];
        if (typeof CciNistMappingData_1.data === 'object') {
            Object.entries(CciNistMappingData_1.data).forEach((item) => {
                this.data.push(new CciNistMappingItem_1.CciNistMappingItem(item[0], item[1]));
            });
        }
    }
    nistFilter(identifiers, defaultNist, collapse = true) {
        const DEFAULT_NIST_TAG = defaultNist;
        const matches = [];
        identifiers.forEach((id) => {
            const item = this.data.find((element) => element.cci === id);
            if (item && item.nistId) {
                if (collapse) {
                    if (matches.indexOf(item.nistId) === -1) {
                        matches.push(item.nistId);
                    }
                }
                else {
                    matches.push(item.nistId);
                }
            }
        });
        if (matches.length === 0) {
            return DEFAULT_NIST_TAG;
        }
        return matches;
    }
}
exports.CciNistMapping = CciNistMapping;
//# sourceMappingURL=CciNistMapping.js.map