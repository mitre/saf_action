"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DBProtectMapper = void 0;
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const global_1 = require("./utils/global");
const IMPACT_MAPPING = new Map([
    ['high', 0.7],
    ['medium', 0.5],
    ['low', 0.3],
    ['informational', 0]
]);
function compileFindings(input) {
    const keys = lodash_1.default.get(input, 'dataset.metadata.item');
    const findings = lodash_1.default.get(input, 'dataset.data.row');
    let output = [];
    if (Array.isArray(keys) && Array.isArray(findings)) {
        const keyNames = keys.map((element) => {
            return lodash_1.default.get(element, 'name');
        });
        output = findings.map((element) => {
            return Object.fromEntries(keyNames.map(function (name, i) {
                return [name, lodash_1.default.get(element, `value[${i}]`)];
            }));
        });
    }
    return Object.fromEntries([['data', output]]);
}
function formatSummary(entry) {
    const text = [];
    text.push(`Organization : ${lodash_1.default.get(entry, 'Organization')}`);
    text.push(`Asset : ${lodash_1.default.get(entry, 'Check Asset')}`);
    text.push(`Asset Type : ${lodash_1.default.get(entry, 'Asset Type')}`);
    text.push(`IP Address, Port, Instance : ${lodash_1.default.get(entry, 'Asset Type')}`);
    text.push(`IP Address, Port, Instance : ${lodash_1.default.get(entry, 'IP Address, Port, Instance')} `);
    return text.join('\n');
}
function formatDesc(entry) {
    const text = [];
    text.push(`Task : ${lodash_1.default.get(entry, 'Task')}`);
    text.push(`Check Category : ${lodash_1.default.get(entry, 'Check Category')}`);
    return text.join('; ');
}
function getStatus(input) {
    switch (input) {
        case 'Fact':
            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
        case 'Failed':
            return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
        case 'Finding':
            return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
        case 'Not A Finding':
            return inspecjs_1.ExecJSON.ControlResultStatus.Passed;
    }
    return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
}
function getBacktrace(input) {
    if (input === 'Failed') {
        return 'DB Protect Failed Check';
    }
    else {
        return '';
    }
}
function handleBacktrace(input) {
    if (Array.isArray(input)) {
        input = input.map((element) => {
            if (lodash_1.default.get(element, 'backtrace')[0] === '') {
                return lodash_1.default.omit(element, 'backtrace');
            }
            else {
                return element;
            }
        });
    }
    return input;
}
function idToString(id) {
    if (typeof id === 'string' || typeof id === 'number') {
        return id.toString();
    }
    else {
        return '';
    }
}
class DBProtectMapper extends base_converter_1.BaseConverter {
    constructor(dbProtectXml, withRaw = false) {
        super(compileFindings((0, base_converter_1.parseXml)(dbProtectXml)));
        this.mappings = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version
            },
            version: package_json_1.version,
            statistics: {},
            profiles: [
                {
                    name: { path: 'data.[0].Policy' },
                    title: { path: 'data.[0].Job Name' },
                    summary: { path: 'data.[0]', transformer: formatSummary },
                    supports: [],
                    attributes: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: 'data',
                            key: 'id',
                            tags: {
                                nist: global_1.DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS,
                                cci: (0, global_1.getCCIsForNISTTags)(global_1.DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS)
                            },
                            refs: [],
                            source_location: {},
                            title: { path: 'Check' },
                            id: { path: 'Check ID', transformer: idToString },
                            desc: { transformer: formatDesc },
                            impact: {
                                path: 'Risk DV',
                                transformer: (0, base_converter_1.impactMapping)(IMPACT_MAPPING)
                            },
                            code: {
                                transformer: (vulnerability) => JSON.stringify(vulnerability, null, 2)
                            },
                            results: [
                                {
                                    arrayTransformer: handleBacktrace,
                                    status: { path: 'Result Status', transformer: getStatus },
                                    code_desc: { path: 'Details' },
                                    start_time: { path: 'Date' },
                                    backtrace: [{ path: 'Result Status', transformer: getBacktrace }]
                                }
                            ]
                        }
                    ],
                    sha256: ''
                }
            ],
            passthrough: {
                transformer: (data) => {
                    return { ...(this.withRaw && { raw: data }) };
                }
            }
        };
        this.withRaw = withRaw;
    }
}
exports.DBProtectMapper = DBProtectMapper;
//# sourceMappingURL=dbprotect-mapper.js.map