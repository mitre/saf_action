"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnykMapper = exports.SnykResults = void 0;
const inspecjs_1 = require("inspecjs");
const _ = __importStar(require("lodash"));
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const CweNistMapping_1 = require("./mappings/CweNistMapping");
const global_1 = require("./utils/global");
const IMPACT_MAPPING = new Map([
    ['high', 0.7],
    ['medium', 0.5],
    ['low', 0.3]
]);
const CWE_NIST_MAPPING = new CweNistMapping_1.CweNistMapping();
const CWE_PATH = 'identifiers.CWE';
function parseIdentifier(identifiers) {
    const output = [];
    if (identifiers !== undefined && Array.isArray(identifiers)) {
        identifiers.forEach((element) => {
            const numbers = element.split('-');
            numbers.shift();
            output.push(numbers.join('-'));
        });
        return output;
    }
    else {
        return [];
    }
}
function nistTag(identifiers) {
    return CWE_NIST_MAPPING.nistFilter(parseIdentifier(identifiers), global_1.DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS);
}
class SnykResults {
    constructor(snykJson) {
        this.data = JSON.parse(snykJson);
    }
    toHdf() {
        const results = [];
        if (Array.isArray(this.data)) {
            this.data.forEach((element) => {
                const entry = new SnykMapper(element);
                if (this.customMapping !== undefined) {
                    entry.setMappings(this.customMapping);
                }
                results.push(entry.toHdf());
            });
            return results;
        }
        else {
            const result = new SnykMapper(this.data);
            if (this.customMapping !== undefined) {
                result.setMappings(this.customMapping);
            }
            return result.toHdf();
        }
    }
}
exports.SnykResults = SnykResults;
class SnykMapper extends base_converter_1.BaseConverter {
    constructor(snykJson) {
        super(snykJson);
        this.mappings = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version,
                target_id: { path: 'projectName' }
            },
            version: package_json_1.version,
            statistics: {
                duration: null
            },
            profiles: [
                {
                    name: 'Snyk Scan',
                    title: {
                        transformer: (data) => {
                            const projectName = _.has(data, 'projectName')
                                ? `Snyk Project: ${_.get(data, 'projectName')} `
                                : '';
                            return `${projectName}Snyk Path: ${_.get(data, 'path')}`;
                        }
                    },
                    maintainer: null,
                    summary: {
                        path: 'summary',
                        transformer: (summary) => {
                            return `Snyk Summary: ${summary}`;
                        }
                    },
                    license: null,
                    copyright: null,
                    copyright_email: null,
                    supports: [],
                    attributes: [],
                    depends: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: 'vulnerabilities',
                            key: 'id',
                            tags: {
                                cci: {
                                    path: CWE_PATH,
                                    transformer: (cwe) => (0, global_1.getCCIsForNISTTags)(nistTag(cwe))
                                },
                                nist: { path: CWE_PATH, transformer: nistTag },
                                cweid: { path: CWE_PATH, transformer: parseIdentifier },
                                cveid: { path: 'identifiers.CVE', transformer: parseIdentifier },
                                ghsaid: { path: 'identifiers.GHSA', transformer: parseIdentifier }
                            },
                            descriptions: [],
                            refs: [],
                            source_location: {},
                            title: { path: 'title' },
                            id: { path: 'id' },
                            desc: { path: 'description' },
                            impact: {
                                path: 'severity',
                                transformer: (0, base_converter_1.impactMapping)(IMPACT_MAPPING)
                            },
                            code: {
                                transformer: (vulnerability) => {
                                    return JSON.stringify(vulnerability, null, 2);
                                }
                            },
                            results: [
                                {
                                    status: inspecjs_1.ExecJSON.ControlResultStatus.Failed,
                                    code_desc: {
                                        path: 'from',
                                        transformer: (input) => {
                                            if (Array.isArray(input)) {
                                                return `From : [ ${input.join(' , ')} ]`;
                                            }
                                            else {
                                                return '';
                                            }
                                        }
                                    },
                                    run_time: 0,
                                    start_time: ''
                                }
                            ]
                        }
                    ],
                    sha256: ''
                }
            ],
            passthrough: {
                snyk_metadata: {
                    transformer: (data) => {
                        return _.omit(data, ['vulnerabilities']);
                    }
                }
            }
        };
    }
}
exports.SnykMapper = SnykMapper;
//# sourceMappingURL=snyk-mapper.js.map