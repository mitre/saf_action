"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetsparkerMapper = void 0;
const inspecjs_1 = require("inspecjs");
const _ = __importStar(require("lodash"));
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const CweNistMapping_1 = require("./mappings/CweNistMapping");
const OwaspNistMapping_1 = require("./mappings/OwaspNistMapping");
const global_1 = require("./utils/global");
const IMPACT_MAPPING = new Map([
    ['critical', 1.0],
    ['high', 0.7],
    ['medium', 0.5],
    ['low', 0.3],
    ['best_practice', 0.0],
    ['information', 0.0]
]);
const CWE_NIST_MAPPING = new CweNistMapping_1.CweNistMapping();
const OWASP_NIST_MAPPING = new OwaspNistMapping_1.OwaspNistMapping();
function nistTag(classification) {
    let cweTag = _.get(classification, 'cwe');
    if (!Array.isArray(cweTag)) {
        cweTag = [cweTag];
    }
    let owaspTag = _.get(classification, 'owasp');
    if (!Array.isArray(owaspTag)) {
        owaspTag = [owaspTag];
    }
    const cwe = CWE_NIST_MAPPING.nistFilter(cweTag);
    const owasp = OWASP_NIST_MAPPING.nistFilterNoDefault(owaspTag);
    const result = cwe.concat(owasp);
    if (result.length !== 0) {
        return result;
    }
    else {
        return global_1.DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS;
    }
}
function formatControlDesc(vulnerability) {
    const text = [];
    const description = _.get(vulnerability, 'description');
    if (description) {
        text.push(description);
    }
    const exploitationSkills = _.get(vulnerability, 'exploitation-skills');
    if (exploitationSkills) {
        text.push(`Exploitation-skills: ${exploitationSkills}`);
    }
    const extraInformation = _.get(vulnerability, 'extra-information');
    if (extraInformation) {
        text.push(`Extra-information: ${JSON.stringify(extraInformation).replace(/:/gi, '=>')}`);
    }
    const classification = _.get(vulnerability, 'classification');
    if (classification) {
        text.push(`Classification: ${JSON.stringify(classification).replace(/:/gi, '=>')}`);
    }
    const impact = _.get(vulnerability, 'impact');
    if (impact) {
        text.push(`Impact: ${impact}`);
    }
    const firstSeenDate = _.get(vulnerability, 'FirstSeenDate');
    if (firstSeenDate) {
        text.push(`FirstSeenDate: ${firstSeenDate}`);
    }
    const lastSeenDate = _.get(vulnerability, 'LastSeenDate');
    if (lastSeenDate) {
        text.push(`LastSeenDate: ${lastSeenDate}`);
    }
    const certainty = _.get(vulnerability, 'certainty');
    if (certainty) {
        text.push(`Certainty: ${certainty}`);
    }
    const type = _.get(vulnerability, 'type');
    if (type) {
        text.push(`Type: ${type}`);
    }
    const confirmed = _.get(vulnerability, 'confirmed');
    if (confirmed) {
        text.push(`Confirmed: ${confirmed}`);
    }
    return text.join('<br>');
}
function formatCheck(vulnerability) {
    const text = [];
    const exploitationSkills = _.get(vulnerability, 'exploitation-skills');
    if (exploitationSkills) {
        text.push(`Exploitation-skills: ${exploitationSkills}`);
    }
    const proofOfConcept = _.get(vulnerability, 'proof-of-concept');
    if (proofOfConcept) {
        text.push(`Proof-of-concept: ${proofOfConcept}`);
    }
    return (0, base_converter_1.parseHtml)(text.join('<br>'));
}
function formatFix(vulnerability) {
    const text = [];
    const remedialActions = _.get(vulnerability, 'remedial-actions');
    if (remedialActions) {
        text.push(`Remedial-actions: ${remedialActions}`);
    }
    const remedialProcedure = _.get(vulnerability, 'remedial-procedure');
    if (remedialProcedure) {
        text.push(`Remedial-procedure: ${remedialProcedure}`);
    }
    const remedyReferences = _.get(vulnerability, 'remedy-references');
    if (remedyReferences) {
        text.push(`Remedy-references: ${remedyReferences}`);
    }
    return text.join('<br>');
}
function formatCodeDesc(request) {
    const text = [];
    text.push(`http-request : ${_.get(request, 'content')}`);
    text.push(`method : ${_.get(request, 'method')}`);
    return text.join('\n');
}
function formatMessage(response) {
    const text = [];
    text.push(`http-response : ${_.get(response, 'content')}`);
    text.push(`duration : ${_.get(response, 'duration')}`);
    text.push(`status-code  : ${_.get(response, 'status-code')}`);
    return text.join('\n');
}
class NetsparkerMapper extends base_converter_1.BaseConverter {
    defineMappings(toolname) {
        const capitalizedToolname = toolname.replace(/^./, (firstLetter) => firstLetter.toUpperCase());
        return {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version,
                target_id: { path: `${toolname}-enterprise.target.url` }
            },
            version: package_json_1.version,
            statistics: {},
            profiles: [
                {
                    name: `${capitalizedToolname} Enterprise Scan`,
                    title: {
                        path: `${toolname}-enterprise.target`,
                        transformer: (input) => {
                            return `${toolname.replace(/^./, (firstLetter) => firstLetter.toUpperCase())} Enterprise Scan ID: ${_.get(input, 'scan-id')} URL: ${_.get(input, 'url')}`;
                        }
                    },
                    summary: `${capitalizedToolname} Enterprise Scan`,
                    supports: [],
                    attributes: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: `${toolname}-enterprise.vulnerabilities.vulnerability`,
                            key: 'id',
                            tags: {
                                cci: {
                                    path: 'classification',
                                    transformer: (data) => (0, global_1.getCCIsForNISTTags)(nistTag(data))
                                },
                                nist: { path: 'classification', transformer: nistTag }
                            },
                            refs: [],
                            source_location: {},
                            title: { path: 'name' },
                            id: { path: 'LookupId' },
                            desc: { transformer: formatControlDesc },
                            descriptions: [
                                {
                                    data: { transformer: formatCheck },
                                    label: 'check'
                                },
                                {
                                    data: { transformer: formatFix },
                                    label: 'fix'
                                }
                            ],
                            impact: {
                                path: 'severity',
                                transformer: (0, base_converter_1.impactMapping)(IMPACT_MAPPING)
                            },
                            code: {
                                transformer: (vulnerability) => JSON.stringify(vulnerability, null, 2)
                            },
                            results: [
                                {
                                    status: inspecjs_1.ExecJSON.ControlResultStatus.Failed,
                                    code_desc: {
                                        path: 'http-request',
                                        transformer: formatCodeDesc
                                    },
                                    message: { path: 'http-response', transformer: formatMessage },
                                    start_time: {
                                        path: `$.${toolname}-enterprise.target.initiated`
                                    }
                                }
                            ]
                        }
                    ],
                    sha256: ''
                }
            ],
            passthrough: {
                transformer: (data) => {
                    const auxData = _.get(data, 'netsparker-enterprise');
                    const genData = _.get(auxData, 'generated');
                    const targetData = _.omit(_.get(auxData, 'target'), [
                        'scan-id',
                        'url',
                        'initiated'
                    ]);
                    return {
                        auxiliary_data: [
                            {
                                name: 'Netsparker',
                                data: {
                                    'netsparker-enterprise': {
                                        generated: genData,
                                        target: targetData
                                    }
                                }
                            }
                        ],
                        ...(this.withRaw && { raw: data })
                    };
                }
            }
        };
    }
    constructor(netsparkerXml, withRaw = false) {
        super((0, base_converter_1.parseXml)(netsparkerXml));
        this.withRaw = withRaw;
        this.setMappings(this.defineMappings(Object.keys(this.data).some((k) => k.includes('netsparker'))
            ? 'netsparker'
            : 'invicti'));
    }
}
exports.NetsparkerMapper = NetsparkerMapper;
//# sourceMappingURL=netsparker-mapper.js.map