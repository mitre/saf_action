import { AxiosError } from 'axios';
import { ExecJSON } from 'inspecjs';
import { BaseConverter, ILookupPath, MappedTransform } from './base-converter';
declare enum SonarqubeVersion {
    Eight = "8.0.0",
    Nine = "9.0.0",
    Ten = "10.0.0",
    Twenty_five = "2025.0.0"
}
type SonarqubeVersionMapping = {
    [SonarqubeVersion.Eight]: {
        issue: Issue_8;
        ruleInformation: Rule_8;
    };
    [SonarqubeVersion.Nine]: {
        issue: Issue_9;
        ruleInformation: Rule_9;
    };
    [SonarqubeVersion.Ten]: {
        issue: Issue_10;
        ruleInformation: Rule_10;
    };
    [SonarqubeVersion.Twenty_five]: {
        issue: Issue_10;
        ruleInformation: Rule_25;
    };
};
type Issue_8 = {
    actions?: string[];
    attr?: {
        'jira-issue-key'?: string;
    };
    author: string;
    cleanCodeAttribute?: string;
    cleanCodeAttributeCategory?: string;
    comments?: {
        key: string;
        login: string;
        htmlText: string;
        markdown: string;
        updatable: boolean;
        createdAt: string;
    }[];
    component: string;
    creationDate: string;
    debt: string;
    effort: string;
    flows: {
        locations: {
            textRange: {
                startLine: number;
                endLine: number;
                startOffset: number;
                endOffset: number;
            };
            msg: string;
            msgFormattings?: {
                start: number;
                end: number;
                type: string;
            }[];
            component: string;
        }[];
    }[];
    fromHotspot?: unknown;
    hash: string;
    impacts?: {
        severity: string;
        softwareQuality: string;
    }[];
    issueStatus?: string;
    key: string;
    line: number;
    message: string;
    messageFormattings?: {
        start: number;
        end: number;
        type: string;
    }[];
    organization?: string;
    project: string;
    projectName?: string;
    resolution?: string;
    rule: string;
    scope?: string;
    severity: string;
    status: string;
    tags: string[];
    textRange: {
        endLine: number;
        endOffset: number;
        startLine: number;
        startOffset: number;
    };
    transitions?: string[];
    type: string;
    updateDate: string;
};
type Issue_9 = Omit<Issue_8, 'fromHotspot'> & {
    quickFixAvailable?: boolean;
    ruleDescriptionContextKey?: string;
};
type Issue_10 = Issue_9 & {
    codeVariants: string[];
    prioritizedRule: boolean;
};
type Search<T extends SonarqubeVersion> = {
    components: {
        enabled: boolean;
        key: string;
        longName: string;
        name: string;
        organization?: string;
        path?: string;
        qualifier: string;
        uuid?: string;
    }[];
    effortTotal: number;
    facets: {
        property: string;
        values: {
            val: string;
            count: number;
        }[];
    }[];
    issues: SonarqubeVersionMapping[T]['issue'][];
    organizations?: {
        key: string;
        name: string;
    }[];
    p?: number;
    paging: {
        pageIndex: number;
        pageSize: number;
        total: number;
    };
    ps?: number;
    rules?: {
        key: string;
        name: string;
        status: string;
        lang: string;
        langName: string;
    }[];
    total?: number;
    users?: {
        login: string;
        name: string;
        active: boolean;
        avatar: string;
    }[];
};
type Rule_8 = {
    cleanCodeAttribute?: string;
    cleanCodeAttributeCategory?: string;
    createdAt: string;
    debtOverloaded: boolean;
    debtRemFnCoeff?: unknown;
    debtRemFnOffset: string;
    debtRemFnType: string;
    defaultDebtRemFnCoeff?: unknown;
    defaultDebtRemFnOffset: string;
    defaultDebtRemFnType: string;
    defaultRemFnBaseEffort: string;
    defaultRemFnType: string;
    descriptionSections?: {
        content: string;
        key: string;
    }[];
    effortToFixDescription?: unknown;
    htmlDesc: string;
    impacts?: {
        severity: string;
        softwareQuality: string;
    }[];
    isExternal: boolean;
    isTemplate: boolean;
    key: string;
    lang: string;
    langName: string;
    mdDesc: string;
    name: string;
    params: {
        key: string;
        desc: string;
        defaultValue: string;
    }[];
    remFnBaseEffort: string;
    remFnOverloaded: boolean;
    remFnType: string;
    repo: string;
    scope: string;
    securityStandards?: unknown[];
    severity: string;
    status: string;
    sysTags: string[];
    tags: unknown[];
    type: string;
};
type Rule_9 = Rule_8 & {
    educationPrinciples?: unknown[];
};
type Rule_10 = Omit<Rule_9, 'debtOverloaded' | 'debtRemFnCoeff' | 'debtRemFnOffset' | 'defaultDebtRemFnCoeff' | 'defaultDebtRemFnOffset' | 'effortToFixDescription'> & {
    updatedAt: string;
};
type Rule_25 = Omit<Rule_10, 'htmlDesc' | 'mdDesc'>;
type Rule<T extends SonarqubeVersion> = {
    actives: {
        qProfile: string;
        inherit: string;
        severity: string;
        params: {
            key: string;
            value: string;
        }[];
    }[];
    rule: SonarqubeVersionMapping[T]['ruleInformation'];
};
type IssueExtensions<T extends SonarqubeVersion> = {
    codeSnippet: string;
    ruleInformation: Rule<T>;
};
type Data<T extends SonarqubeVersion> = {
    search: Omit<Search<T>, 'issues'> & {
        issues: (SonarqubeVersionMapping[T]['issue'] & IssueExtensions<T>)[];
    };
    sonarqubeVersion: string;
    sonarqubeHost: string;
    projectKey: string;
    branchName?: string;
    pullRequestID?: string;
    organization?: string;
};
export declare class SonarqubeMapper<T extends SonarqubeVersion> extends BaseConverter<Data<T>> {
    readonly data: Data<T>;
    withRaw: boolean;
    mappings: MappedTransform<ExecJSON.Execution & {
        passthrough: unknown;
    }, ILookupPath>;
    constructor(data: Data<T>, withRaw?: boolean);
}
declare enum AuthenticationMethod {
    TokenAsUsername = 0,
    BearerToken = 1
}
export declare class SonarqubeResults {
    readonly sonarqubeHost: string;
    readonly projectKey: string;
    private readonly userToken;
    readonly branchName?: string | undefined;
    readonly pullRequestID?: string | undefined;
    readonly organization?: string | undefined;
    readonly withRaw: boolean;
    authMethod?: AuthenticationMethod;
    constructor(sonarqubeHost: string, projectKey: string, userToken: string, branchName?: string | undefined, pullRequestID?: string | undefined, organization?: string | undefined, withRaw?: boolean);
    logAxiosError(e: AxiosError): void;
    getSearchResults<T extends SonarqubeVersion>(): Promise<Search<T>>;
    getCodeSnippets<T extends SonarqubeVersion>(issues: SonarqubeVersionMapping[T]['issue'][]): Promise<string[]>;
    getRules<T extends SonarqubeVersion>(issues: SonarqubeVersionMapping[T]['issue'][]): Promise<Rule<T>[]>;
    generateHdf<T extends SonarqubeVersion>(sonarqubeVersion: string): Promise<ExecJSON.Execution>;
    toHdf(): Promise<ExecJSON.Execution>;
}
export {};
