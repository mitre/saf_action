import { ExecJSON } from 'inspecjs';
export interface ILookupPath {
    shortcircuit?: boolean;
    path?: string | string[];
    transformer?: (value: any) => unknown;
    arrayTransformer?: (value: unknown[], file: any) => unknown[];
    pathTransform?: (value: unknown, file: any) => unknown;
    key?: string;
}
export declare type ObjectEntryValue<T> = {
    [K in keyof T]: readonly [K, T[K]];
}[keyof T];
export declare type MappedTransform<T, U extends ILookupPath> = {
    [K in keyof T]: Exclude<T[K], undefined | null> extends Array<any> ? MappedTransform<T[K], U> : T[K] extends Function ? T[K] : T[K] extends object ? MappedTransform<T[K] & U, U> : T[K] | U;
};
export declare type MappedReform<T, U> = {
    [K in keyof T]: Exclude<T[K], undefined | null> extends Array<any> ? MappedReform<T[K], U> : T[K] extends object ? MappedReform<T[K] & U, U> : Exclude<T[K], U>;
};
export declare function generateHash(data: string, algorithm?: string): string;
export declare function parseHtml(input: unknown): string;
export declare function parseXml(xml: string, additionalOptions?: Record<string, unknown>): Record<string, unknown>;
export declare function parseCsv(csv: string): unknown[];
export declare function impactMapping(mapping: Map<string, number>): (severity: unknown) => number;
export declare class BaseConverter {
    data: Record<string, unknown>;
    mappings?: MappedTransform<ExecJSON.Execution, ILookupPath>;
    collapseResults: boolean;
    constructor(data: Record<string, unknown>, collapseResults?: boolean);
    setMappings(mappings: MappedTransform<ExecJSON.Execution, ILookupPath>): void;
    toHdf(): ExecJSON.Execution;
    objectMap<T, V>(obj: T, fn: (v: ObjectEntryValue<T>) => V): {
        [K in keyof T]: V;
    };
    convertInternal<T>(file: Record<string, unknown>, fields: T): MappedReform<T, ILookupPath>;
    evaluate<T>(file: Record<string, unknown>, v: T | Array<T>): T | Array<T> | MappedReform<T, ILookupPath>;
    handleArray<T>(file: Record<string, unknown>, v: Array<T & ILookupPath>): Array<T>;
    handlePath(file: Record<string, unknown>, path: string | string[]): unknown;
    hasPath(file: Record<string, unknown>, path: string | string[]): boolean;
}
