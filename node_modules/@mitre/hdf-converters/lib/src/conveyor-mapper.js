"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConveyorResults = exports.ConveyorMapper = void 0;
const inspecjs_1 = require("inspecjs");
const _ = __importStar(require("lodash"));
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const global_1 = require("./utils/global");
const CONVEYOR_MAX_SCORE = 1000;
var scannerType;
(function (scannerType) {
    scannerType["Moldy"] = "Moldy";
    scannerType["Stigma"] = "Stigma";
    scannerType["CodeQuality"] = "CodeQuality";
})(scannerType || (scannerType = {}));
function determineStatus(score) {
    if (score === 0) {
        return inspecjs_1.ExecJSON.ControlResultStatus.Passed;
    }
    return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
}
function groupByScanner(processed) {
    const groups = _.groupBy(processed, (result) => {
        return _.get(result, 'response.service_name');
    });
    return groups;
}
function collateShaAndFilenames(currLevel) {
    const shaFilePairs = [];
    for (const [sha, file] of Object.entries(currLevel)) {
        if (_.has(file, 'name')) {
            const name = _.get(file, 'name[0]') || '';
            shaFilePairs.push([sha, name]);
        }
        if (_.has(file, 'children')) {
            const nextLevel = _.get(file, 'children') || {};
            for (const nextLevelPairs of collateShaAndFilenames(nextLevel)) {
                shaFilePairs.push(nextLevelPairs);
            }
        }
    }
    return shaFilePairs;
}
function mapSha2Filename(results) {
    const toplevel = _.get(results, 'api_response.file_tree');
    const shaMappings = {};
    const shaFilePairs = collateShaAndFilenames(toplevel);
    for (const [sha, filename] of shaFilePairs) {
        _.set(shaMappings, sha || '', filename || '');
    }
    return shaMappings;
}
function createDescription(data, score, date, scannerName, endTime) {
    const desc = () => {
        if (scannerName === scannerType.Moldy ||
            scannerName === scannerType.Stigma) {
            return `title_text:${_.get(data, 'title_text')}
      body:${_.get(data, 'body')}
      body_format:${_.get(data, 'body_format')}
      classificaton:${_.get(data, 'classification')}
      depth:${_.get(data, 'depth')}
      heuristic_heur_id:${_.get(data, 'heuristic.heur_id')}
      heuristic_score:${_.get(data, 'heuristic.score')}
      heuristic_name:${_.get(data, 'heuristic.name')}`;
        }
        else if (scannerName === scannerType.CodeQuality) {
            return `body:${_.get(data, 'body')}
      body_format:${_.get(data, 'body_format')}
      classificaton:${_.get(data, 'classification')}
      depth:${_.get(data, 'depth')}
      title_text:${_.get(data, 'title_text')}`;
        }
        else {
            return JSON.stringify(data);
        }
    };
    return {
        status: determineStatus(score),
        code_desc: desc(),
        start_time: date,
        run_time: new Date(endTime).valueOf() - new Date(date).valueOf()
    };
}
function preprocessObject(parsed, mappings) {
    const results = _.get(parsed, 'api_response.results');
    const newSections = [];
    for (const result of Object.values(results)) {
        const sha = _.get(result, 'sha256', '');
        _.set(result, 'filename', _.get(mappings, sha));
        const descriptions = _.map(_.get(result, 'result.sections'), (section) => createDescription(section, _.get(result, 'result.score'), _.get(result, 'response.milestones.service_started'), _.get(result, 'response.service_name'), _.get(result, 'response.milestones.service_completed')));
        _.set(result, 'result.sections', descriptions);
        newSections.push(result);
    }
    return newSections;
}
function controlMappingConveyor() {
    return {
        id: { path: 'sha256' },
        title: { path: 'filename' },
        desc: '',
        impact: {
            path: 'result.score',
            transformer: (value) => {
                return value / CONVEYOR_MAX_SCORE;
            }
        },
        refs: [],
        tags: {
            service_context: { path: 'response.service_context' },
            service_debug_info: { path: 'response.service_debug_info' },
            service_tool_version: { path: 'response.service_tool_version' },
            supplementary: { path: 'response.supplementary' },
            created: { path: 'created' },
            archive_ts: { path: 'archive_ts' },
            classification: { path: 'classification' },
            expiry_ts: { path: 'expiry_ts' },
            size: { path: 'size' },
            type: { path: 'type' },
            nist: global_1.DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS,
            cci: global_1.DEFAULT_STATIC_CODE_ANALYSIS_CCI_TAGS.flat()
        },
        source_location: {},
        results: [
            {
                path: 'result.sections',
                status: { path: 'status' },
                code_desc: { path: 'code_desc' },
                start_time: { path: 'start_time' },
                run_time: { path: 'run_time' }
            }
        ]
    };
}
class ConveyorMapper extends base_converter_1.BaseConverter {
    constructor(remappedConveyorResults, data, scannerName) {
        _.set(data, 'api_response.results', remappedConveyorResults);
        super(data);
        this.mappings = {
            passthrough: { path: 'api_response' },
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version
            },
            version: { path: 'api_server_version' },
            statistics: {},
            profiles: [
                {
                    name: { path: 'api_response.results[0].response.service_name' },
                    version: { path: 'api_response.results[0].response.service_version' },
                    title: { path: 'api_response.params.description' },
                    supports: [],
                    attributes: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: 'api_response.results',
                            ...controlMappingConveyor()
                        }
                    ],
                    sha256: ''
                }
            ]
        };
        this.scannerName = scannerName;
    }
}
exports.ConveyorMapper = ConveyorMapper;
class ConveyorResults {
    constructor(conveyorJson) {
        const parsed = JSON.parse(conveyorJson);
        const mappings = mapSha2Filename(parsed);
        const processed = preprocessObject(parsed, mappings);
        this.data = _.set(parsed, 'api_response.results', groupByScanner(processed));
    }
    toHdf() {
        const scannerRecordInput = Object.entries(_.get(this.data, 'api_response.results')).map(([scannerName, scannerData]) => [
            scannerName,
            new ConveyorMapper(scannerData, this.data, scannerName).toHdf()
        ]);
        return Object.fromEntries(scannerRecordInput);
    }
}
exports.ConveyorResults = ConveyorResults;
//# sourceMappingURL=conveyor-mapper.js.map