"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseXLSXAttestations = exports.addAttestationToHDF = exports.convertAttestationToSegment = exports.createAttestationMessage = exports.advanceDate = void 0;
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const moment_1 = __importDefault(require("moment"));
const ms_1 = __importDefault(require("ms"));
const xlsx_1 = __importDefault(require("xlsx"));
function advanceDate(date, frequency) {
    switch (frequency) {
        case 'annually':
            date.add(1, 'year');
            break;
        case 'semiannually':
            date.add(6, 'months');
            break;
        case 'quarterly':
            date.add(3, 'months');
            break;
        case 'monthly':
            date.add(1, 'month');
            break;
        case 'every2weeks':
            date.add(2, 'weeks');
            break;
        case 'fortnightly':
            date.add(2, 'weeks');
            break;
        case 'weekly':
            date.add(1, 'week');
            break;
        case 'every3days':
            date.add(3, 'day');
            break;
        case 'daily':
            date.add(1, 'day');
            break;
        default:
            const msTime = (0, ms_1.default)(frequency);
            if (!msTime) {
                throw new Error('Unknown date format: ' + frequency);
            }
            else {
                date.add(msTime, 'milliseconds');
            }
            break;
    }
    return date;
}
exports.advanceDate = advanceDate;
function createAttestationMessage(attestation, expired) {
    let message = '';
    if (expired) {
        message += 'Expired Attestation:\n';
        message += `Expired Status: ${attestation.status}\n`;
        message += `Expired Explanation: ${attestation.explanation}\n\n`;
    }
    else {
        message += 'Attestation:\n';
        message += `Status: ${attestation.status}\n`;
        message += `Explanation: ${attestation.explanation}\n\n`;
    }
    message += `Updated: ${attestation.updated}\n`;
    message += `Updated By: ${attestation.updated_by}\n`;
    message += `Frequency: ${attestation.frequency}`;
    return message;
}
exports.createAttestationMessage = createAttestationMessage;
function convertAttestationToSegment(attestation) {
    const expirationDate = advanceDate((0, moment_1.default)(attestation.updated), attestation.frequency);
    if (expirationDate.isBefore(new Date())) {
        console.log(`Warning: Attestation Expired: ${attestation.control_id} (Expired at ${expirationDate.toString()})`);
        return {
            code_desc: 'Manual verification status provided through attestation has expired',
            status: inspecjs_1.ExecJSON.ControlResultStatus.Skipped,
            message: createAttestationMessage(attestation, true),
            start_time: new Date().toISOString()
        };
    }
    else {
        return {
            code_desc: 'Manually verified status provided through attestation',
            status: attestation.status,
            message: createAttestationMessage(attestation, false),
            start_time: new Date().toISOString()
        };
    }
}
exports.convertAttestationToSegment = convertAttestationToSegment;
function addAttestationToHDF(hdf, attestations) {
    for (const profile of hdf.profiles) {
        for (const control of profile.controls) {
            for (const attestation of attestations) {
                if (attestation.control_id.toLowerCase() === control.id.toLowerCase()) {
                    if (['passed', 'failed'].includes(attestation.status)) {
                        control.attestation_data =
                            attestation;
                        control.results.push(convertAttestationToSegment(attestation));
                    }
                    else {
                        console.error(`Invalid attestation status for Control ${control.id}: ${attestation.status} - Status must be passed or failed. To make this control 'not applicable', use a waiver.`);
                    }
                }
            }
        }
    }
    return hdf;
}
exports.addAttestationToHDF = addAttestationToHDF;
async function parseXLSXAttestations(attestationXLSX) {
    return new Promise((resolve) => {
        const workbook = xlsx_1.default.read(attestationXLSX, {
            cellDates: true
        });
        const sheet = workbook.Sheets['attestations'];
        const data = xlsx_1.default.utils.sheet_to_json(sheet);
        const attestations = data.map((attestation) => {
            const lowerAttestation = lodash_1.default.mapKeys(attestation, (v, k) => {
                return k.toLowerCase().replace(/\s/g, '_');
            });
            return {
                control_id: getFirstPath(lowerAttestation, [
                    'control_id',
                    'id',
                    'control'
                ]),
                explanation: getFirstPath(lowerAttestation, ['explanation', 'explain']),
                frequency: getFirstPath(lowerAttestation, ['frequency']),
                status: getFirstPath(lowerAttestation, ['status']),
                updated: getFirstPath(lowerAttestation, ['updated', 'updated_at']),
                updated_by: getFirstPath(lowerAttestation, ['updated_by'])
            };
        });
        resolve(attestations);
    });
}
exports.parseXLSXAttestations = parseXLSXAttestations;
function getFirstPath(object, paths) {
    const index = lodash_1.default.findIndex(paths, (p) => hasPath(object, p));
    if (index === -1) {
        throw new Error(`Attestation is missing one of these paths: ${paths.join(', ')}`);
    }
    else {
        return lodash_1.default.get(object, paths[index]);
    }
}
function hasPath(file, path) {
    let pathArray;
    if (typeof path === 'string') {
        pathArray = [path];
    }
    else {
        pathArray = path;
    }
    return lodash_1.default.some(pathArray, (p) => lodash_1.default.has(file, p));
}
//# sourceMappingURL=attestations.js.map