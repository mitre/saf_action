"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseXLSXAttestations = exports.addAttestationToHDF = exports.convertAttestationToSegment = exports.createAttestationMessage = exports.advanceDate = void 0;
const XLSX = __importStar(require("@e965/xlsx"));
const inspecjs_1 = require("inspecjs");
const _ = __importStar(require("lodash"));
const moment_1 = __importDefault(require("moment"));
function advanceDate(date, frequency) {
    switch (frequency) {
        case 'annually':
            date.add(1, 'year');
            break;
        case 'semiannually':
            date.add(6, 'months');
            break;
        case 'quarterly':
            date.add(3, 'months');
            break;
        case 'monthly':
            date.add(1, 'month');
            break;
        case 'every2weeks':
            date.add(2, 'weeks');
            break;
        case 'fortnightly':
            date.add(2, 'weeks');
            break;
        case 'weekly':
            date.add(1, 'week');
            break;
        case 'every3days':
            date.add(3, 'day');
            break;
        case 'daily':
            date.add(1, 'day');
            break;
        default: {
            const re = /(\d{1,10}(?:.\d{0,10})?)(\s{0,10})([a-z])/;
            const match = re.exec(frequency);
            if (!match) {
                throw new Error('Unknown date format: ' +
                    frequency +
                    '. Please use a number followed by d/w/m/y to indicate days, weeks, months, or years, e.g. 1d/2w/3m/1y/custom.');
            }
            const number = match[1];
            const unit = match[3];
            switch (unit) {
                case 'd':
                    date.add(number, 'days');
                    break;
                case 'w':
                    date.add(number, 'weeks');
                    break;
                case 'm':
                    date.add(number, 'months');
                    break;
                case 'y':
                    date.add(number, 'years');
                    break;
            }
            break;
        }
    }
    return date;
}
exports.advanceDate = advanceDate;
function createAttestationMessage(attestation, expired) {
    let message = '';
    if (expired) {
        message += 'Expired Attestation:\n';
        message += `Expired Status: ${attestation.status}\n`;
        message += `Expired Explanation: ${attestation.explanation}\n\n`;
    }
    else {
        message += 'Attestation:\n';
        message += `Status: ${attestation.status}\n`;
        message += `Explanation: ${attestation.explanation}\n\n`;
    }
    message += `Updated: ${attestation.updated}\n`;
    message += `Updated By: ${attestation.updated_by}\n`;
    message += `Frequency: ${attestation.frequency}`;
    return message;
}
exports.createAttestationMessage = createAttestationMessage;
function convertAttestationToSegment(attestation) {
    const expirationDate = advanceDate((0, moment_1.default)(attestation.updated), attestation.frequency);
    if (expirationDate.isBefore(new Date())) {
        console.log(`Warning: Attestation Expired: ${attestation.control_id} (Expired at ${expirationDate.toString()})`);
        return {
            code_desc: 'Manual verification status provided through attestation has expired',
            status: inspecjs_1.ExecJSON.ControlResultStatus.Skipped,
            message: createAttestationMessage(attestation, true),
            start_time: new Date().toISOString()
        };
    }
    else {
        return {
            code_desc: 'Manually verified status provided through attestation',
            status: attestation.status,
            message: createAttestationMessage(attestation, false),
            start_time: new Date().toISOString()
        };
    }
}
exports.convertAttestationToSegment = convertAttestationToSegment;
function addAttestationToHDF(hdf, attestations) {
    for (const attestation of attestations) {
        let found_control = false;
        for (const profile of hdf.profiles) {
            for (const control of profile.controls) {
                if (attestationCanBeAdded(attestation, control)) {
                    found_control = true;
                    if (['passed', 'failed'].includes(attestation.status)) {
                        control.attestation_data =
                            attestation;
                        control.results.push(convertAttestationToSegment(attestation));
                    }
                    else {
                        console.error(`Invalid attestation status for Control ${control.id}: ${attestation.status} - Status must be passed or failed. To make this control 'not applicable', use a waiver.`);
                    }
                }
            }
        }
        if (!found_control) {
            console.error(`Control ${attestation.control_id} not found in HDF. Skipping attestation.`);
        }
    }
    return hdf;
}
exports.addAttestationToHDF = addAttestationToHDF;
async function parseXLSXAttestations(attestationXLSX) {
    return new Promise((resolve) => {
        const workbook = XLSX.read(attestationXLSX, {
            cellDates: true
        });
        const sheet = workbook.Sheets['attestations'];
        const data = XLSX.utils.sheet_to_json(sheet);
        const attestations = data.map((attestation) => {
            const lowerAttestation = _.mapKeys(attestation, (_v, k) => {
                return k.toLowerCase().replace(/\s/g, '_');
            });
            return {
                control_id: getFirstPath(lowerAttestation, [
                    'control_id',
                    'id',
                    'control'
                ]),
                explanation: getFirstPath(lowerAttestation, ['explanation', 'explain']),
                frequency: getFirstPath(lowerAttestation, ['frequency']),
                status: getFirstPath(lowerAttestation, ['status']),
                updated: getFirstPath(lowerAttestation, ['updated', 'updated_at']),
                updated_by: getFirstPath(lowerAttestation, ['updated_by'])
            };
        });
        resolve(attestations);
    });
}
exports.parseXLSXAttestations = parseXLSXAttestations;
function attestationCanBeAdded(attestation, control) {
    if (attestation.control_id.toLowerCase() === control.id.toLowerCase()) {
        if (control.results[0].status === 'skipped') {
            return true;
        }
        else {
            console.error('Invalid control selected: Control must have "skipped" status to be attested');
            return false;
        }
    }
    else {
        return false;
    }
}
function getFirstPath(object, paths) {
    const index = _.findIndex(paths, (p) => hasPath(object, p));
    if (index === -1) {
        throw new Error(`Attestation is missing one of these paths: ${paths.join(', ')}`);
    }
    const stringOrDate = _.get(object, paths[index]);
    if (_.isString(stringOrDate)) {
        return stringOrDate;
    }
    return `${stringOrDate.getFullYear()}-${String(stringOrDate.getMonth() + 1).padStart(2, '0')}-${String(stringOrDate.getDate()).padStart(2, '0')}`;
}
function hasPath(file, path) {
    let pathArray;
    if (typeof path === 'string') {
        pathArray = [path];
    }
    else {
        pathArray = path;
    }
    return _.some(pathArray, (p) => _.has(file, p));
}
//# sourceMappingURL=attestations.js.map