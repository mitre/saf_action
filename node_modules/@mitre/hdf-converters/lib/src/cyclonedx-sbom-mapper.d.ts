import { ExecJSON } from 'inspecjs';
import { BaseConverter, ILookupPath, MappedTransform } from './base-converter';
import { CycloneDXSoftwareBillOfMaterialSpecification, CycloneDXSoftwareBillOfMaterialsStandard, CycloneDXBillOfMaterialsStandardVulnerability, CycloneDXSoftwareBillOfMaterialsStandardVulnerability, ComponentClass, ComponentObject } from '../types/cyclonedx';
type IntermediaryComponent = Omit<ComponentClass | ComponentObject, 'components'> & {
    components?: IntermediaryComponent[];
    affectingVulnerabilities?: string[];
    isDummy?: boolean;
};
type IntermediaryVulnerability = (CycloneDXBillOfMaterialsStandardVulnerability | CycloneDXSoftwareBillOfMaterialsStandardVulnerability) & {
    affectedComponents?: number[];
};
type DataStorage = {
    components: IntermediaryComponent[];
    vulnerabilities: IntermediaryVulnerability[];
    raw: CycloneDXSoftwareBillOfMaterialSpecification | CycloneDXSoftwareBillOfMaterialsStandard;
};
export declare class CycloneDXSBOMResults {
    data: DataStorage;
    withRaw: boolean;
    constructor(sbomJson: string, withRaw?: boolean);
    flattenComponents(data: DataStorage): void;
    generateIntermediary(data: DataStorage): void;
    formatVEX(data: DataStorage): void;
    toHdf(): ExecJSON.Execution;
}
export declare class CycloneDXSBOMMapper extends BaseConverter<DataStorage> {
    withRaw: boolean;
    getComponentValueAtIndex(index: number, keys: string[]): Record<string, unknown>;
    mappings: MappedTransform<ExecJSON.Execution & {
        passthrough: unknown;
    }, ILookupPath>;
    constructor(exportJson: DataStorage, withRaw?: boolean);
}
export {};
