"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsConfigMapper = void 0;
const client_config_service_1 = require("@aws-sdk/client-config-service");
const node_http_handler_1 = require("@smithy/node-http-handler");
const https_1 = __importDefault(require("https"));
const inspecjs_1 = require("inspecjs");
const _ = __importStar(require("lodash"));
const package_json_1 = require("../package.json");
const AwsConfigMapping_1 = require("./mappings/AwsConfigMapping");
const NOT_APPLICABLE_MSG = 'No AWS resources found to evaluate compliance for this rule';
const INSUFFICIENT_DATA_MSG = 'Not enough data has been collected to determine compliance yet.';
const NAME = 'AWS Config';
const AWS_CONFIG_MAPPING = new AwsConfigMapping_1.AwsConfigMapping();
class AwsConfigMapper {
    constructor(options, verifySSLCertificates = true, certificate) {
        const clientOptions = {
            ...options,
            requestHandler: new node_http_handler_1.NodeHttpHandler({
                httpsAgent: new https_1.default.Agent({
                    rejectUnauthorized: verifySSLCertificates,
                    ca: certificate
                })
            })
        };
        this.configService = new client_config_service_1.ConfigService(clientOptions);
        this.results = [];
        this.issues = this.getAllConfigRules();
    }
    delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
    async getAllConfigRules() {
        let params = {
            ConfigRuleNames: [],
            NextToken: ''
        };
        const configRules = [];
        let response = await this.getConfigRulePage(params);
        if (response.ConfigRules === undefined) {
            throw new Error('No data was returned');
        }
        else {
            while (response !== undefined && response.ConfigRules !== undefined) {
                response.ConfigRules.forEach((rule) => {
                    configRules.push(rule);
                });
                if (response.NextToken) {
                    params = _.set(params, 'NextToken', response.NextToken);
                }
                else {
                    break;
                }
                response = await this.getConfigRulePage(params);
            }
        }
        this.results = await this.getResults(configRules);
        return configRules;
    }
    async getConfigRulePage(params) {
        await this.delay(150);
        return this.configService.describeConfigRules(params);
    }
    async getResults(configRules) {
        const complianceResults = await this.fetchAllComplianceInfo(configRules);
        const ruleData = [];
        const allRulesResolved = [];
        for (const configRule of configRules) {
            const result = [];
            let params = {
                ConfigRuleName: configRule.ConfigRuleName || '',
                Limit: 100
            };
            await this.delay(150);
            let response = await this.configService.getComplianceDetailsByConfigRule(params);
            let ruleResults = response.EvaluationResults || [];
            allRulesResolved.push(...ruleResults);
            while (response.NextToken !== undefined) {
                params = _.set(params, 'NextToken', response.NextToken);
                await this.delay(150);
                response = await this.configService.getComplianceDetailsByConfigRule(params);
                ruleResults = ruleResults === null || ruleResults === void 0 ? void 0 : ruleResults.concat(response.EvaluationResults || []);
                allRulesResolved.push(...ruleResults);
            }
            ruleResults.forEach((evaluation) => {
                var _a, _b, _c;
                const hdfResult = {
                    code_desc: this.getCodeDesc(evaluation),
                    start_time: ((_a = evaluation.ConfigRuleInvokedTime) === null || _a === void 0 ? void 0 : _a.toISOString()) || '',
                    run_time: this.getRunTime(evaluation),
                    status: this.getStatus(evaluation),
                    message: this.getMessage(evaluation, this.getCodeDesc(evaluation), this.getStatus(evaluation))
                };
                result.push(hdfResult);
                const currentDate = new Date().toISOString();
                if (result.length === 0) {
                    switch ((_c = (_b = complianceResults.find((complianceResult) => complianceResult.ConfigRuleName === configRule.ConfigRuleName)) === null || _b === void 0 ? void 0 : _b.Compliance) === null || _c === void 0 ? void 0 : _c.ComplianceType) {
                        case 'NOT_APPLICABLE':
                            return [
                                {
                                    run_time: 0,
                                    code_desc: NOT_APPLICABLE_MSG,
                                    skip_message: NOT_APPLICABLE_MSG,
                                    start_time: currentDate,
                                    status: inspecjs_1.ExecJSON.ControlResultStatus.Skipped
                                }
                            ];
                        case 'INSUFFICIENT_DATA':
                            return [
                                {
                                    run_time: 0,
                                    code_desc: INSUFFICIENT_DATA_MSG,
                                    skip_message: INSUFFICIENT_DATA_MSG,
                                    start_time: currentDate,
                                    status: inspecjs_1.ExecJSON.ControlResultStatus.Skipped
                                }
                            ];
                        default:
                            return [];
                    }
                }
                else {
                    return ruleData.push(result);
                }
            });
        }
        return this.appendResourceNamesToResults(await Promise.all(ruleData), await this.extractResourceNamesFromIds(allRulesResolved));
    }
    async appendResourceNamesToResults(completedControlResults, extractedResourceNames) {
        return completedControlResults.map((completedControlResult) => completedControlResult.map((completedControl) => {
            for (const extractedResourceName in extractedResourceNames) {
                if (completedControl.code_desc.indexOf(JSON.stringify(extractedResourceName)
                    .replace(/\"/gi, '')
                    .replace(/{/gi, '')
                    .replace(/}/gi, '')) !== -1) {
                    return {
                        ...completedControl,
                        code_desc: `${completedControl.code_desc}, resource_name: ${extractedResourceNames[extractedResourceName]}`
                    };
                }
            }
            return completedControl;
        }));
    }
    async extractResourceNamesFromIds(evaluationResults) {
        var _a;
        const resourceMap = {};
        const resolvedResourcesMap = {};
        evaluationResults.forEach((result) => {
            var _a, _b;
            const resourceType = client_config_service_1.ResourceType[_.get(result, 'EvaluationResultIdentifier.EvaluationResultQualifier.ResourceType')];
            const resourceId = _.get(result, 'EvaluationResultIdentifier.EvaluationResultQualifier.ResourceId');
            if (resourceType in resourceMap) {
                if (!((_a = resourceMap[resourceType]) === null || _a === void 0 ? void 0 : _a.includes(resourceId)) &&
                    typeof resourceId === 'string') {
                    (_b = resourceMap[resourceType]) === null || _b === void 0 ? void 0 : _b.push(resourceId);
                }
            }
            else {
                resourceMap[resourceType] = [resourceId];
            }
        });
        let resourceType;
        for (resourceType in resourceMap) {
            const resourceIDSlices = _.chunk(resourceMap[resourceType], 20);
            for (const slice of resourceIDSlices) {
                await this.delay(150);
                const resources = await this.configService.listDiscoveredResources({
                    resourceType: resourceType,
                    resourceIds: slice
                });
                (_a = resources.resourceIdentifiers) === null || _a === void 0 ? void 0 : _a.forEach((resource) => {
                    if (resource.resourceId && resource.resourceName) {
                        resolvedResourcesMap[resource.resourceId] = resource.resourceName;
                    }
                });
            }
        }
        return resolvedResourcesMap;
    }
    getCodeDesc(result) {
        let output = '';
        if (result.EvaluationResultIdentifier !== undefined &&
            result.EvaluationResultIdentifier.EvaluationResultQualifier !== undefined) {
            output = JSON.stringify(result.EvaluationResultIdentifier.EvaluationResultQualifier)
                .replace(/\"/gi, '')
                .replace(/{/gi, '')
                .replace(/}/gi, '');
        }
        return output;
    }
    getRunTime(result) {
        let diff = 0;
        if (result.ResultRecordedTime !== undefined &&
            result.ConfigRuleInvokedTime !== undefined) {
            diff =
                (result.ResultRecordedTime.getTime() -
                    result.ConfigRuleInvokedTime.getTime()) /
                    1000;
        }
        return diff;
    }
    getStatus(result) {
        if (result.ComplianceType === 'COMPLIANT') {
            return inspecjs_1.ExecJSON.ControlResultStatus.Passed;
        }
        else if (result.ComplianceType === 'NON_COMPLIANT') {
            return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
        }
        else {
            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
        }
    }
    getMessage(result, codeDesc, status) {
        if (status === inspecjs_1.ExecJSON.ControlResultStatus.Failed) {
            return `${codeDesc}: ${result.Annotation || 'Rule does not pass rule compliance'}`;
        }
        else {
            return undefined;
        }
    }
    async fetchAllComplianceInfo(configRules) {
        var _a;
        const complianceResults = [];
        const configRuleSlices = _.chunk(configRules, 25);
        for (const slice of configRuleSlices) {
            await this.delay(150);
            const response = await this.configService.describeComplianceByConfigRule({
                ConfigRuleNames: slice.map((rule) => rule.ConfigRuleName || '')
            });
            if (response.ComplianceByConfigRules === undefined) {
                throw new Error('No compliance data was returned');
            }
            else {
                (_a = response.ComplianceByConfigRules) === null || _a === void 0 ? void 0 : _a.forEach((compliance) => complianceResults.push(compliance));
            }
        }
        return complianceResults;
    }
    hdfTags(configRule) {
        var _a;
        let result = {};
        const sourceIdentifier = (_a = configRule.Source) === null || _a === void 0 ? void 0 : _a.SourceIdentifier;
        result = _.set(result, 'nist', []);
        let defaultMatch = [];
        if (sourceIdentifier !== undefined) {
            defaultMatch = AWS_CONFIG_MAPPING.searchNIST([sourceIdentifier]);
        }
        if (Array.isArray(defaultMatch) && defaultMatch.length !== 0) {
            result = _.set(result, 'nist', _.get(result, 'nist').concat(defaultMatch));
        }
        return result;
    }
    checkText(configRule) {
        var _a;
        let params = [];
        if (configRule.InputParameters !== undefined &&
            configRule.InputParameters !== '{}') {
            params = configRule.InputParameters.replace(/{/gi, '')
                .replace(/}/gi, '')
                .split(',');
        }
        const checkText = [];
        checkText.push(`ARN: ${configRule.ConfigRuleArn || 'N/A'}`);
        checkText.push(`Source Identifier: ${((_a = configRule.Source) === null || _a === void 0 ? void 0 : _a.SourceIdentifier) || 'N/A'}`);
        if (params.length !== 0) {
            checkText.push(`${params.join('<br/>').replace(/\"/gi, '')}`);
        }
        return checkText.join('<br/>');
    }
    hdfDescriptions(configRule) {
        return [
            {
                data: this.checkText(configRule),
                label: 'check'
            }
        ];
    }
    getAccountId(arn) {
        const matches = arn.match(/:(\d{12}):config-rule/);
        if (matches === null) {
            return 'no-account-id';
        }
        else {
            return matches[0];
        }
    }
    async getControls() {
        let index = 0;
        return (await this.issues).map((issue) => {
            const control = {
                id: issue.ConfigRuleId || '',
                title: `${this.getAccountId(issue.ConfigRuleArn || '')} - ${issue.ConfigRuleName}`
                    .replace(/:/gi, '')
                    .replace(/config-rule/gi, ''),
                desc: issue.Description || null,
                impact: this.getImpact(issue),
                tags: this.hdfTags(issue),
                descriptions: this.hdfDescriptions(issue),
                refs: [],
                source_location: { ref: issue.ConfigRuleArn, line: 1 },
                code: '',
                results: this.results[index]
            };
            index++;
            return control;
        });
    }
    getImpact(issue) {
        if (_.get(issue, 'compliance') === 'NOT_APPLICABLE') {
            return 0;
        }
        else {
            return 0.5;
        }
    }
    async toHdf() {
        const hdf = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version,
                target_id: ''
            },
            version: package_json_1.version,
            statistics: {
                duration: null
            },
            profiles: [
                {
                    name: NAME,
                    version: '',
                    title: NAME,
                    maintainer: null,
                    summary: NAME,
                    license: null,
                    copyright: null,
                    copyright_email: null,
                    supports: [],
                    attributes: [],
                    depends: [],
                    groups: [],
                    status: 'loaded',
                    controls: await this.getControls(),
                    sha256: ''
                }
            ]
        };
        return hdf;
    }
}
exports.AwsConfigMapper = AwsConfigMapper;
//# sourceMappingURL=aws-config-mapper.js.map