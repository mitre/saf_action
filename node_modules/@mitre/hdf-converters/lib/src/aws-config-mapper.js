"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsConfigMapper = void 0;
const aws_sdk_1 = __importDefault(require("aws-sdk"));
const https_1 = __importDefault(require("https"));
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const package_json_1 = require("../package.json");
const AwsConfigMapping_1 = require("./mappings/AwsConfigMapping");
const NOT_APPLICABLE_MSG = 'No AWS resources found to evaluate compliance for this rule';
const INSUFFICIENT_DATA_MSG = 'Not enough data has been collected to determine compliance yet.';
const NAME = 'AWS Config';
const AWS_CONFIG_MAPPING = new AwsConfigMapping_1.AwsConfigMapping();
class AwsConfigMapper {
    constructor(options, verifySSLCertificates = true) {
        aws_sdk_1.default.config.update({
            httpOptions: {
                agent: new https_1.default.Agent({
                    rejectUnauthorized: verifySSLCertificates
                })
            }
        });
        this.configService = new aws_sdk_1.default.ConfigService(options);
        this.results = [];
        this.issues = this.getAllConfigRules();
    }
    delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
    async getAllConfigRules() {
        let params = {
            ConfigRuleNames: [],
            NextToken: ''
        };
        const configRules = [];
        let response = await this.getConfigRulePage(params);
        if (response.ConfigRules === undefined) {
            throw new Error('No data was returned');
        }
        else {
            while (response !== undefined && response.ConfigRules !== undefined) {
                response.ConfigRules.forEach((rule) => {
                    configRules.push(rule);
                });
                if (response.NextToken) {
                    params = lodash_1.default.set(params, 'NextToken', response.NextToken);
                }
                else {
                    break;
                }
                response = await this.getConfigRulePage(params);
            }
        }
        this.results = await this.getResults(configRules);
        return configRules;
    }
    chunkArray(sourceArray, chunkSize) {
        const result = [];
        for (let i = 0; i < sourceArray.length; i += chunkSize) {
            result.push(sourceArray.slice(i, i + chunkSize));
        }
        return result;
    }
    async getConfigRulePage(params) {
        await this.delay(150);
        return this.configService.describeConfigRules(params).promise();
    }
    async getResults(configRules) {
        const complianceResults = await this.fetchAllComplianceInfo(configRules);
        const ruleData = [];
        const allRulesResolved = [];
        for (const configRule of configRules) {
            const result = [];
            let params = {
                ConfigRuleName: configRule.ConfigRuleName || '',
                Limit: 100
            };
            await this.delay(150);
            let response = await this.configService
                .getComplianceDetailsByConfigRule(params)
                .promise();
            let ruleResults = response.EvaluationResults || [];
            allRulesResolved.push(...ruleResults);
            while (response.NextToken !== undefined) {
                params = lodash_1.default.set(params, 'NextToken', response.NextToken);
                await this.delay(150);
                response = await this.configService
                    .getComplianceDetailsByConfigRule(params)
                    .promise();
                ruleResults = ruleResults === null || ruleResults === void 0 ? void 0 : ruleResults.concat(response.EvaluationResults || []);
                allRulesResolved.push(...ruleResults);
            }
            ruleResults.forEach((evaluation) => {
                var _a, _b, _c;
                const hdfResult = {
                    code_desc: this.getCodeDesc(evaluation),
                    start_time: ((_a = evaluation.ConfigRuleInvokedTime) === null || _a === void 0 ? void 0 : _a.toISOString()) || '',
                    run_time: this.getRunTime(evaluation),
                    status: this.getStatus(evaluation),
                    message: this.getMessage(evaluation, this.getCodeDesc(evaluation), this.getStatus(evaluation))
                };
                result.push(hdfResult);
                const currentDate = new Date().toISOString();
                if (result.length === 0) {
                    switch ((_c = (_b = complianceResults.find((complianceResult) => complianceResult.ConfigRuleName === configRule.ConfigRuleName)) === null || _b === void 0 ? void 0 : _b.Compliance) === null || _c === void 0 ? void 0 : _c.ComplianceType) {
                        case 'NOT_APPLICABLE':
                            return [
                                {
                                    run_time: 0,
                                    code_desc: NOT_APPLICABLE_MSG,
                                    skip_message: NOT_APPLICABLE_MSG,
                                    start_time: currentDate,
                                    status: inspecjs_1.ExecJSON.ControlResultStatus.Skipped
                                }
                            ];
                        case 'INSUFFICIENT_DATA':
                            return [
                                {
                                    run_time: 0,
                                    code_desc: INSUFFICIENT_DATA_MSG,
                                    skip_message: INSUFFICIENT_DATA_MSG,
                                    start_time: currentDate,
                                    status: inspecjs_1.ExecJSON.ControlResultStatus.Skipped
                                }
                            ];
                        default:
                            return [];
                    }
                }
                else {
                    return ruleData.push(result);
                }
            });
        }
        return this.appendResourceNamesToResults(await Promise.all(ruleData), await this.extractResourceNamesFromIds(allRulesResolved));
    }
    async appendResourceNamesToResults(completedControlResults, extractedResourceNames) {
        return completedControlResults.map((completedControlResult) => completedControlResult.map((completedControl) => {
            for (const extractedResourceName in extractedResourceNames) {
                if (completedControl.code_desc.indexOf(JSON.stringify(extractedResourceName)
                    .replace(/\"/gi, '')
                    .replace(/{/gi, '')
                    .replace(/}/gi, '')) !== -1) {
                    return {
                        ...completedControl,
                        code_desc: `${completedControl.code_desc}, resource_name: ${extractedResourceNames[extractedResourceName]}`
                    };
                }
            }
            return completedControl;
        }));
    }
    async extractResourceNamesFromIds(evaluationResults) {
        var _a;
        const resourceMap = {};
        const resolvedResourcesMap = {};
        evaluationResults.forEach((result) => {
            const resourceType = lodash_1.default.get(result, 'EvaluationResultIdentifier.EvaluationResultQualifier.ResourceType');
            const resourceId = lodash_1.default.get(result, 'EvaluationResultIdentifier.EvaluationResultQualifier.ResourceId');
            if (!(resourceType in resourceMap)) {
                resourceMap[resourceType] = [resourceId];
            }
            else {
                if (!resourceMap[resourceType].includes(resourceId) &&
                    typeof resourceId === 'string') {
                    resourceMap[resourceType].push(resourceId);
                }
            }
        });
        for (const resourceType in resourceMap) {
            const resourceIDSlices = this.chunkArray(resourceMap[resourceType], 20);
            for (const slice of resourceIDSlices) {
                await this.delay(150);
                const resources = await this.configService
                    .listDiscoveredResources({
                    resourceType: resourceType,
                    resourceIds: slice
                })
                    .promise();
                (_a = resources.resourceIdentifiers) === null || _a === void 0 ? void 0 : _a.forEach((resource) => {
                    if (resource.resourceId && resource.resourceName) {
                        resolvedResourcesMap[resource.resourceId] = resource.resourceName;
                    }
                });
            }
        }
        return resolvedResourcesMap;
    }
    getCodeDesc(result) {
        let output = '';
        if (result.EvaluationResultIdentifier !== undefined &&
            result.EvaluationResultIdentifier.EvaluationResultQualifier !== undefined) {
            output = JSON.stringify(result.EvaluationResultIdentifier.EvaluationResultQualifier)
                .replace(/\"/gi, '')
                .replace(/{/gi, '')
                .replace(/}/gi, '');
        }
        return output;
    }
    getRunTime(result) {
        let diff = 0;
        if (result.ResultRecordedTime !== undefined &&
            result.ConfigRuleInvokedTime !== undefined) {
            diff =
                (result.ResultRecordedTime.getTime() -
                    result.ConfigRuleInvokedTime.getTime()) /
                    1000;
        }
        return diff;
    }
    getStatus(result) {
        if (result.ComplianceType === 'COMPLIANT') {
            return inspecjs_1.ExecJSON.ControlResultStatus.Passed;
        }
        else if (result.ComplianceType === 'NON_COMPLIANT') {
            return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
        }
        else {
            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
        }
    }
    getMessage(result, codeDesc, status) {
        if (status === inspecjs_1.ExecJSON.ControlResultStatus.Failed) {
            return `${codeDesc}: ${result.Annotation || 'Rule does not pass rule compliance'}`;
        }
        else {
            return undefined;
        }
    }
    async fetchAllComplianceInfo(configRules) {
        var _a;
        const complianceResults = [];
        const configRuleSlices = this.chunkArray(configRules, 25);
        for (const slice of configRuleSlices) {
            await this.delay(150);
            const response = await this.configService
                .describeComplianceByConfigRule({
                ConfigRuleNames: slice.map((rule) => rule.ConfigRuleName || '')
            })
                .promise();
            if (response.ComplianceByConfigRules === undefined) {
                throw new Error('No compliance data was returned');
            }
            else {
                (_a = response.ComplianceByConfigRules) === null || _a === void 0 ? void 0 : _a.forEach((compliance) => complianceResults.push(compliance));
            }
        }
        return complianceResults;
    }
    hdfTags(configRule) {
        var _a;
        let result = {};
        const sourceIdentifier = (_a = configRule.Source) === null || _a === void 0 ? void 0 : _a.SourceIdentifier;
        result = lodash_1.default.set(result, 'nist', []);
        let defaultMatch = [];
        if (sourceIdentifier !== undefined) {
            defaultMatch = AWS_CONFIG_MAPPING.searchNIST([sourceIdentifier]);
        }
        if (Array.isArray(defaultMatch) && defaultMatch.length !== 0) {
            result = lodash_1.default.set(result, 'nist', lodash_1.default.get(result, 'nist').concat(defaultMatch));
        }
        return result;
    }
    checkText(configRule) {
        var _a;
        let params = [];
        if (configRule.InputParameters !== undefined &&
            configRule.InputParameters !== '{}') {
            params = configRule.InputParameters.replace(/{/gi, '')
                .replace(/}/gi, '')
                .split(',');
        }
        const checkText = [];
        checkText.push(`ARN: ${configRule.ConfigRuleArn || 'N/A'}`);
        checkText.push(`Source Identifier: ${((_a = configRule.Source) === null || _a === void 0 ? void 0 : _a.SourceIdentifier) || 'N/A'}`);
        if (params.length !== 0) {
            checkText.push(`${params.join('<br/>').replace(/\"/gi, '')}`);
        }
        return checkText.join('<br/>');
    }
    hdfDescriptions(configRule) {
        return [
            {
                data: this.checkText(configRule),
                label: 'check'
            }
        ];
    }
    getAccountId(arn) {
        const matches = arn.match(/:(\d{12}):config-rule/);
        if (matches === null) {
            return 'no-account-id';
        }
        else {
            return matches[0];
        }
    }
    async getControls() {
        let index = 0;
        return (await this.issues).map((issue) => {
            const control = {
                id: issue.ConfigRuleId || '',
                title: `${this.getAccountId(issue.ConfigRuleArn || '')} - ${issue.ConfigRuleName}`
                    .replace(/:/gi, '')
                    .replace(/config-rule/gi, ''),
                desc: issue.Description || null,
                impact: this.getImpact(issue),
                tags: this.hdfTags(issue),
                descriptions: this.hdfDescriptions(issue),
                refs: [],
                source_location: { ref: issue.ConfigRuleArn, line: 1 },
                code: '',
                results: this.results[index]
            };
            index++;
            return control;
        });
    }
    getImpact(issue) {
        if (lodash_1.default.get(issue, 'compliance') === 'NOT_APPLICABLE') {
            return 0;
        }
        else {
            return 0.5;
        }
    }
    async toHdf() {
        const hdf = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version,
                target_id: ''
            },
            version: package_json_1.version,
            statistics: {
                duration: null
            },
            profiles: [
                {
                    name: NAME,
                    version: '',
                    title: NAME,
                    maintainer: null,
                    summary: NAME,
                    license: null,
                    copyright: null,
                    copyright_email: null,
                    supports: [],
                    attributes: [],
                    depends: [],
                    groups: [],
                    status: 'loaded',
                    controls: await this.getControls(),
                    sha256: ''
                }
            ]
        };
        return hdf;
    }
}
exports.AwsConfigMapper = AwsConfigMapper;
//# sourceMappingURL=aws-config-mapper.js.map